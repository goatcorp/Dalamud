// <auto-generated/>

using HexaGen.Runtime;
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Dalamud.Bindings.ImGui;

public unsafe partial class ImGui
{
		public static Vector2* ImVec2()
		{
			Vector2* ret = ImGuiNative.ImVec2();
			return ret;
		}
		public static Vector2* ImVec2(float x, float y)
		{
			Vector2* ret = ImGuiNative.ImVec2(x, y);
			return ret;
		}
		public static void Destroy(Vector2* self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref Vector2 self)
		{
			fixed (Vector2* pself = &self)
			{
				ImGuiNative.Destroy((Vector2*)pself);
			}
		}
		public static void Destroy(Vector4* self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref Vector4 self)
		{
			fixed (Vector4* pself = &self)
			{
				ImGuiNative.Destroy((Vector4*)pself);
			}
		}
		public static void Destroy(ImGuiStylePtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiStyle self)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiStyle*)pself);
			}
		}
		public static void Destroy(ImGuiIOPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiIO*)pself);
			}
		}
		public static void Destroy(ImGuiInputTextCallbackDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiInputTextCallbackData*)pself);
			}
		}
		public static void Destroy(ImGuiWindowClassPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiWindowClass self)
		{
			fixed (ImGuiWindowClass* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiWindowClass*)pself);
			}
		}
		public static void Destroy(ImGuiPayloadPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiPayload*)pself);
			}
		}
		public static void Destroy(ImGuiTableColumnSortSpecsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableColumnSortSpecs self)
		{
			fixed (ImGuiTableColumnSortSpecs* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableColumnSortSpecs*)pself);
			}
		}
		public static void Destroy(ImGuiTableSortSpecsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableSortSpecs self)
		{
			fixed (ImGuiTableSortSpecs* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableSortSpecs*)pself);
			}
		}
		public static void Destroy(ImGuiOnceUponAFramePtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiOnceUponAFrame self)
		{
			fixed (ImGuiOnceUponAFrame* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiOnceUponAFrame*)pself);
			}
		}
		public static void Destroy(ImGuiTextFilterPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTextFilter*)pself);
			}
		}
		public static void Destroy(ImGuiTextRangePtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTextRange self)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTextRange*)pself);
			}
		}
		public static void Destroy(ImGuiTextBufferPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTextBuffer*)pself);
			}
		}
		public static void Destroy(ImGuiStoragePairPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiStoragePair self)
		{
			fixed (ImGuiStoragePair* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiStoragePair*)pself);
			}
		}
		public static void Destroy(ImGuiListClipperPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiListClipper*)pself);
			}
		}
		public static void Destroy(ImColorPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImColor self)
		{
			fixed (ImColor* pself = &self)
			{
				ImGuiNative.Destroy((ImColor*)pself);
			}
		}
		public static void Destroy(ImDrawCmdPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImDrawCmd self)
		{
			fixed (ImDrawCmd* pself = &self)
			{
				ImGuiNative.Destroy((ImDrawCmd*)pself);
			}
		}
		public static void Destroy(ImDrawListSplitterPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ImGuiNative.Destroy((ImDrawListSplitter*)pself);
			}
		}
		public static void Destroy(ImDrawListPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.Destroy((ImDrawList*)pself);
			}
		}
		public static void Destroy(ImDrawDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				ImGuiNative.Destroy((ImDrawData*)pself);
			}
		}
		public static void Destroy(ImFontConfigPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImFontConfig self)
		{
			fixed (ImFontConfig* pself = &self)
			{
				ImGuiNative.Destroy((ImFontConfig*)pself);
			}
		}
		public static void Destroy(ImFontGlyphRangesBuilderPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImFontGlyphRangesBuilder self)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ImGuiNative.Destroy((ImFontGlyphRangesBuilder*)pself);
			}
		}
		public static void Destroy(ImFontAtlasCustomRectPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImFontAtlasCustomRect self)
		{
			fixed (ImFontAtlasCustomRect* pself = &self)
			{
				ImGuiNative.Destroy((ImFontAtlasCustomRect*)pself);
			}
		}
		public static void Destroy(ImFontAtlasPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.Destroy((ImFontAtlas*)pself);
			}
		}
		public static void Destroy(ImFontPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.Destroy((ImFont*)pself);
			}
		}
		public static void Destroy(ImGuiViewportPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiViewport*)pself);
			}
		}
		public static void Destroy(ImGuiPlatformIOPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiPlatformIO self)
		{
			fixed (ImGuiPlatformIO* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiPlatformIO*)pself);
			}
		}
		public static void Destroy(ImGuiPlatformMonitorPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiPlatformMonitor self)
		{
			fixed (ImGuiPlatformMonitor* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiPlatformMonitor*)pself);
			}
		}
		public static void Destroy(ImGuiPlatformImeDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiPlatformImeData self)
		{
			fixed (ImGuiPlatformImeData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiPlatformImeData*)pself);
			}
		}
		public static void Destroy(ImVec1Ptr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImVec1 self)
		{
			fixed (ImVec1* pself = &self)
			{
				ImGuiNative.Destroy((ImVec1*)pself);
			}
		}
		public static void Destroy(ImVec2IhPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImVec2Ih self)
		{
			fixed (ImVec2Ih* pself = &self)
			{
				ImGuiNative.Destroy((ImVec2Ih*)pself);
			}
		}
		public static void Destroy(ImRectPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiNative.Destroy((ImRect*)pself);
			}
		}
		public static void Destroy(ImDrawListSharedDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImDrawListSharedData self)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImGuiNative.Destroy((ImDrawListSharedData*)pself);
			}
		}
		public static void Destroy(ImGuiStyleModPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiStyleMod self)
		{
			fixed (ImGuiStyleMod* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiStyleMod*)pself);
			}
		}
		public static void Destroy(ImGuiComboPreviewDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiComboPreviewData self)
		{
			fixed (ImGuiComboPreviewData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiComboPreviewData*)pself);
			}
		}
		public static void Destroy(ImGuiMenuColumnsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiMenuColumns self)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiMenuColumns*)pself);
			}
		}
		public static void Destroy(ImGuiInputTextStatePtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiInputTextState*)pself);
			}
		}
		public static void Destroy(ImGuiPopupDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiPopupData self)
		{
			fixed (ImGuiPopupData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiPopupData*)pself);
			}
		}
		public static void Destroy(ImGuiNextWindowDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiNextWindowData*)pself);
			}
		}
		public static void Destroy(ImGuiNextItemDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiNextItemData*)pself);
			}
		}
		public static void Destroy(ImGuiLastItemDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiLastItemData self)
		{
			fixed (ImGuiLastItemData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiLastItemData*)pself);
			}
		}
		public static void Destroy(ImGuiStackSizesPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiStackSizes*)pself);
			}
		}
		public static void Destroy(ImGuiPtrOrIndexPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiPtrOrIndex self)
		{
			fixed (ImGuiPtrOrIndex* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiPtrOrIndex*)pself);
			}
		}
		public static void Destroy(ImGuiInputEventPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiInputEvent self)
		{
			fixed (ImGuiInputEvent* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiInputEvent*)pself);
			}
		}
		public static void Destroy(ImGuiListClipperDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiListClipperData self)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiListClipperData*)pself);
			}
		}
		public static void Destroy(ImGuiNavItemDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiNavItemData*)pself);
			}
		}
		public static void Destroy(ImGuiOldColumnDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiOldColumnData self)
		{
			fixed (ImGuiOldColumnData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiOldColumnData*)pself);
			}
		}
		public static void Destroy(ImGuiOldColumnsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiOldColumns self)
		{
			fixed (ImGuiOldColumns* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiOldColumns*)pself);
			}
		}
		public static void Destroy(ImGuiDockContextPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiDockContext self)
		{
			fixed (ImGuiDockContext* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiDockContext*)pself);
			}
		}
		public static void Destroy(ImGuiWindowSettingsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiWindowSettings*)pself);
			}
		}
		public static void Destroy(ImGuiSettingsHandlerPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiSettingsHandler self)
		{
			fixed (ImGuiSettingsHandler* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiSettingsHandler*)pself);
			}
		}
		public static void Destroy(ImGuiMetricsConfigPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiMetricsConfig self)
		{
			fixed (ImGuiMetricsConfig* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiMetricsConfig*)pself);
			}
		}
		public static void Destroy(ImGuiStackLevelInfoPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiStackLevelInfo self)
		{
			fixed (ImGuiStackLevelInfo* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiStackLevelInfo*)pself);
			}
		}
		public static void Destroy(ImGuiStackToolPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiStackTool self)
		{
			fixed (ImGuiStackTool* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiStackTool*)pself);
			}
		}
		public static void Destroy(ImGuiContextHookPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiContextHook self)
		{
			fixed (ImGuiContextHook* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiContextHook*)pself);
			}
		}
		public static void Destroy(ImGuiContextPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiContext self)
		{
			fixed (ImGuiContext* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiContext*)pself);
			}
		}
		public static void Destroy(ImGuiTabItemPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTabItem self)
		{
			fixed (ImGuiTabItem* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTabItem*)pself);
			}
		}
		public static void Destroy(ImGuiTabBarPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTabBar self)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTabBar*)pself);
			}
		}
		public static void Destroy(ImGuiTableColumnPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableColumn self)
		{
			fixed (ImGuiTableColumn* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableColumn*)pself);
			}
		}
		public static void Destroy(ImGuiTableInstanceDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableInstanceData self)
		{
			fixed (ImGuiTableInstanceData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableInstanceData*)pself);
			}
		}
		public static void Destroy(ImGuiTableTempDataPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableTempData self)
		{
			fixed (ImGuiTableTempData* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableTempData*)pself);
			}
		}
		public static void Destroy(ImGuiTableColumnSettingsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableColumnSettings self)
		{
			fixed (ImGuiTableColumnSettings* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableColumnSettings*)pself);
			}
		}
		public static void Destroy(ImGuiTableSettingsPtr self)
		{
			ImGuiNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiNative.Destroy((ImGuiTableSettings*)pself);
			}
		}
		public static Vector4* ImVec4()
		{
			Vector4* ret = ImGuiNative.ImVec4();
			return ret;
		}
		public static Vector4* ImVec4(float x, float y, float z, float w)
		{
			Vector4* ret = ImGuiNative.ImVec4(x, y, z, w);
			return ret;
		}
		public static ImGuiContextPtr CreateContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = ImGuiNative.CreateContext(sharedFontAtlas);
			return ret;
		}
		public static ImGuiContextPtr CreateContext()
		{
			ImGuiContextPtr ret = ImGuiNative.CreateContext((ImFontAtlas*)(default));
			return ret;
		}
		public static ImGuiContextPtr CreateContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = ImGuiNative.CreateContext((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}
		public static void DestroyContext(ImGuiContextPtr ctx)
		{
			ImGuiNative.DestroyContext(ctx);
		}
		public static void DestroyContext()
		{
			ImGuiNative.DestroyContext((ImGuiContext*)(default));
		}
		public static void DestroyContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiNative.DestroyContext((ImGuiContext*)pctx);
			}
		}
		public static ImGuiContextPtr GetCurrentContext()
		{
			ImGuiContextPtr ret = ImGuiNative.GetCurrentContext();
			return ret;
		}
		public static void SetCurrentContext(ImGuiContextPtr ctx)
		{
			ImGuiNative.SetCurrentContext(ctx);
		}
		public static void SetCurrentContext(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiNative.SetCurrentContext((ImGuiContext*)pctx);
			}
		}
		public static ImGuiIOPtr GetIO()
		{
			ImGuiIOPtr ret = ImGuiNative.GetIO();
			return ret;
		}
		public static ImGuiStylePtr GetStyle()
		{
			ImGuiStylePtr ret = ImGuiNative.GetStyle();
			return ret;
		}
		public static void NewFrame()
		{
			ImGuiNative.NewFrame();
		}
		public static void EndFrame()
		{
			ImGuiNative.EndFrame();
		}
		public static void Render()
		{
			ImGuiNative.Render();
		}
		public static ImDrawDataPtr GetDrawData()
		{
			ImDrawDataPtr ret = ImGuiNative.GetDrawData();
			return ret;
		}
		public static void ShowDemoWindow(bool* pOpen)
		{
			ImGuiNative.ShowDemoWindow(pOpen);
		}
		public static void ShowDemoWindow()
		{
			ImGuiNative.ShowDemoWindow((bool*)(default));
		}
		public static void ShowDemoWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ImGuiNative.ShowDemoWindow((bool*)ppOpen);
			}
		}
		public static void ShowMetricsWindow(bool* pOpen)
		{
			ImGuiNative.ShowMetricsWindow(pOpen);
		}
		public static void ShowMetricsWindow()
		{
			ImGuiNative.ShowMetricsWindow((bool*)(default));
		}
		public static void ShowMetricsWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ImGuiNative.ShowMetricsWindow((bool*)ppOpen);
			}
		}
		public static void ShowDebugLogWindow(bool* pOpen)
		{
			ImGuiNative.ShowDebugLogWindow(pOpen);
		}
		public static void ShowDebugLogWindow()
		{
			ImGuiNative.ShowDebugLogWindow((bool*)(default));
		}
		public static void ShowDebugLogWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ImGuiNative.ShowDebugLogWindow((bool*)ppOpen);
			}
		}
		public static void ShowStackToolWindow(bool* pOpen)
		{
			ImGuiNative.ShowStackToolWindow(pOpen);
		}
		public static void ShowStackToolWindow()
		{
			ImGuiNative.ShowStackToolWindow((bool*)(default));
		}
		public static void ShowStackToolWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ImGuiNative.ShowStackToolWindow((bool*)ppOpen);
			}
		}
		public static void ShowAboutWindow(bool* pOpen)
		{
			ImGuiNative.ShowAboutWindow(pOpen);
		}
		public static void ShowAboutWindow()
		{
			ImGuiNative.ShowAboutWindow((bool*)(default));
		}
		public static void ShowAboutWindow(ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ImGuiNative.ShowAboutWindow((bool*)ppOpen);
			}
		}
		public static void ShowStyleEditor(ImGuiStylePtr reference)
		{
			ImGuiNative.ShowStyleEditor(reference);
		}
		public static void ShowStyleEditor()
		{
			ImGuiNative.ShowStyleEditor((ImGuiStyle*)(default));
		}
		public static void ShowStyleEditor(ref ImGuiStyle reference)
		{
			fixed (ImGuiStyle* preference = &reference)
			{
				ImGuiNative.ShowStyleEditor((ImGuiStyle*)preference);
			}
		}
		public static bool ShowStyleSelector(byte* label)
		{
			byte ret = ImGuiNative.ShowStyleSelector(label);
			return ret != 0;
		}
		public static bool ShowStyleSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.ShowStyleSelector((byte*)plabel);
				return ret != 0;
			}
		}
		public static bool ShowStyleSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.ShowStyleSelector((byte*)plabel);
				return ret != 0;
			}
		}
		public static bool ShowStyleSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ShowStyleSelector(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void ShowFontSelector(byte* label)
		{
			ImGuiNative.ShowFontSelector(label);
		}
		public static void ShowFontSelector(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.ShowFontSelector((byte*)plabel);
			}
		}
		public static void ShowFontSelector(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.ShowFontSelector((byte*)plabel);
			}
		}
		public static void ShowFontSelector(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.ShowFontSelector(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ShowUserGuide()
		{
			ImGuiNative.ShowUserGuide();
		}
		public static byte* GetVersion()
		{
			byte* ret = ImGuiNative.GetVersion();
			return ret;
		}
		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.GetVersion());
			return ret;
		}
		public static void StyleColorsDark(ImGuiStylePtr dst)
		{
			ImGuiNative.StyleColorsDark(dst);
		}
		public static void StyleColorsDark()
		{
			ImGuiNative.StyleColorsDark((ImGuiStyle*)(default));
		}
		public static void StyleColorsDark(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				ImGuiNative.StyleColorsDark((ImGuiStyle*)pdst);
			}
		}
		public static void StyleColorsLight(ImGuiStylePtr dst)
		{
			ImGuiNative.StyleColorsLight(dst);
		}
		public static void StyleColorsLight()
		{
			ImGuiNative.StyleColorsLight((ImGuiStyle*)(default));
		}
		public static void StyleColorsLight(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				ImGuiNative.StyleColorsLight((ImGuiStyle*)pdst);
			}
		}
		public static void StyleColorsClassic(ImGuiStylePtr dst)
		{
			ImGuiNative.StyleColorsClassic(dst);
		}
		public static void StyleColorsClassic()
		{
			ImGuiNative.StyleColorsClassic((ImGuiStyle*)(default));
		}
		public static void StyleColorsClassic(ref ImGuiStyle dst)
		{
			fixed (ImGuiStyle* pdst = &dst)
			{
				ImGuiNative.StyleColorsClassic((ImGuiStyle*)pdst);
			}
		}
		public static bool Begin(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.Begin(name, pOpen, flags);
			return ret != 0;
		}
		public static bool Begin(byte* name, bool* pOpen)
		{
			byte ret = ImGuiNative.Begin(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool Begin(byte* name)
		{
			byte ret = ImGuiNative.Begin(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool Begin(byte* name, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.Begin(name, (bool*)(default), flags);
			return ret != 0;
		}
		public static bool Begin(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}
		public static bool Begin(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool Begin(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool Begin(ref byte name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}
		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}
		public static bool Begin(ReadOnlySpan<byte> name, bool* pOpen)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool Begin(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool Begin(ReadOnlySpan<byte> name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.Begin((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}
		public static bool Begin(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Begin(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Begin(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Begin(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Begin(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Begin(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Begin(string name, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Begin(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Begin(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.Begin(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}
		public static bool Begin(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.Begin(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool Begin(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.Begin((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}
		public static bool Begin(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.Begin((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.Begin((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}
		public static bool Begin(ReadOnlySpan<byte> name, ref bool pOpen)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.Begin((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool Begin(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.Begin(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Begin(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.Begin(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void Begin(ImGuiListClipperPtr self, int itemsCount, float itemsHeight)
		{
			ImGuiNative.Begin(self, itemsCount, itemsHeight);
		}
		public static void Begin(ImGuiListClipperPtr self, int itemsCount)
		{
			ImGuiNative.Begin(self, itemsCount, (float)(-1.0f));
		}
		public static void Begin(ref ImGuiListClipper self, int itemsCount, float itemsHeight)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ImGuiNative.Begin((ImGuiListClipper*)pself, itemsCount, itemsHeight);
			}
		}
		public static void Begin(ref ImGuiListClipper self, int itemsCount)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ImGuiNative.Begin((ImGuiListClipper*)pself, itemsCount, (float)(-1.0f));
			}
		}
		public static void End()
		{
			ImGuiNative.End();
		}
		public static void End(ImGuiListClipperPtr self)
		{
			ImGuiNative.End(self);
		}
		public static void End(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ImGuiNative.End((ImGuiListClipper*)pself);
			}
		}
		public static bool BeginChild(byte* strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(strId, size, border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}
		public static bool BeginChild(byte* strId, Vector2 size, bool border)
		{
			byte ret = ImGuiNative.BeginChild(strId, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(byte* strId, Vector2 size)
		{
			byte ret = ImGuiNative.BeginChild(strId, size, (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(byte* strId)
		{
			byte ret = ImGuiNative.BeginChild(strId, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(byte* strId, bool border)
		{
			byte ret = ImGuiNative.BeginChild(strId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(byte* strId, Vector2 size, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(strId, size, (byte)(0), flags);
			return ret != 0;
		}
		public static bool BeginChild(byte* strId, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(strId, (Vector2)(new Vector2(0,0)), (byte)(0), flags);
			return ret != 0;
		}
		public static bool BeginChild(byte* strId, bool border, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(strId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}
		public static bool BeginChild(ref byte strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId, Vector2 size, bool border)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, (byte)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId, bool border)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId, Vector2 size, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, (byte)(0), flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), (byte)(0), flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ref byte strId, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, bool border)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, (byte)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, bool border)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, Vector2 size, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, size, (byte)(0), flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), (byte)(0), flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(ReadOnlySpan<byte> strId, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginChild((byte*)pstrId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}
		public static bool BeginChild(string strId, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, size, border ? (byte)1 : (byte)0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId, Vector2 size, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, size, (byte)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId, Vector2 size, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, size, (byte)(0), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, (Vector2)(new Vector2(0,0)), (byte)(0), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(string strId, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginChild(pStr0, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginChild(uint id, Vector2 size, bool border, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(id, size, border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}
		public static bool BeginChild(uint id, Vector2 size, bool border)
		{
			byte ret = ImGuiNative.BeginChild(id, size, border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(uint id, Vector2 size)
		{
			byte ret = ImGuiNative.BeginChild(id, size, (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(uint id)
		{
			byte ret = ImGuiNative.BeginChild(id, (Vector2)(new Vector2(0,0)), (byte)(0), (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(uint id, bool border)
		{
			byte ret = ImGuiNative.BeginChild(id, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginChild(uint id, Vector2 size, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(id, size, (byte)(0), flags);
			return ret != 0;
		}
		public static bool BeginChild(uint id, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(id, (Vector2)(new Vector2(0,0)), (byte)(0), flags);
			return ret != 0;
		}
		public static bool BeginChild(uint id, bool border, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChild(id, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}
		public static void EndChild()
		{
			ImGuiNative.EndChild();
		}
		public static bool IsWindowAppearing()
		{
			byte ret = ImGuiNative.IsWindowAppearing();
			return ret != 0;
		}
		public static bool IsWindowCollapsed()
		{
			byte ret = ImGuiNative.IsWindowCollapsed();
			return ret != 0;
		}
		public static bool IsWindowFocused(ImGuiFocusedFlags flags)
		{
			byte ret = ImGuiNative.IsWindowFocused(flags);
			return ret != 0;
		}
		public static bool IsWindowFocused()
		{
			byte ret = ImGuiNative.IsWindowFocused((ImGuiFocusedFlags)(0));
			return ret != 0;
		}
		public static bool IsWindowHovered(ImGuiHoveredFlags flags)
		{
			byte ret = ImGuiNative.IsWindowHovered(flags);
			return ret != 0;
		}
		public static bool IsWindowHovered()
		{
			byte ret = ImGuiNative.IsWindowHovered((ImGuiHoveredFlags)(0));
			return ret != 0;
		}
		public static ImDrawListPtr GetWindowDrawList()
		{
			ImDrawListPtr ret = ImGuiNative.GetWindowDrawList();
			return ret;
		}
		public static float GetWindowDpiScale()
		{
			float ret = ImGuiNative.GetWindowDpiScale();
			return ret;
		}
		public static Vector2 GetWindowPos()
		{
			Vector2 ret;
			ImGuiNative.GetWindowPos(&ret);
			return ret;
		}
		public static void GetWindowPos(Vector2* pOut)
		{
			ImGuiNative.GetWindowPos(pOut);
		}
		public static void GetWindowPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetWindowPos((Vector2*)ppOut);
			}
		}
		public static Vector2 GetWindowSize()
		{
			Vector2 ret;
			ImGuiNative.GetWindowSize(&ret);
			return ret;
		}
		public static void GetWindowSize(Vector2* pOut)
		{
			ImGuiNative.GetWindowSize(pOut);
		}
		public static void GetWindowSize(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetWindowSize((Vector2*)ppOut);
			}
		}
		public static float GetWindowWidth()
		{
			float ret = ImGuiNative.GetWindowWidth();
			return ret;
		}
		public static float GetWindowHeight()
		{
			float ret = ImGuiNative.GetWindowHeight();
			return ret;
		}
		public static ImGuiViewportPtr GetWindowViewport()
		{
			ImGuiViewportPtr ret = ImGuiNative.GetWindowViewport();
			return ret;
		}
		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond, Vector2 pivot)
		{
			ImGuiNative.SetNextWindowPos(pos, cond, pivot);
		}
		public static void SetNextWindowPos(Vector2 pos, ImGuiCond cond)
		{
			ImGuiNative.SetNextWindowPos(pos, cond, (Vector2)(new Vector2(0,0)));
		}
		public static void SetNextWindowPos(Vector2 pos)
		{
			ImGuiNative.SetNextWindowPos(pos, (ImGuiCond)(0), (Vector2)(new Vector2(0,0)));
		}
		public static void SetNextWindowPos(Vector2 pos, Vector2 pivot)
		{
			ImGuiNative.SetNextWindowPos(pos, (ImGuiCond)(0), pivot);
		}
		public static void SetNextWindowSize(Vector2 size, ImGuiCond cond)
		{
			ImGuiNative.SetNextWindowSize(size, cond);
		}
		public static void SetNextWindowSize(Vector2 size)
		{
			ImGuiNative.SetNextWindowSize(size, (ImGuiCond)(0));
		}
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData)
		{
			ImGuiNative.SetNextWindowSizeConstraints(sizeMin, sizeMax, customCallback, customCallbackData);
		}
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback)
		{
			ImGuiNative.SetNextWindowSizeConstraints(sizeMin, sizeMax, customCallback, (void*)(default));
		}
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax)
		{
			ImGuiNative.SetNextWindowSizeConstraints(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}
		public static void SetNextWindowSizeConstraints(Vector2 sizeMin, Vector2 sizeMax, void* customCallbackData)
		{
			ImGuiNative.SetNextWindowSizeConstraints(sizeMin, sizeMax, (ImGuiSizeCallback)(default), customCallbackData);
		}
		public static void SetNextWindowContentSize(Vector2 size)
		{
			ImGuiNative.SetNextWindowContentSize(size);
		}
		public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			ImGuiNative.SetNextWindowCollapsed(collapsed ? (byte)1 : (byte)0, cond);
		}
		public static void SetNextWindowCollapsed(bool collapsed)
		{
			ImGuiNative.SetNextWindowCollapsed(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}
		public static void SetNextWindowFocus()
		{
			ImGuiNative.SetNextWindowFocus();
		}
		public static void SetNextWindowBgAlpha(float alpha)
		{
			ImGuiNative.SetNextWindowBgAlpha(alpha);
		}
		public static void SetNextWindowViewport(uint viewportId)
		{
			ImGuiNative.SetNextWindowViewport(viewportId);
		}
		public static void SetWindowPos(Vector2 pos, ImGuiCond cond)
		{
			ImGuiNative.SetWindowPos(pos, cond);
		}
		public static void SetWindowPos(Vector2 pos)
		{
			ImGuiNative.SetWindowPos(pos, (ImGuiCond)(0));
		}
		public static void SetWindowPos(byte* name, Vector2 pos, ImGuiCond cond)
		{
			ImGuiNative.SetWindowPos(name, pos, cond);
		}
		public static void SetWindowPos(byte* name, Vector2 pos)
		{
			ImGuiNative.SetWindowPos(name, pos, (ImGuiCond)(0));
		}
		public static void SetWindowPos(ref byte name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowPos((byte*)pname, pos, cond);
			}
		}
		public static void SetWindowPos(ref byte name, Vector2 pos)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowPos((byte*)pname, pos, (ImGuiCond)(0));
			}
		}
		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowPos((byte*)pname, pos, cond);
			}
		}
		public static void SetWindowPos(ReadOnlySpan<byte> name, Vector2 pos)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowPos((byte*)pname, pos, (ImGuiCond)(0));
			}
		}
		public static void SetWindowPos(string name, Vector2 pos, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowPos(pStr0, pos, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowPos(string name, Vector2 pos)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowPos(pStr0, pos, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowSize(Vector2 size, ImGuiCond cond)
		{
			ImGuiNative.SetWindowSize(size, cond);
		}
		public static void SetWindowSize(Vector2 size)
		{
			ImGuiNative.SetWindowSize(size, (ImGuiCond)(0));
		}
		public static void SetWindowSize(byte* name, Vector2 size, ImGuiCond cond)
		{
			ImGuiNative.SetWindowSize(name, size, cond);
		}
		public static void SetWindowSize(byte* name, Vector2 size)
		{
			ImGuiNative.SetWindowSize(name, size, (ImGuiCond)(0));
		}
		public static void SetWindowSize(ref byte name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowSize((byte*)pname, size, cond);
			}
		}
		public static void SetWindowSize(ref byte name, Vector2 size)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowSize((byte*)pname, size, (ImGuiCond)(0));
			}
		}
		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowSize((byte*)pname, size, cond);
			}
		}
		public static void SetWindowSize(ReadOnlySpan<byte> name, Vector2 size)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowSize((byte*)pname, size, (ImGuiCond)(0));
			}
		}
		public static void SetWindowSize(string name, Vector2 size, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowSize(pStr0, size, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowSize(string name, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowSize(pStr0, size, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond)
		{
			ImGuiNative.SetWindowCollapsed(collapsed ? (byte)1 : (byte)0, cond);
		}
		public static void SetWindowCollapsed(bool collapsed)
		{
			ImGuiNative.SetWindowCollapsed(collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}
		public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond)
		{
			ImGuiNative.SetWindowCollapsed(name, collapsed ? (byte)1 : (byte)0, cond);
		}
		public static void SetWindowCollapsed(byte* name, bool collapsed)
		{
			ImGuiNative.SetWindowCollapsed(name, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}
		public static void SetWindowCollapsed(ref byte name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowCollapsed((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}
		public static void SetWindowCollapsed(ref byte name, bool collapsed)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowCollapsed((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}
		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed, ImGuiCond cond)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowCollapsed((byte*)pname, collapsed ? (byte)1 : (byte)0, cond);
			}
		}
		public static void SetWindowCollapsed(ReadOnlySpan<byte> name, bool collapsed)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowCollapsed((byte*)pname, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}
		public static void SetWindowCollapsed(string name, bool collapsed, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowCollapsed(pStr0, collapsed ? (byte)1 : (byte)0, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowCollapsed(string name, bool collapsed)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowCollapsed(pStr0, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowFocus()
		{
			ImGuiNative.SetWindowFocus();
		}
		public static void SetWindowFocus(byte* name)
		{
			ImGuiNative.SetWindowFocus(name);
		}
		public static void SetWindowFocus(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiNative.SetWindowFocus((byte*)pname);
			}
		}
		public static void SetWindowFocus(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiNative.SetWindowFocus((byte*)pname);
			}
		}
		public static void SetWindowFocus(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetWindowFocus(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SetWindowFontScale(float scale)
		{
			ImGuiNative.SetWindowFontScale(scale);
		}
		public static Vector2 GetContentRegionAvail()
		{
			Vector2 ret;
			ImGuiNative.GetContentRegionAvail(&ret);
			return ret;
		}
		public static void GetContentRegionAvail(Vector2* pOut)
		{
			ImGuiNative.GetContentRegionAvail(pOut);
		}
		public static void GetContentRegionAvail(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetContentRegionAvail((Vector2*)ppOut);
			}
		}
		public static Vector2 GetContentRegionMax()
		{
			Vector2 ret;
			ImGuiNative.GetContentRegionMax(&ret);
			return ret;
		}
		public static void GetContentRegionMax(Vector2* pOut)
		{
			ImGuiNative.GetContentRegionMax(pOut);
		}
		public static void GetContentRegionMax(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetContentRegionMax((Vector2*)ppOut);
			}
		}
		public static Vector2 GetWindowContentRegionMin()
		{
			Vector2 ret;
			ImGuiNative.GetWindowContentRegionMin(&ret);
			return ret;
		}
		public static void GetWindowContentRegionMin(Vector2* pOut)
		{
			ImGuiNative.GetWindowContentRegionMin(pOut);
		}
		public static void GetWindowContentRegionMin(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetWindowContentRegionMin((Vector2*)ppOut);
			}
		}
		public static Vector2 GetWindowContentRegionMax()
		{
			Vector2 ret;
			ImGuiNative.GetWindowContentRegionMax(&ret);
			return ret;
		}
		public static void GetWindowContentRegionMax(Vector2* pOut)
		{
			ImGuiNative.GetWindowContentRegionMax(pOut);
		}
		public static void GetWindowContentRegionMax(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetWindowContentRegionMax((Vector2*)ppOut);
			}
		}
		public static float GetScrollX()
		{
			float ret = ImGuiNative.GetScrollX();
			return ret;
		}
		public static float GetScrollY()
		{
			float ret = ImGuiNative.GetScrollY();
			return ret;
		}
		public static void SetScrollX(float scrollX)
		{
			ImGuiNative.SetScrollX(scrollX);
		}
		public static void SetScrollY(float scrollY)
		{
			ImGuiNative.SetScrollY(scrollY);
		}
		public static float GetScrollMaxX()
		{
			float ret = ImGuiNative.GetScrollMaxX();
			return ret;
		}
		public static float GetScrollMaxY()
		{
			float ret = ImGuiNative.GetScrollMaxY();
			return ret;
		}
		public static void SetScrollHereX(float centerXRatio)
		{
			ImGuiNative.SetScrollHereX(centerXRatio);
		}
		public static void SetScrollHereX()
		{
			ImGuiNative.SetScrollHereX((float)(0.5f));
		}
		public static void SetScrollHereY(float centerYRatio)
		{
			ImGuiNative.SetScrollHereY(centerYRatio);
		}
		public static void SetScrollHereY()
		{
			ImGuiNative.SetScrollHereY((float)(0.5f));
		}
		public static void SetScrollFromPosX(float localX, float centerXRatio)
		{
			ImGuiNative.SetScrollFromPosX(localX, centerXRatio);
		}
		public static void SetScrollFromPosX(float localX)
		{
			ImGuiNative.SetScrollFromPosX(localX, (float)(0.5f));
		}
		public static void SetScrollFromPosY(float localY, float centerYRatio)
		{
			ImGuiNative.SetScrollFromPosY(localY, centerYRatio);
		}
		public static void SetScrollFromPosY(float localY)
		{
			ImGuiNative.SetScrollFromPosY(localY, (float)(0.5f));
		}
		public static void PushFont(ImFontPtr font)
		{
			ImGuiNative.PushFont(font);
		}
		public static void PushFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGuiNative.PushFont((ImFont*)pfont);
			}
		}
		public static void PopFont()
		{
			ImGuiNative.PopFont();
		}
		public static void PushStyleColor(ImGuiCol idx, uint col)
		{
			ImGuiNative.PushStyleColor(idx, col);
		}
		public static void PushStyleColor(ImGuiCol idx, Vector4 col)
		{
			ImGuiNative.PushStyleColor(idx, col);
		}
		public static void PopStyleColor(int count)
		{
			ImGuiNative.PopStyleColor(count);
		}
		public static void PopStyleColor()
		{
			ImGuiNative.PopStyleColor((int)(1));
		}
		public static void PushStyleVar(ImGuiStyleVar idx, float val)
		{
			ImGuiNative.PushStyleVar(idx, val);
		}
		public static void PushStyleVar(ImGuiStyleVar idx, Vector2 val)
		{
			ImGuiNative.PushStyleVar(idx, val);
		}
		public static void PopStyleVar(int count)
		{
			ImGuiNative.PopStyleVar(count);
		}
		public static void PopStyleVar()
		{
			ImGuiNative.PopStyleVar((int)(1));
		}
		public static void PushAllowKeyboardFocus(bool allowKeyboardFocus)
		{
			ImGuiNative.PushAllowKeyboardFocus(allowKeyboardFocus ? (byte)1 : (byte)0);
		}
		public static void PopAllowKeyboardFocus()
		{
			ImGuiNative.PopAllowKeyboardFocus();
		}
		public static void PushButtonRepeat(bool repeat)
		{
			ImGuiNative.PushButtonRepeat(repeat ? (byte)1 : (byte)0);
		}
		public static void PopButtonRepeat()
		{
			ImGuiNative.PopButtonRepeat();
		}
		public static void PushItemWidth(float itemWidth)
		{
			ImGuiNative.PushItemWidth(itemWidth);
		}
		public static void PopItemWidth()
		{
			ImGuiNative.PopItemWidth();
		}
		public static void SetNextItemWidth(float itemWidth)
		{
			ImGuiNative.SetNextItemWidth(itemWidth);
		}
		public static float CalcItemWidth()
		{
			float ret = ImGuiNative.CalcItemWidth();
			return ret;
		}
		public static void PushTextWrapPos(float wrapLocalPosX)
		{
			ImGuiNative.PushTextWrapPos(wrapLocalPosX);
		}
		public static void PushTextWrapPos()
		{
			ImGuiNative.PushTextWrapPos((float)(0.0f));
		}
		public static void PopTextWrapPos()
		{
			ImGuiNative.PopTextWrapPos();
		}
		public static ImFontPtr GetFont()
		{
			ImFontPtr ret = ImGuiNative.GetFont();
			return ret;
		}
		public static float GetFontSize()
		{
			float ret = ImGuiNative.GetFontSize();
			return ret;
		}
		public static ImTextureID GetFontTexIdWhitePixel()
		{
			ImTextureID ret = ImGuiNative.GetFontTexIdWhitePixel();
			return ret;
		}
		public static Vector2 GetFontTexUvWhitePixel()
		{
			Vector2 ret;
			ImGuiNative.GetFontTexUvWhitePixel(&ret);
			return ret;
		}
		public static void GetFontTexUvWhitePixel(Vector2* pOut)
		{
			ImGuiNative.GetFontTexUvWhitePixel(pOut);
		}
		public static void GetFontTexUvWhitePixel(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetFontTexUvWhitePixel((Vector2*)ppOut);
			}
		}
		public static uint GetColorU32(ImGuiCol idx, float alphaMul)
		{
			uint ret = ImGuiNative.GetColorU32(idx, alphaMul);
			return ret;
		}
		public static uint GetColorU32(ImGuiCol idx)
		{
			uint ret = ImGuiNative.GetColorU32(idx, (float)(1.0f));
			return ret;
		}
		public static uint GetColorU32(Vector4 col)
		{
			uint ret = ImGuiNative.GetColorU32(col);
			return ret;
		}
		public static uint GetColorU32(uint col)
		{
			uint ret = ImGuiNative.GetColorU32(col);
			return ret;
		}
		public static Vector4* GetStyleColorVec4(ImGuiCol idx)
		{
			Vector4* ret = ImGuiNative.GetStyleColorVec4(idx);
			return ret;
		}
		public static void Separator()
		{
			ImGuiNative.Separator();
		}
		public static void SameLine(float offsetFromStartX, float spacing)
		{
			ImGuiNative.SameLine(offsetFromStartX, spacing);
		}
		public static void SameLine(float offsetFromStartX)
		{
			ImGuiNative.SameLine(offsetFromStartX, (float)(-1.0f));
		}
		public static void SameLine()
		{
			ImGuiNative.SameLine((float)(0.0f), (float)(-1.0f));
		}
		public static void NewLine()
		{
			ImGuiNative.NewLine();
		}
		public static void Spacing()
		{
			ImGuiNative.Spacing();
		}
		public static void Dummy(Vector2 size)
		{
			ImGuiNative.Dummy(size);
		}
		public static void Indent(float indentW)
		{
			ImGuiNative.Indent(indentW);
		}
		public static void Indent()
		{
			ImGuiNative.Indent((float)(0.0f));
		}
		public static void Unindent(float indentW)
		{
			ImGuiNative.Unindent(indentW);
		}
		public static void Unindent()
		{
			ImGuiNative.Unindent((float)(0.0f));
		}
		public static void BeginGroup()
		{
			ImGuiNative.BeginGroup();
		}
		public static void EndGroup()
		{
			ImGuiNative.EndGroup();
		}
		public static Vector2 GetCursorPos()
		{
			Vector2 ret;
			ImGuiNative.GetCursorPos(&ret);
			return ret;
		}
		public static void GetCursorPos(Vector2* pOut)
		{
			ImGuiNative.GetCursorPos(pOut);
		}
		public static void GetCursorPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetCursorPos((Vector2*)ppOut);
			}
		}
		public static float GetCursorPosX()
		{
			float ret = ImGuiNative.GetCursorPosX();
			return ret;
		}
		public static float GetCursorPosY()
		{
			float ret = ImGuiNative.GetCursorPosY();
			return ret;
		}
		public static void SetCursorPos(Vector2 localPos)
		{
			ImGuiNative.SetCursorPos(localPos);
		}
		public static void SetCursorPosX(float localX)
		{
			ImGuiNative.SetCursorPosX(localX);
		}
		public static void SetCursorPosY(float localY)
		{
			ImGuiNative.SetCursorPosY(localY);
		}
		public static Vector2 GetCursorStartPos()
		{
			Vector2 ret;
			ImGuiNative.GetCursorStartPos(&ret);
			return ret;
		}
		public static void GetCursorStartPos(Vector2* pOut)
		{
			ImGuiNative.GetCursorStartPos(pOut);
		}
		public static void GetCursorStartPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetCursorStartPos((Vector2*)ppOut);
			}
		}
		public static Vector2 GetCursorScreenPos()
		{
			Vector2 ret;
			ImGuiNative.GetCursorScreenPos(&ret);
			return ret;
		}
		public static void GetCursorScreenPos(Vector2* pOut)
		{
			ImGuiNative.GetCursorScreenPos(pOut);
		}
		public static void GetCursorScreenPos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetCursorScreenPos((Vector2*)ppOut);
			}
		}
		public static void SetCursorScreenPos(Vector2 pos)
		{
			ImGuiNative.SetCursorScreenPos(pos);
		}
		public static void AlignTextToFramePadding()
		{
			ImGuiNative.AlignTextToFramePadding();
		}
		public static float GetTextLineHeight()
		{
			float ret = ImGuiNative.GetTextLineHeight();
			return ret;
		}
		public static float GetTextLineHeightWithSpacing()
		{
			float ret = ImGuiNative.GetTextLineHeightWithSpacing();
			return ret;
		}
		public static float GetFrameHeight()
		{
			float ret = ImGuiNative.GetFrameHeight();
			return ret;
		}
		public static float GetFrameHeightWithSpacing()
		{
			float ret = ImGuiNative.GetFrameHeightWithSpacing();
			return ret;
		}
		public static void PopID()
		{
			ImGuiNative.PopID();
		}
		public static bool Button(byte* label, Vector2 size)
		{
			byte ret = ImGuiNative.Button(label, size);
			return ret != 0;
		}
		public static bool Button(byte* label)
		{
			byte ret = ImGuiNative.Button(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Button(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Button((byte*)plabel, size);
				return ret != 0;
			}
		}
		public static bool Button(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Button((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Button(ReadOnlySpan<byte> label, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Button((byte*)plabel, size);
				return ret != 0;
			}
		}
		public static bool Button(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Button((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Button(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Button(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Button(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Button(pStr0, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool SmallButton(byte* label)
		{
			byte ret = ImGuiNative.SmallButton(label);
			return ret != 0;
		}
		public static bool SmallButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.SmallButton((byte*)plabel);
				return ret != 0;
			}
		}
		public static bool SmallButton(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.SmallButton((byte*)plabel);
				return ret != 0;
			}
		}
		public static bool SmallButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.SmallButton(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool InvisibleButton(byte* strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte ret = ImGuiNative.InvisibleButton(strId, size, flags);
			return ret != 0;
		}
		public static bool InvisibleButton(byte* strId, Vector2 size)
		{
			byte ret = ImGuiNative.InvisibleButton(strId, size, (ImGuiButtonFlags)(0));
			return ret != 0;
		}
		public static bool InvisibleButton(ref byte strId, Vector2 size, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.InvisibleButton((byte*)pstrId, size, flags);
				return ret != 0;
			}
		}
		public static bool InvisibleButton(ref byte strId, Vector2 size)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.InvisibleButton((byte*)pstrId, size, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool InvisibleButton(ReadOnlySpan<byte> strId, Vector2 size, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.InvisibleButton((byte*)pstrId, size, flags);
				return ret != 0;
			}
		}
		public static bool InvisibleButton(ReadOnlySpan<byte> strId, Vector2 size)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.InvisibleButton((byte*)pstrId, size, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool InvisibleButton(string strId, Vector2 size, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.InvisibleButton(pStr0, size, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool InvisibleButton(string strId, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.InvisibleButton(pStr0, size, (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ArrowButton(byte* strId, ImGuiDir dir)
		{
			byte ret = ImGuiNative.ArrowButton(strId, dir);
			return ret != 0;
		}
		public static bool ArrowButton(ref byte strId, ImGuiDir dir)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.ArrowButton((byte*)pstrId, dir);
				return ret != 0;
			}
		}
		public static bool ArrowButton(ReadOnlySpan<byte> strId, ImGuiDir dir)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.ArrowButton((byte*)pstrId, dir);
				return ret != 0;
			}
		}
		public static bool ArrowButton(string strId, ImGuiDir dir)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ArrowButton(pStr0, dir);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol)
		{
			ImGuiNative.Image(userTextureId, size, uv0, uv1, tintCol, borderCol);
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol)
		{
			ImGuiNative.Image(userTextureId, size, uv0, uv1, tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			ImGuiNative.Image(userTextureId, size, uv0, uv1, (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			ImGuiNative.Image(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}
		public static void Image(ImTextureID userTextureId, Vector2 size)
		{
			ImGuiNative.Image(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(1,1,1,1)), (Vector4)(new Vector4(0,0,0,0)));
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector4 tintCol)
		{
			ImGuiNative.Image(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector4 tintCol)
		{
			ImGuiNative.Image(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), tintCol, (Vector4)(new Vector4(0,0,0,0)));
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector4 tintCol, Vector4 borderCol)
		{
			ImGuiNative.Image(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), tintCol, borderCol);
		}
		public static void Image(ImTextureID userTextureId, Vector2 size, Vector4 tintCol, Vector4 borderCol)
		{
			ImGuiNative.Image(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), tintCol, borderCol);
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, int framePadding, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, uv1, framePadding, bgCol, tintCol);
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, int framePadding, Vector4 bgCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, uv1, framePadding, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, int framePadding)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, uv1, framePadding, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, uv1, (int)(-1), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (int)(-1), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (int)(-1), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, int framePadding)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), framePadding, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, int framePadding)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), framePadding, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, uv1, (int)(-1), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector4 bgCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (int)(-1), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector4 bgCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (int)(-1), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, int framePadding, Vector4 bgCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), framePadding, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, int framePadding, Vector4 bgCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), framePadding, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, uv1, (int)(-1), bgCol, tintCol);
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), (int)(-1), bgCol, tintCol);
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (int)(-1), bgCol, tintCol);
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, Vector2 uv0, int framePadding, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, uv0, (Vector2)(new Vector2(1,1)), framePadding, bgCol, tintCol);
			return ret != 0;
		}
		public static bool ImageButton(ImTextureID userTextureId, Vector2 size, int framePadding, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiNative.ImageButton(userTextureId, size, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), framePadding, bgCol, tintCol);
			return ret != 0;
		}
		public static bool Checkbox(byte* label, bool* v)
		{
			byte ret = ImGuiNative.Checkbox(label, v);
			return ret != 0;
		}
		public static bool Checkbox(ref byte label, bool* v)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Checkbox((byte*)plabel, v);
				return ret != 0;
			}
		}
		public static bool Checkbox(ReadOnlySpan<byte> label, bool* v)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Checkbox((byte*)plabel, v);
				return ret != 0;
			}
		}
		public static bool Checkbox(string label, bool* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Checkbox(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Checkbox(byte* label, ref bool v)
		{
			fixed (bool* pv = &v)
			{
				byte ret = ImGuiNative.Checkbox(label, (bool*)pv);
				return ret != 0;
			}
		}
		public static bool Checkbox(ref byte label, ref bool v)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* pv = &v)
				{
					byte ret = ImGuiNative.Checkbox((byte*)plabel, (bool*)pv);
					return ret != 0;
				}
			}
		}
		public static bool Checkbox(ReadOnlySpan<byte> label, ref bool v)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* pv = &v)
				{
					byte ret = ImGuiNative.Checkbox((byte*)plabel, (bool*)pv);
					return ret != 0;
				}
			}
		}
		public static bool Checkbox(string label, ref bool v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* pv = &v)
			{
				byte ret = ImGuiNative.Checkbox(pStr0, (bool*)pv);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(byte* label, int* flags, int flagsValue)
		{
			byte ret = ImGuiNative.CheckboxFlags(label, flags, flagsValue);
			return ret != 0;
		}
		public static bool CheckboxFlags(ref byte label, int* flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(ReadOnlySpan<byte> label, int* flags, int flagsValue)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(string label, int* flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.CheckboxFlags(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CheckboxFlags(byte* label, ref int flags, int flagsValue)
		{
			fixed (int* pflags = &flags)
			{
				byte ret = ImGuiNative.CheckboxFlags(label, (int*)pflags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(ref byte label, ref int flags, int flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pflags = &flags)
				{
					byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, (int*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}
		public static bool CheckboxFlags(ReadOnlySpan<byte> label, ref int flags, int flagsValue)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pflags = &flags)
				{
					byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, (int*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}
		public static bool CheckboxFlags(string label, ref int flags, int flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pflags = &flags)
			{
				byte ret = ImGuiNative.CheckboxFlags(pStr0, (int*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(byte* label, uint* flags, uint flagsValue)
		{
			byte ret = ImGuiNative.CheckboxFlags(label, flags, flagsValue);
			return ret != 0;
		}
		public static bool CheckboxFlags(ref byte label, uint* flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(ReadOnlySpan<byte> label, uint* flags, uint flagsValue)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(string label, uint* flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.CheckboxFlags(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CheckboxFlags(byte* label, ref uint flags, uint flagsValue)
		{
			fixed (uint* pflags = &flags)
			{
				byte ret = ImGuiNative.CheckboxFlags(label, (uint*)pflags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(ref byte label, ref uint flags, uint flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (uint* pflags = &flags)
				{
					byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, (uint*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}
		public static bool CheckboxFlags(ReadOnlySpan<byte> label, ref uint flags, uint flagsValue)
		{
			fixed (byte* plabel = label)
			{
				fixed (uint* pflags = &flags)
				{
					byte ret = ImGuiNative.CheckboxFlags((byte*)plabel, (uint*)pflags, flagsValue);
					return ret != 0;
				}
			}
		}
		public static bool CheckboxFlags(string label, ref uint flags, uint flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (uint* pflags = &flags)
			{
				byte ret = ImGuiNative.CheckboxFlags(pStr0, (uint*)pflags, flagsValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool RadioButton(byte* label, bool active)
		{
			byte ret = ImGuiNative.RadioButton(label, active ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool RadioButton(ref byte label, bool active)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.RadioButton((byte*)plabel, active ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool RadioButton(ReadOnlySpan<byte> label, bool active)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.RadioButton((byte*)plabel, active ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool RadioButton(string label, bool active)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.RadioButton(pStr0, active ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool RadioButton(byte* label, int* v, int vButton)
		{
			byte ret = ImGuiNative.RadioButton(label, v, vButton);
			return ret != 0;
		}
		public static bool RadioButton(ref byte label, int* v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.RadioButton((byte*)plabel, v, vButton);
				return ret != 0;
			}
		}
		public static bool RadioButton(ReadOnlySpan<byte> label, int* v, int vButton)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.RadioButton((byte*)plabel, v, vButton);
				return ret != 0;
			}
		}
		public static bool RadioButton(string label, int* v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.RadioButton(pStr0, v, vButton);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool RadioButton(byte* label, ref int v, int vButton)
		{
			fixed (int* pv = &v)
			{
				byte ret = ImGuiNative.RadioButton(label, (int*)pv, vButton);
				return ret != 0;
			}
		}
		public static bool RadioButton(ref byte label, ref int v, int vButton)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pv = &v)
				{
					byte ret = ImGuiNative.RadioButton((byte*)plabel, (int*)pv, vButton);
					return ret != 0;
				}
			}
		}
		public static bool RadioButton(ReadOnlySpan<byte> label, ref int v, int vButton)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pv = &v)
				{
					byte ret = ImGuiNative.RadioButton((byte*)plabel, (int*)pv, vButton);
					return ret != 0;
				}
			}
		}
		public static bool RadioButton(string label, ref int v, int vButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pv = &v)
			{
				byte ret = ImGuiNative.RadioButton(pStr0, (int*)pv, vButton);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void ProgressBar(float fraction, Vector2 sizeArg, byte* overlay)
		{
			ImGuiNative.ProgressBar(fraction, sizeArg, overlay);
		}
		public static void ProgressBar(float fraction, Vector2 sizeArg)
		{
			ImGuiNative.ProgressBar(fraction, sizeArg, (byte*)(default));
		}
		public static void ProgressBar(float fraction)
		{
			ImGuiNative.ProgressBar(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)(default));
		}
		public static void ProgressBar(float fraction, byte* overlay)
		{
			ImGuiNative.ProgressBar(fraction, (Vector2)(new Vector2(-float.MinValue,0)), overlay);
		}
		public static void ProgressBar(float fraction, Vector2 sizeArg, ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ImGuiNative.ProgressBar(fraction, sizeArg, (byte*)poverlay);
			}
		}
		public static void ProgressBar(float fraction, ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ImGuiNative.ProgressBar(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)poverlay);
			}
		}
		public static void ProgressBar(float fraction, Vector2 sizeArg, ReadOnlySpan<byte> overlay)
		{
			fixed (byte* poverlay = overlay)
			{
				ImGuiNative.ProgressBar(fraction, sizeArg, (byte*)poverlay);
			}
		}
		public static void ProgressBar(float fraction, ReadOnlySpan<byte> overlay)
		{
			fixed (byte* poverlay = overlay)
			{
				ImGuiNative.ProgressBar(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)poverlay);
			}
		}
		public static void ProgressBar(float fraction, Vector2 sizeArg, string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.ProgressBar(fraction, sizeArg, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ProgressBar(float fraction, string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.ProgressBar(fraction, (Vector2)(new Vector2(-float.MinValue,0)), pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Bullet()
		{
			ImGuiNative.Bullet();
		}
		public static bool BeginCombo(byte* label, byte* previewValue, ImGuiComboFlags flags)
		{
			byte ret = ImGuiNative.BeginCombo(label, previewValue, flags);
			return ret != 0;
		}
		public static bool BeginCombo(byte* label, byte* previewValue)
		{
			byte ret = ImGuiNative.BeginCombo(label, previewValue, (ImGuiComboFlags)(0));
			return ret != 0;
		}
		public static bool BeginCombo(ref byte label, byte* previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, previewValue, flags);
				return ret != 0;
			}
		}
		public static bool BeginCombo(ref byte label, byte* previewValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, previewValue, (ImGuiComboFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, byte* previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, previewValue, flags);
				return ret != 0;
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, byte* previewValue)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, previewValue, (ImGuiComboFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginCombo(string label, byte* previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginCombo(pStr0, previewValue, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginCombo(string label, byte* previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginCombo(pStr0, previewValue, (ImGuiComboFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginCombo(byte* label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(label, (byte*)ppreviewValue, flags);
				return ret != 0;
			}
		}
		public static bool BeginCombo(byte* label, ref byte previewValue)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(label, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginCombo(byte* label, ReadOnlySpan<byte> previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* ppreviewValue = previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(label, (byte*)ppreviewValue, flags);
				return ret != 0;
			}
		}
		public static bool BeginCombo(byte* label, ReadOnlySpan<byte> previewValue)
		{
			fixed (byte* ppreviewValue = previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(label, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginCombo(byte* label, string previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginCombo(label, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginCombo(byte* label, string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginCombo(label, pStr0, (ImGuiComboFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginCombo(ref byte label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ref byte label, ref byte previewValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, ReadOnlySpan<byte> previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* ppreviewValue = previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, ReadOnlySpan<byte> previewValue)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* ppreviewValue = previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(string label, string previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (previewValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(previewValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.BeginCombo(pStr0, pStr1, flags);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginCombo(string label, string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (previewValue != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(previewValue, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.BeginCombo(pStr0, pStr1, (ImGuiComboFlags)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginCombo(ref byte label, ReadOnlySpan<byte> previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ref byte label, ReadOnlySpan<byte> previewValue)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* ppreviewValue = previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ref byte label, string previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (previewValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(previewValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(ref byte label, string previewValue)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (previewValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(previewValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, pStr0, (ImGuiComboFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, ref byte previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, ref byte previewValue)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* ppreviewValue = &previewValue)
				{
					byte ret = ImGuiNative.BeginCombo((byte*)plabel, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, string previewValue, ImGuiComboFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (previewValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(previewValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(ReadOnlySpan<byte> label, string previewValue)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (previewValue != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(previewValue);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.BeginCombo((byte*)plabel, pStr0, (ImGuiComboFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(string label, ref byte previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(pStr0, (byte*)ppreviewValue, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(string label, ref byte previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(pStr0, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(string label, ReadOnlySpan<byte> previewValue, ImGuiComboFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ppreviewValue = previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(pStr0, (byte*)ppreviewValue, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginCombo(string label, ReadOnlySpan<byte> previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ppreviewValue = previewValue)
			{
				byte ret = ImGuiNative.BeginCombo(pStr0, (byte*)ppreviewValue, (ImGuiComboFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void EndCombo()
		{
			ImGuiNative.EndCombo();
		}
		public static bool Combo(byte* label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte ret = ImGuiNative.Combo(label, currentItem, items, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}
		public static bool Combo(byte* label, int* currentItem, byte** items, int itemsCount)
		{
			byte ret = ImGuiNative.Combo(label, currentItem, items, itemsCount, (int)(-1));
			return ret != 0;
		}
		public static bool Combo(ref byte label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, items, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, items, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, items, itemsCount, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(string label, int* currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, items, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(byte* label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, items, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, items, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, byte** items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, ref int currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.Combo(label, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}
		public static bool Combo(byte* label, int* currentItem, string[] items, int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.Combo(label, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}
		public static bool Combo(string label, int* currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(string label, int* currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(byte* label, ref int currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, ref int currentItem, string[] items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, ref int currentItem, string[] items, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, ref int currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte ret = ImGuiNative.Combo(label, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
			return ret != 0;
		}
		public static bool Combo(byte* label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			byte ret = ImGuiNative.Combo(label, currentItem, itemsSeparatedByZeros, (int)(-1));
			return ret != 0;
		}
		public static bool Combo(ref byte label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(string label, int* currentItem, byte* itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, itemsSeparatedByZeros, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(byte* label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, ref int currentItem, byte* itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(label, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(label, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(label, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(label, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(label, currentItem, pStr0, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(byte* label, int* currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(label, currentItem, pStr0, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(ref byte label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, pStr1, popupMaxHeightInItems);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(string label, int* currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, pStr1, (int)(-1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(ref byte label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, pStr0, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, int* currentItem, string itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, pStr0, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, pStr0, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, string itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, pStr0, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(pStr0, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, ref byte itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(pStr0, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(pStr0, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
			{
				byte ret = ImGuiNative.Combo(pStr0, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(byte* label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(byte* label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(byte* label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(byte* label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, pStr0, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, ref int currentItem, string itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, pStr0, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, pStr1, popupMaxHeightInItems);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, ref int currentItem, string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, pStr1, (int)(-1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (itemsSeparatedByZeros != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, pStr0, popupMaxHeightInItems);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, string itemsSeparatedByZeros)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (itemsSeparatedByZeros != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, pStr0, (int)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
					{
						byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
						return ret != 0;
					}
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, string itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (itemsSeparatedByZeros != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, pStr0, popupMaxHeightInItems);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, string itemsSeparatedByZeros)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (itemsSeparatedByZeros != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, pStr0, (int)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, ref byte itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, ref byte itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, ReadOnlySpan<byte> itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = itemsSeparatedByZeros)
				{
					byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool Combo(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte ret = ImGuiNative.Combo(label, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}
		public static bool Combo(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			byte ret = ImGuiNative.Combo(label, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			return ret != 0;
		}
		public static bool Combo(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Combo((byte*)plabel, currentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Combo(pStr0, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Combo(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}
		public static bool Combo(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}
		public static bool Combo(ReadOnlySpan<byte> label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.Combo((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool Combo(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Combo(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.Combo(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool ColorButton(byte* descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			byte ret = ImGuiNative.ColorButton(descId, col, flags, size);
			return ret != 0;
		}
		public static bool ColorButton(byte* descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			byte ret = ImGuiNative.ColorButton(descId, col, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool ColorButton(byte* descId, Vector4 col)
		{
			byte ret = ImGuiNative.ColorButton(descId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool ColorButton(byte* descId, Vector4 col, Vector2 size)
		{
			byte ret = ImGuiNative.ColorButton(descId, col, (ImGuiColorEditFlags)(0), size);
			return ret != 0;
		}
		public static bool ColorButton(ref byte descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, flags, size);
				return ret != 0;
			}
		}
		public static bool ColorButton(ref byte descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool ColorButton(ref byte descId, Vector4 col)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool ColorButton(ref byte descId, Vector4 col, Vector2 size)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, (ImGuiColorEditFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool ColorButton(ReadOnlySpan<byte> descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, flags, size);
				return ret != 0;
			}
		}
		public static bool ColorButton(ReadOnlySpan<byte> descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool ColorButton(ReadOnlySpan<byte> descId, Vector4 col)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool ColorButton(ReadOnlySpan<byte> descId, Vector4 col, Vector2 size)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ImGuiNative.ColorButton((byte*)pdescId, col, (ImGuiColorEditFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool ColorButton(string descId, Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ColorButton(pStr0, col, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ColorButton(string descId, Vector4 col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ColorButton(pStr0, col, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ColorButton(string descId, Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ColorButton(pStr0, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ColorButton(string descId, Vector4 col, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ColorButton(pStr0, col, (ImGuiColorEditFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void SetColorEditOptions(ImGuiColorEditFlags flags)
		{
			ImGuiNative.SetColorEditOptions(flags);
		}
		public static void TreePush(byte* strId)
		{
			ImGuiNative.TreePush(strId);
		}
		public static void TreePush(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiNative.TreePush((byte*)pstrId);
			}
		}
		public static void TreePush(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiNative.TreePush((byte*)pstrId);
			}
		}
		public static void TreePush(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TreePush(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TreePush(void* ptrId)
		{
			ImGuiNative.TreePush(ptrId);
		}
		public static void TreePush()
		{
			ImGuiNative.TreePush((void*)(default));
		}
		public static void TreePop()
		{
			ImGuiNative.TreePop();
		}
		public static float GetTreeNodeToLabelSpacing()
		{
			float ret = ImGuiNative.GetTreeNodeToLabelSpacing();
			return ret;
		}
		public static bool CollapsingHeader(byte* label, ImGuiTreeNodeFlags flags)
		{
			byte ret = ImGuiNative.CollapsingHeader(label, flags);
			return ret != 0;
		}
		public static bool CollapsingHeader(byte* label)
		{
			byte ret = ImGuiNative.CollapsingHeader(label, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}
		public static bool CollapsingHeader(ref byte label, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, flags);
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ReadOnlySpan<byte> label, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, flags);
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(string label, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.CollapsingHeader(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CollapsingHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.CollapsingHeader(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CollapsingHeader(byte* label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			byte ret = ImGuiNative.CollapsingHeader(label, pVisible, flags);
			return ret != 0;
		}
		public static bool CollapsingHeader(byte* label, bool* pVisible)
		{
			byte ret = ImGuiNative.CollapsingHeader(label, pVisible, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}
		public static bool CollapsingHeader(ref byte label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, pVisible, flags);
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ref byte label, bool* pVisible)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, pVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ReadOnlySpan<byte> label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, pVisible, flags);
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ReadOnlySpan<byte> label, bool* pVisible)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, pVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(string label, bool* pVisible, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.CollapsingHeader(pStr0, pVisible, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CollapsingHeader(string label, bool* pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.CollapsingHeader(pStr0, pVisible, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CollapsingHeader(byte* label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = ImGuiNative.CollapsingHeader(label, (bool*)ppVisible, flags);
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(byte* label, ref bool pVisible)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = ImGuiNative.CollapsingHeader(label, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(ref byte label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, (bool*)ppVisible, flags);
					return ret != 0;
				}
			}
		}
		public static bool CollapsingHeader(ref byte label, ref bool pVisible)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool CollapsingHeader(ReadOnlySpan<byte> label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, (bool*)ppVisible, flags);
					return ret != 0;
				}
			}
		}
		public static bool CollapsingHeader(ReadOnlySpan<byte> label, ref bool pVisible)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = ImGuiNative.CollapsingHeader((byte*)plabel, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool CollapsingHeader(string label, ref bool pVisible, ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = ImGuiNative.CollapsingHeader(pStr0, (bool*)ppVisible, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool CollapsingHeader(string label, ref bool pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = ImGuiNative.CollapsingHeader(pStr0, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void SetNextItemOpen(bool isOpen, ImGuiCond cond)
		{
			ImGuiNative.SetNextItemOpen(isOpen ? (byte)1 : (byte)0, cond);
		}
		public static void SetNextItemOpen(bool isOpen)
		{
			ImGuiNative.SetNextItemOpen(isOpen ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}
		public static bool Selectable(byte* label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte ret = ImGuiNative.Selectable(label, selected ? (byte)1 : (byte)0, flags, size);
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool selected, ImGuiSelectableFlags flags)
		{
			byte ret = ImGuiNative.Selectable(label, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool selected)
		{
			byte ret = ImGuiNative.Selectable(label, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Selectable(byte* label)
		{
			byte ret = ImGuiNative.Selectable(label, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Selectable(byte* label, ImGuiSelectableFlags flags)
		{
			byte ret = ImGuiNative.Selectable(label, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool selected, Vector2 size)
		{
			byte ret = ImGuiNative.Selectable(label, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
			return ret != 0;
		}
		public static bool Selectable(byte* label, Vector2 size)
		{
			byte ret = ImGuiNative.Selectable(label, (byte)(0), (ImGuiSelectableFlags)(0), size);
			return ret != 0;
		}
		public static bool Selectable(byte* label, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte ret = ImGuiNative.Selectable(label, (byte)(0), flags, size);
			return ret != 0;
		}
		public static bool Selectable(ref byte label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, bool selected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, bool selected, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool selected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool selected, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, (byte)(0), flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(string label, bool selected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, selected ? (byte)1 : (byte)0, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, bool selected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, bool selected, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, (byte)(0), (ImGuiSelectableFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, (byte)(0), flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte ret = ImGuiNative.Selectable(label, pSelected, flags, size);
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			byte ret = ImGuiNative.Selectable(label, pSelected, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool* pSelected)
		{
			byte ret = ImGuiNative.Selectable(label, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool Selectable(byte* label, bool* pSelected, Vector2 size)
		{
			byte ret = ImGuiNative.Selectable(label, pSelected, (ImGuiSelectableFlags)(0), size);
			return ret != 0;
		}
		public static bool Selectable(ref byte label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, bool* pSelected, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool* pSelected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, bool* pSelected, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Selectable((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(string label, bool* pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, pSelected, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, bool* pSelected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, pSelected, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(string label, bool* pSelected, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Selectable(pStr0, pSelected, (ImGuiSelectableFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Selectable(byte* label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(label, (bool*)ppSelected, flags, size);
				return ret != 0;
			}
		}
		public static bool Selectable(byte* label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(label, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(byte* label, ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(label, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool Selectable(byte* label, ref bool pSelected, Vector2 size)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(label, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}
		public static bool Selectable(ref byte label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, flags, size);
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ref byte label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ref byte label, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ref byte label, ref bool pSelected, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, flags, size);
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, ref bool pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}
		public static bool Selectable(ReadOnlySpan<byte> label, ref bool pSelected, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.Selectable((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
					return ret != 0;
				}
			}
		}
		public static bool Selectable(string label, ref bool pSelected, ImGuiSelectableFlags flags, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(pStr0, (bool*)ppSelected, flags, size);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Selectable(string label, ref bool pSelected, ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(pStr0, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Selectable(string label, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(pStr0, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Selectable(string label, ref bool pSelected, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.Selectable(pStr0, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginListBox(byte* label, Vector2 size)
		{
			byte ret = ImGuiNative.BeginListBox(label, size);
			return ret != 0;
		}
		public static bool BeginListBox(byte* label)
		{
			byte ret = ImGuiNative.BeginListBox(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}
		public static bool BeginListBox(ref byte label, Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginListBox((byte*)plabel, size);
				return ret != 0;
			}
		}
		public static bool BeginListBox(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginListBox((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool BeginListBox(ReadOnlySpan<byte> label, Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginListBox((byte*)plabel, size);
				return ret != 0;
			}
		}
		public static bool BeginListBox(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginListBox((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
		public static bool BeginListBox(string label, Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginListBox(pStr0, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginListBox(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginListBox(pStr0, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void EndListBox()
		{
			ImGuiNative.EndListBox();
		}
		public static bool ListBox(byte* label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte ret = ImGuiNative.ListBox(label, currentItem, items, itemsCount, heightInItems);
			return ret != 0;
		}
		public static bool ListBox(byte* label, int* currentItem, byte** items, int itemsCount)
		{
			byte ret = ImGuiNative.ListBox(label, currentItem, items, itemsCount, (int)(-1));
			return ret != 0;
		}
		public static bool ListBox(ref byte label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, items, itemsCount, heightInItems);
				return ret != 0;
			}
		}
		public static bool ListBox(ref byte label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, items, itemsCount, heightInItems);
				return ret != 0;
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, int* currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool ListBox(string label, int* currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ListBox(pStr0, currentItem, items, itemsCount, heightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ListBox(string label, int* currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ListBox(pStr0, currentItem, items, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ListBox(byte* label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(label, (int*)pcurrentItem, items, itemsCount, heightInItems);
				return ret != 0;
			}
		}
		public static bool ListBox(byte* label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(label, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool ListBox(ref byte label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, items, itemsCount, heightInItems);
					return ret != 0;
				}
			}
		}
		public static bool ListBox(ref byte label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, items, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, items, itemsCount, heightInItems);
					return ret != 0;
				}
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, ref int currentItem, byte** items, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, items, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool ListBox(string label, ref int currentItem, byte** items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(pStr0, (int*)pcurrentItem, items, itemsCount, heightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(string label, ref int currentItem, byte** items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(pStr0, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(byte* label, int* currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.ListBox(label, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}
		public static bool ListBox(byte* label, int* currentItem, string[] items, int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.ListBox(label, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}
		public static bool ListBox(string label, int* currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.ListBox(pStr0, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ListBox(string label, int* currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte** pStrArray0 = null;
			int pStrArray0Size = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArray0Size > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
				}
				else
				{
					byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
					pStrArray0 = (byte**)pStrArray0Stack;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ImGuiNative.ListBox(pStr0, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArray0Size >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ListBox(byte* label, ref int currentItem, string[] items, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.ListBox(label, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(byte* label, ref int currentItem, string[] items, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.ListBox(label, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(string label, ref int currentItem, string[] items, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.ListBox(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(string label, ref int currentItem, string[] items, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArray0Size = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArray0Size > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArray0Size);
					}
					else
					{
						byte* pStrArray0Stack = stackalloc byte[pStrArray0Size];
						pStrArray0 = (byte**)pStrArray0Stack;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ImGuiNative.ListBox(pStr0, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArray0Size >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte ret = ImGuiNative.ListBox(label, currentItem, itemsGetter, data, itemsCount, heightInItems);
			return ret != 0;
		}
		public static bool ListBox(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			byte ret = ImGuiNative.ListBox(label, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			return ret != 0;
		}
		public static bool ListBox(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret != 0;
			}
		}
		public static bool ListBox(ref byte label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret != 0;
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.ListBox((byte*)plabel, currentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool ListBox(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ListBox(pStr0, currentItem, itemsGetter, data, itemsCount, heightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ListBox(string label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.ListBox(pStr0, currentItem, itemsGetter, data, itemsCount, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ListBox(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
				return ret != 0;
			}
		}
		public static bool ListBox(byte* label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(label, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				return ret != 0;
			}
		}
		public static bool ListBox(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
					return ret != 0;
				}
			}
		}
		public static bool ListBox(ref byte label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = &label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
					return ret != 0;
				}
			}
		}
		public static bool ListBox(ReadOnlySpan<byte> label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			fixed (byte* plabel = label)
			{
				fixed (int* pcurrentItem = &currentItem)
				{
					byte ret = ImGuiNative.ListBox((byte*)plabel, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
					return ret != 0;
				}
			}
		}
		public static bool ListBox(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount, int heightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, heightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool ListBox(string label, ref int currentItem, delegate*<byte*, int*, delegate*<void*, int, byte**, bool>, void*, int, int, bool> itemsGetter, void* data, int itemsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ImGuiNative.ListBox(pStr0, (int*)pcurrentItem, itemsGetter, data, itemsCount, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void Value(byte* prefix, bool b)
		{
			ImGuiNative.Value(prefix, b ? (byte)1 : (byte)0);
		}
		public static void Value(ref byte prefix, bool b)
		{
			fixed (byte* pprefix = &prefix)
			{
				ImGuiNative.Value((byte*)pprefix, b ? (byte)1 : (byte)0);
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, bool b)
		{
			fixed (byte* pprefix = prefix)
			{
				ImGuiNative.Value((byte*)pprefix, b ? (byte)1 : (byte)0);
			}
		}
		public static void Value(string prefix, bool b)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Value(pStr0, b ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(byte* prefix, int v)
		{
			ImGuiNative.Value(prefix, v);
		}
		public static void Value(ref byte prefix, int v)
		{
			fixed (byte* pprefix = &prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v);
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, int v)
		{
			fixed (byte* pprefix = prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v);
			}
		}
		public static void Value(string prefix, int v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Value(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(byte* prefix, uint v)
		{
			ImGuiNative.Value(prefix, v);
		}
		public static void Value(ref byte prefix, uint v)
		{
			fixed (byte* pprefix = &prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v);
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, uint v)
		{
			fixed (byte* pprefix = prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v);
			}
		}
		public static void Value(string prefix, uint v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Value(pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(byte* prefix, float v, byte* floatFormat)
		{
			ImGuiNative.Value(prefix, v, floatFormat);
		}
		public static void Value(byte* prefix, float v)
		{
			ImGuiNative.Value(prefix, v, (byte*)(default));
		}
		public static void Value(ref byte prefix, float v, byte* floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v, floatFormat);
			}
		}
		public static void Value(ref byte prefix, float v)
		{
			fixed (byte* pprefix = &prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v, (byte*)(default));
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, float v, byte* floatFormat)
		{
			fixed (byte* pprefix = prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v, floatFormat);
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, float v)
		{
			fixed (byte* pprefix = prefix)
			{
				ImGuiNative.Value((byte*)pprefix, v, (byte*)(default));
			}
		}
		public static void Value(string prefix, float v, byte* floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Value(pStr0, v, floatFormat);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(string prefix, float v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Value(pStr0, v, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(byte* prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pfloatFormat = &floatFormat)
			{
				ImGuiNative.Value(prefix, v, (byte*)pfloatFormat);
			}
		}
		public static void Value(byte* prefix, float v, ReadOnlySpan<byte> floatFormat)
		{
			fixed (byte* pfloatFormat = floatFormat)
			{
				ImGuiNative.Value(prefix, v, (byte*)pfloatFormat);
			}
		}
		public static void Value(byte* prefix, float v, string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (floatFormat != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(floatFormat, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Value(prefix, v, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(ref byte prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* pfloatFormat = &floatFormat)
				{
					ImGuiNative.Value((byte*)pprefix, v, (byte*)pfloatFormat);
				}
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, float v, ReadOnlySpan<byte> floatFormat)
		{
			fixed (byte* pprefix = prefix)
			{
				fixed (byte* pfloatFormat = floatFormat)
				{
					ImGuiNative.Value((byte*)pprefix, v, (byte*)pfloatFormat);
				}
			}
		}
		public static void Value(string prefix, float v, string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (floatFormat != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(floatFormat, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiNative.Value(pStr0, v, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Value(ref byte prefix, float v, ReadOnlySpan<byte> floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* pfloatFormat = floatFormat)
				{
					ImGuiNative.Value((byte*)pprefix, v, (byte*)pfloatFormat);
				}
			}
		}
		public static void Value(ref byte prefix, float v, string floatFormat)
		{
			fixed (byte* pprefix = &prefix)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (floatFormat != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(floatFormat);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(floatFormat, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiNative.Value((byte*)pprefix, v, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, float v, ref byte floatFormat)
		{
			fixed (byte* pprefix = prefix)
			{
				fixed (byte* pfloatFormat = &floatFormat)
				{
					ImGuiNative.Value((byte*)pprefix, v, (byte*)pfloatFormat);
				}
			}
		}
		public static void Value(ReadOnlySpan<byte> prefix, float v, string floatFormat)
		{
			fixed (byte* pprefix = prefix)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (floatFormat != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(floatFormat);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(floatFormat, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiNative.Value((byte*)pprefix, v, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void Value(string prefix, float v, ref byte floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfloatFormat = &floatFormat)
			{
				ImGuiNative.Value(pStr0, v, (byte*)pfloatFormat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void Value(string prefix, float v, ReadOnlySpan<byte> floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfloatFormat = floatFormat)
			{
				ImGuiNative.Value(pStr0, v, (byte*)pfloatFormat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static bool BeginMenuBar()
		{
			byte ret = ImGuiNative.BeginMenuBar();
			return ret != 0;
		}
		public static void EndMenuBar()
		{
			ImGuiNative.EndMenuBar();
		}
		public static bool BeginMainMenuBar()
		{
			byte ret = ImGuiNative.BeginMainMenuBar();
			return ret != 0;
		}
		public static void EndMainMenuBar()
		{
			ImGuiNative.EndMainMenuBar();
		}
		public static bool BeginMenu(byte* label, bool enabled)
		{
			byte ret = ImGuiNative.BeginMenu(label, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool BeginMenu(byte* label)
		{
			byte ret = ImGuiNative.BeginMenu(label, (byte)(1));
			return ret != 0;
		}
		public static bool BeginMenu(ref byte label, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginMenu((byte*)plabel, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool BeginMenu(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginMenu((byte*)plabel, (byte)(1));
				return ret != 0;
			}
		}
		public static bool BeginMenu(ReadOnlySpan<byte> label, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginMenu((byte*)plabel, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool BeginMenu(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginMenu((byte*)plabel, (byte)(1));
				return ret != 0;
			}
		}
		public static bool BeginMenu(string label, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginMenu(pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenu(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginMenu(pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void EndMenu()
		{
			ImGuiNative.EndMenu();
		}
		public static bool MenuItem(byte* label, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = ImGuiNative.MenuItem(label, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool MenuItem(byte* label, byte* shortcut, bool selected)
		{
			byte ret = ImGuiNative.MenuItem(label, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}
		public static bool MenuItem(byte* label, byte* shortcut)
		{
			byte ret = ImGuiNative.MenuItem(label, shortcut, (byte)(0), (byte)(1));
			return ret != 0;
		}
		public static bool MenuItem(byte* label)
		{
			byte ret = ImGuiNative.MenuItem(label, (byte*)(default), (byte)(0), (byte)(1));
			return ret != 0;
		}
		public static bool MenuItem(byte* label, bool selected)
		{
			byte ret = ImGuiNative.MenuItem(label, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}
		public static bool MenuItem(byte* label, bool selected, bool enabled)
		{
			byte ret = ImGuiNative.MenuItem(label, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool MenuItem(ref byte label, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, shortcut, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(byte* label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ref byte shortcut, bool selected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ref byte shortcut)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(label, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(byte* label, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(label, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(byte* label, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(label, pStr0, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(ref byte label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, pStr1, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, string shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, string shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ref byte shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ref byte shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ref byte shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, byte* shortcut, bool* pSelected, bool enabled)
		{
			byte ret = ImGuiNative.MenuItem(label, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool MenuItem(byte* label, byte* shortcut, bool* pSelected)
		{
			byte ret = ImGuiNative.MenuItem(label, shortcut, pSelected, (byte)(1));
			return ret != 0;
		}
		public static bool MenuItem(ref byte label, byte* shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, byte* shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut, bool* pSelected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, byte* shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, byte* shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, shortcut, pSelected, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(byte* label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut, bool* pSelected)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, string shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(label, pStr0, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(byte* label, string shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.MenuItem(label, pStr0, pSelected, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(ref byte label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut, bool* pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, string shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, pStr1, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(string label, string shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiNative.MenuItem(pStr0, pStr1, pSelected, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, string shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, pSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, string shortcut, bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, pSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut, bool* pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, pSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut, bool* pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, pSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut, bool* pSelected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, pSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ref byte shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ref byte shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, pSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut, bool* pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut, bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, pSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(label, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, byte* shortcut, ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(label, shortcut, (bool*)ppSelected, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, byte* shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, (bool*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, byte* shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, shortcut, (bool*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, byte* shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, shortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, byte* shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, shortcut, (bool*)ppSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(byte* label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* pshortcut = shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(byte* label, ReadOnlySpan<byte> shortcut, ref bool pSelected)
		{
			fixed (byte* pshortcut = shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(label, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(byte* label, string shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(label, pStr0, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(byte* label, string shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(label, pStr0, (bool*)ppSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ref byte label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ReadOnlySpan<byte> shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(string label, string shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, pStr1, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(string label, string shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = ImGuiNative.MenuItem(pStr0, pStr1, (bool*)ppSelected, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ref byte label, ReadOnlySpan<byte> shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ref byte label, string shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ref byte label, string shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, (bool*)ppSelected, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, ref byte shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					fixed (bool* ppSelected = &pSelected)
					{
						byte ret = ImGuiNative.MenuItem((byte*)plabel, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut, ref bool pSelected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(ReadOnlySpan<byte> label, string shortcut, ref bool pSelected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem((byte*)plabel, pStr0, (bool*)ppSelected, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, ref byte shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, ref byte shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut, ref bool pSelected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, (bool*)ppSelected, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItem(string label, ReadOnlySpan<byte> shortcut, ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = ImGuiNative.MenuItem(pStr0, (byte*)pshortcut, (bool*)ppSelected, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static void BeginTooltip()
		{
			ImGuiNative.BeginTooltip();
		}
		public static void EndTooltip()
		{
			ImGuiNative.EndTooltip();
		}
		public static bool BeginPopup(byte* strId, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginPopup(strId, flags);
			return ret != 0;
		}
		public static bool BeginPopup(byte* strId)
		{
			byte ret = ImGuiNative.BeginPopup(strId, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginPopup(ref byte strId, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopup((byte*)pstrId, flags);
				return ret != 0;
			}
		}
		public static bool BeginPopup(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopup((byte*)pstrId, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopup(ReadOnlySpan<byte> strId, ImGuiWindowFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopup((byte*)pstrId, flags);
				return ret != 0;
			}
		}
		public static bool BeginPopup(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopup((byte*)pstrId, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopup(string strId, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopup(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopup(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopup(pStr0, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupModal(byte* name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginPopupModal(name, pOpen, flags);
			return ret != 0;
		}
		public static bool BeginPopupModal(byte* name, bool* pOpen)
		{
			byte ret = ImGuiNative.BeginPopupModal(name, pOpen, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginPopupModal(byte* name)
		{
			byte ret = ImGuiNative.BeginPopupModal(name, (bool*)(default), (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static bool BeginPopupModal(byte* name, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginPopupModal(name, (bool*)(default), flags);
			return ret != 0;
		}
		public static bool BeginPopupModal(ref byte name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ref byte name, bool* pOpen)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ref byte name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ReadOnlySpan<byte> name, bool* pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, pOpen, flags);
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ReadOnlySpan<byte> name, bool* pOpen)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, pOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)(default), (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ReadOnlySpan<byte> name, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)(default), flags);
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(string name, bool* pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupModal(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupModal(string name, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupModal(pStr0, pOpen, (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupModal(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupModal(pStr0, (bool*)(default), (ImGuiWindowFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupModal(string name, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupModal(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupModal(byte* name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginPopupModal(name, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(byte* name, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginPopupModal(name, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(ref byte name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginPopupModal(ref byte name, ref bool pOpen)
		{
			fixed (byte* pname = &name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginPopupModal(ReadOnlySpan<byte> name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginPopupModal(ReadOnlySpan<byte> name, ref bool pOpen)
		{
			fixed (byte* pname = name)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginPopupModal((byte*)pname, (bool*)ppOpen, (ImGuiWindowFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginPopupModal(string name, ref bool pOpen, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginPopupModal(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginPopupModal(string name, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginPopupModal(pStr0, (bool*)ppOpen, (ImGuiWindowFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void EndPopup()
		{
			ImGuiNative.EndPopup();
		}
		public static void OpenPopup(byte* strId, ImGuiPopupFlags popupFlags)
		{
			ImGuiNative.OpenPopup(strId, popupFlags);
		}
		public static void OpenPopup(byte* strId)
		{
			ImGuiNative.OpenPopup(strId, (ImGuiPopupFlags)(0));
		}
		public static void OpenPopup(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiNative.OpenPopup((byte*)pstrId, popupFlags);
			}
		}
		public static void OpenPopup(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiNative.OpenPopup((byte*)pstrId, (ImGuiPopupFlags)(0));
			}
		}
		public static void OpenPopup(ReadOnlySpan<byte> strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiNative.OpenPopup((byte*)pstrId, popupFlags);
			}
		}
		public static void OpenPopup(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiNative.OpenPopup((byte*)pstrId, (ImGuiPopupFlags)(0));
			}
		}
		public static void OpenPopup(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.OpenPopup(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void OpenPopup(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.OpenPopup(pStr0, (ImGuiPopupFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void OpenPopup(uint id, ImGuiPopupFlags popupFlags)
		{
			ImGuiNative.OpenPopup(id, popupFlags);
		}
		public static void OpenPopup(uint id)
		{
			ImGuiNative.OpenPopup(id, (ImGuiPopupFlags)(0));
		}
		public static void OpenPopupOnItemClick(byte* strId, ImGuiPopupFlags popupFlags)
		{
			ImGuiNative.OpenPopupOnItemClick(strId, popupFlags);
		}
		public static void OpenPopupOnItemClick(byte* strId)
		{
			ImGuiNative.OpenPopupOnItemClick(strId, (ImGuiPopupFlags)(1));
		}
		public static void OpenPopupOnItemClick()
		{
			ImGuiNative.OpenPopupOnItemClick((byte*)(default), (ImGuiPopupFlags)(1));
		}
		public static void OpenPopupOnItemClick(ImGuiPopupFlags popupFlags)
		{
			ImGuiNative.OpenPopupOnItemClick((byte*)(default), popupFlags);
		}
		public static void OpenPopupOnItemClick(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiNative.OpenPopupOnItemClick((byte*)pstrId, popupFlags);
			}
		}
		public static void OpenPopupOnItemClick(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiNative.OpenPopupOnItemClick((byte*)pstrId, (ImGuiPopupFlags)(1));
			}
		}
		public static void OpenPopupOnItemClick(ReadOnlySpan<byte> strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiNative.OpenPopupOnItemClick((byte*)pstrId, popupFlags);
			}
		}
		public static void OpenPopupOnItemClick(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiNative.OpenPopupOnItemClick((byte*)pstrId, (ImGuiPopupFlags)(1));
			}
		}
		public static void OpenPopupOnItemClick(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.OpenPopupOnItemClick(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void OpenPopupOnItemClick(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.OpenPopupOnItemClick(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void CloseCurrentPopup()
		{
			ImGuiNative.CloseCurrentPopup();
		}
		public static bool BeginPopupContextItem(byte* strId, ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiNative.BeginPopupContextItem(strId, popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupContextItem(byte* strId)
		{
			byte ret = ImGuiNative.BeginPopupContextItem(strId, (ImGuiPopupFlags)(1));
			return ret != 0;
		}
		public static bool BeginPopupContextItem()
		{
			byte ret = ImGuiNative.BeginPopupContextItem((byte*)(default), (ImGuiPopupFlags)(1));
			return ret != 0;
		}
		public static bool BeginPopupContextItem(ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiNative.BeginPopupContextItem((byte*)(default), popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupContextItem(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopupContextItem((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}
		public static bool BeginPopupContextItem(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopupContextItem((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}
		public static bool BeginPopupContextItem(ReadOnlySpan<byte> strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopupContextItem((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}
		public static bool BeginPopupContextItem(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopupContextItem((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}
		public static bool BeginPopupContextItem(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupContextItem(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupContextItem(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupContextItem(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupContextWindow(byte* strId, ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiNative.BeginPopupContextWindow(strId, popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupContextWindow(byte* strId)
		{
			byte ret = ImGuiNative.BeginPopupContextWindow(strId, (ImGuiPopupFlags)(1));
			return ret != 0;
		}
		public static bool BeginPopupContextWindow()
		{
			byte ret = ImGuiNative.BeginPopupContextWindow((byte*)(default), (ImGuiPopupFlags)(1));
			return ret != 0;
		}
		public static bool BeginPopupContextWindow(ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiNative.BeginPopupContextWindow((byte*)(default), popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupContextWindow(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopupContextWindow((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}
		public static bool BeginPopupContextWindow(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopupContextWindow((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}
		public static bool BeginPopupContextWindow(ReadOnlySpan<byte> strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopupContextWindow((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}
		public static bool BeginPopupContextWindow(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopupContextWindow((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}
		public static bool BeginPopupContextWindow(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupContextWindow(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupContextWindow(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupContextWindow(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupContextVoid(byte* strId, ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiNative.BeginPopupContextVoid(strId, popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupContextVoid(byte* strId)
		{
			byte ret = ImGuiNative.BeginPopupContextVoid(strId, (ImGuiPopupFlags)(1));
			return ret != 0;
		}
		public static bool BeginPopupContextVoid()
		{
			byte ret = ImGuiNative.BeginPopupContextVoid((byte*)(default), (ImGuiPopupFlags)(1));
			return ret != 0;
		}
		public static bool BeginPopupContextVoid(ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiNative.BeginPopupContextVoid((byte*)(default), popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupContextVoid(ref byte strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopupContextVoid((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}
		public static bool BeginPopupContextVoid(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginPopupContextVoid((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}
		public static bool BeginPopupContextVoid(ReadOnlySpan<byte> strId, ImGuiPopupFlags popupFlags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopupContextVoid((byte*)pstrId, popupFlags);
				return ret != 0;
			}
		}
		public static bool BeginPopupContextVoid(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginPopupContextVoid((byte*)pstrId, (ImGuiPopupFlags)(1));
				return ret != 0;
			}
		}
		public static bool BeginPopupContextVoid(string strId, ImGuiPopupFlags popupFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupContextVoid(pStr0, popupFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginPopupContextVoid(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginPopupContextVoid(pStr0, (ImGuiPopupFlags)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool IsPopupOpen(byte* strId, ImGuiPopupFlags flags)
		{
			byte ret = ImGuiNative.IsPopupOpen(strId, flags);
			return ret != 0;
		}
		public static bool IsPopupOpen(byte* strId)
		{
			byte ret = ImGuiNative.IsPopupOpen(strId, (ImGuiPopupFlags)(0));
			return ret != 0;
		}
		public static bool IsPopupOpen(ref byte strId, ImGuiPopupFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.IsPopupOpen((byte*)pstrId, flags);
				return ret != 0;
			}
		}
		public static bool IsPopupOpen(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.IsPopupOpen((byte*)pstrId, (ImGuiPopupFlags)(0));
				return ret != 0;
			}
		}
		public static bool IsPopupOpen(ReadOnlySpan<byte> strId, ImGuiPopupFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.IsPopupOpen((byte*)pstrId, flags);
				return ret != 0;
			}
		}
		public static bool IsPopupOpen(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.IsPopupOpen((byte*)pstrId, (ImGuiPopupFlags)(0));
				return ret != 0;
			}
		}
		public static bool IsPopupOpen(string strId, ImGuiPopupFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.IsPopupOpen(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool IsPopupOpen(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.IsPopupOpen(pStr0, (ImGuiPopupFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, flags, outerSize, innerWidth);
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, flags, outerSize, (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, Vector2 outerSize)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, ImGuiTableFlags flags, float innerWidth)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, float innerWidth)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			return ret != 0;
		}
		public static bool BeginTable(byte* strId, int column, Vector2 outerSize, float innerWidth)
		{
			byte ret = ImGuiNative.BeginTable(strId, column, (ImGuiTableFlags)(0), outerSize, innerWidth);
			return ret != 0;
		}
		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column, Vector2 outerSize)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ref byte strId, int column, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, ImGuiTableFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, Vector2 outerSize)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(ReadOnlySpan<byte> strId, int column, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTable((byte*)pstrId, column, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, flags, outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column, ImGuiTableFlags flags, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTable(string strId, int column, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTable(pStr0, column, (ImGuiTableFlags)(0), outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void EndTable()
		{
			ImGuiNative.EndTable();
		}
		public static void TableNextRow(ImGuiTableRowFlags rowFlags, float minRowHeight)
		{
			ImGuiNative.TableNextRow(rowFlags, minRowHeight);
		}
		public static void TableNextRow(ImGuiTableRowFlags rowFlags)
		{
			ImGuiNative.TableNextRow(rowFlags, (float)(0.0f));
		}
		public static void TableNextRow()
		{
			ImGuiNative.TableNextRow((ImGuiTableRowFlags)(0), (float)(0.0f));
		}
		public static void TableNextRow(float minRowHeight)
		{
			ImGuiNative.TableNextRow((ImGuiTableRowFlags)(0), minRowHeight);
		}
		public static bool TableNextColumn()
		{
			byte ret = ImGuiNative.TableNextColumn();
			return ret != 0;
		}
		public static bool TableSetColumnIndex(int columnN)
		{
			byte ret = ImGuiNative.TableSetColumnIndex(columnN);
			return ret != 0;
		}
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			ImGuiNative.TableSetupColumn(label, flags, initWidthOrWeight, userId);
		}
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			ImGuiNative.TableSetupColumn(label, flags, initWidthOrWeight, (uint)(0));
		}
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags)
		{
			ImGuiNative.TableSetupColumn(label, flags, (float)(0.0f), (uint)(0));
		}
		public static void TableSetupColumn(byte* label)
		{
			ImGuiNative.TableSetupColumn(label, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
		}
		public static void TableSetupColumn(byte* label, float initWidthOrWeight)
		{
			ImGuiNative.TableSetupColumn(label, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
		}
		public static void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags, uint userId)
		{
			ImGuiNative.TableSetupColumn(label, flags, (float)(0.0f), userId);
		}
		public static void TableSetupColumn(byte* label, uint userId)
		{
			ImGuiNative.TableSetupColumn(label, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
		}
		public static void TableSetupColumn(byte* label, float initWidthOrWeight, uint userId)
		{
			ImGuiNative.TableSetupColumn(label, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
		}
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, initWidthOrWeight, userId);
			}
		}
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, initWidthOrWeight, (uint)(0));
			}
		}
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, (float)(0.0f), (uint)(0));
			}
		}
		public static void TableSetupColumn(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
			}
		}
		public static void TableSetupColumn(ref byte label, float initWidthOrWeight)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
			}
		}
		public static void TableSetupColumn(ref byte label, ImGuiTableColumnFlags flags, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, (float)(0.0f), userId);
			}
		}
		public static void TableSetupColumn(ref byte label, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
			}
		}
		public static void TableSetupColumn(ref byte label, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, initWidthOrWeight, userId);
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, initWidthOrWeight, (uint)(0));
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, (float)(0.0f), (uint)(0));
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, float initWidthOrWeight)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, ImGuiTableColumnFlags flags, uint userId)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, flags, (float)(0.0f), userId);
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, uint userId)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
			}
		}
		public static void TableSetupColumn(ReadOnlySpan<byte> label, float initWidthOrWeight, uint userId)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableSetupColumn((byte*)plabel, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
			}
		}
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, flags, initWidthOrWeight, userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, float initWidthOrWeight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, flags, initWidthOrWeight, (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, flags, (float)(0.0f), (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, (ImGuiTableColumnFlags)(0), (float)(0.0f), (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label, float initWidthOrWeight)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, (ImGuiTableColumnFlags)(0), initWidthOrWeight, (uint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label, ImGuiTableColumnFlags flags, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, flags, (float)(0.0f), userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, (ImGuiTableColumnFlags)(0), (float)(0.0f), userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupColumn(string label, float initWidthOrWeight, uint userId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableSetupColumn(pStr0, (ImGuiTableColumnFlags)(0), initWidthOrWeight, userId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TableSetupScrollFreeze(int cols, int rows)
		{
			ImGuiNative.TableSetupScrollFreeze(cols, rows);
		}
		public static void TableHeadersRow()
		{
			ImGuiNative.TableHeadersRow();
		}
		public static void TableHeader(byte* label)
		{
			ImGuiNative.TableHeader(label);
		}
		public static void TableHeader(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiNative.TableHeader((byte*)plabel);
			}
		}
		public static void TableHeader(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiNative.TableHeader((byte*)plabel);
			}
		}
		public static void TableHeader(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.TableHeader(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static ImGuiTableSortSpecsPtr TableGetSortSpecs()
		{
			ImGuiTableSortSpecsPtr ret = ImGuiNative.TableGetSortSpecs();
			return ret;
		}
		public static int TableGetColumnCount()
		{
			int ret = ImGuiNative.TableGetColumnCount();
			return ret;
		}
		public static int TableGetColumnIndex()
		{
			int ret = ImGuiNative.TableGetColumnIndex();
			return ret;
		}
		public static int TableGetRowIndex()
		{
			int ret = ImGuiNative.TableGetRowIndex();
			return ret;
		}
		public static byte* TableGetColumnName(int columnN)
		{
			byte* ret = ImGuiNative.TableGetColumnName(columnN);
			return ret;
		}
		public static byte* TableGetColumnName()
		{
			byte* ret = ImGuiNative.TableGetColumnName((int)(-1));
			return ret;
		}
		public static string TableGetColumnNameS()
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.TableGetColumnName((int)(-1)));
			return ret;
		}
		public static string TableGetColumnNameS(int columnN)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.TableGetColumnName(columnN));
			return ret;
		}
		public static ImGuiTableColumnFlags TableGetColumnFlags(int columnN)
		{
			ImGuiTableColumnFlags ret = ImGuiNative.TableGetColumnFlags(columnN);
			return ret;
		}
		public static ImGuiTableColumnFlags TableGetColumnFlags()
		{
			ImGuiTableColumnFlags ret = ImGuiNative.TableGetColumnFlags((int)(-1));
			return ret;
		}
		public static void TableSetColumnEnabled(int columnN, bool v)
		{
			ImGuiNative.TableSetColumnEnabled(columnN, v ? (byte)1 : (byte)0);
		}
		public static void TableSetBgColor(ImGuiTableBgTarget target, uint color, int columnN)
		{
			ImGuiNative.TableSetBgColor(target, color, columnN);
		}
		public static void TableSetBgColor(ImGuiTableBgTarget target, uint color)
		{
			ImGuiNative.TableSetBgColor(target, color, (int)(-1));
		}
		public static void Columns(int count, byte* id, bool border)
		{
			ImGuiNative.Columns(count, id, border ? (byte)1 : (byte)0);
		}
		public static void Columns(int count, byte* id)
		{
			ImGuiNative.Columns(count, id, (byte)(1));
		}
		public static void Columns(int count)
		{
			ImGuiNative.Columns(count, (byte*)(default), (byte)(1));
		}
		public static void Columns()
		{
			ImGuiNative.Columns((int)(1), (byte*)(default), (byte)(1));
		}
		public static void Columns(byte* id)
		{
			ImGuiNative.Columns((int)(1), id, (byte)(1));
		}
		public static void Columns(int count, bool border)
		{
			ImGuiNative.Columns(count, (byte*)(default), border ? (byte)1 : (byte)0);
		}
		public static void Columns(bool border)
		{
			ImGuiNative.Columns((int)(1), (byte*)(default), border ? (byte)1 : (byte)0);
		}
		public static void Columns(byte* id, bool border)
		{
			ImGuiNative.Columns((int)(1), id, border ? (byte)1 : (byte)0);
		}
		public static void Columns(int count, ref byte id, bool border)
		{
			fixed (byte* pid = &id)
			{
				ImGuiNative.Columns(count, (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}
		public static void Columns(int count, ref byte id)
		{
			fixed (byte* pid = &id)
			{
				ImGuiNative.Columns(count, (byte*)pid, (byte)(1));
			}
		}
		public static void Columns(ref byte id)
		{
			fixed (byte* pid = &id)
			{
				ImGuiNative.Columns((int)(1), (byte*)pid, (byte)(1));
			}
		}
		public static void Columns(ref byte id, bool border)
		{
			fixed (byte* pid = &id)
			{
				ImGuiNative.Columns((int)(1), (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}
		public static void Columns(int count, ReadOnlySpan<byte> id, bool border)
		{
			fixed (byte* pid = id)
			{
				ImGuiNative.Columns(count, (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}
		public static void Columns(int count, ReadOnlySpan<byte> id)
		{
			fixed (byte* pid = id)
			{
				ImGuiNative.Columns(count, (byte*)pid, (byte)(1));
			}
		}
		public static void Columns(ReadOnlySpan<byte> id)
		{
			fixed (byte* pid = id)
			{
				ImGuiNative.Columns((int)(1), (byte*)pid, (byte)(1));
			}
		}
		public static void Columns(ReadOnlySpan<byte> id, bool border)
		{
			fixed (byte* pid = id)
			{
				ImGuiNative.Columns((int)(1), (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}
		public static void Columns(int count, string id, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Columns(count, pStr0, border ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Columns(int count, string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Columns(count, pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Columns(string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Columns((int)(1), pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void Columns(string id, bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.Columns((int)(1), pStr0, border ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void NextColumn()
		{
			ImGuiNative.NextColumn();
		}
		public static int GetColumnIndex()
		{
			int ret = ImGuiNative.GetColumnIndex();
			return ret;
		}
		public static float GetColumnWidth(int columnIndex)
		{
			float ret = ImGuiNative.GetColumnWidth(columnIndex);
			return ret;
		}
		public static float GetColumnWidth()
		{
			float ret = ImGuiNative.GetColumnWidth((int)(-1));
			return ret;
		}
		public static void SetColumnWidth(int columnIndex, float width)
		{
			ImGuiNative.SetColumnWidth(columnIndex, width);
		}
		public static float GetColumnOffset(int columnIndex)
		{
			float ret = ImGuiNative.GetColumnOffset(columnIndex);
			return ret;
		}
		public static float GetColumnOffset()
		{
			float ret = ImGuiNative.GetColumnOffset((int)(-1));
			return ret;
		}
		public static void SetColumnOffset(int columnIndex, float offsetX)
		{
			ImGuiNative.SetColumnOffset(columnIndex, offsetX);
		}
		public static int GetColumnsCount()
		{
			int ret = ImGuiNative.GetColumnsCount();
			return ret;
		}
		public static bool BeginTabBar(byte* strId, ImGuiTabBarFlags flags)
		{
			byte ret = ImGuiNative.BeginTabBar(strId, flags);
			return ret != 0;
		}
		public static bool BeginTabBar(byte* strId)
		{
			byte ret = ImGuiNative.BeginTabBar(strId, (ImGuiTabBarFlags)(0));
			return ret != 0;
		}
		public static bool BeginTabBar(ref byte strId, ImGuiTabBarFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTabBar((byte*)pstrId, flags);
				return ret != 0;
			}
		}
		public static bool BeginTabBar(ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiNative.BeginTabBar((byte*)pstrId, (ImGuiTabBarFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabBar(ReadOnlySpan<byte> strId, ImGuiTabBarFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTabBar((byte*)pstrId, flags);
				return ret != 0;
			}
		}
		public static bool BeginTabBar(ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiNative.BeginTabBar((byte*)pstrId, (ImGuiTabBarFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabBar(string strId, ImGuiTabBarFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTabBar(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTabBar(string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTabBar(pStr0, (ImGuiTabBarFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void EndTabBar()
		{
			ImGuiNative.EndTabBar();
		}
		public static bool BeginTabItem(byte* label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte ret = ImGuiNative.BeginTabItem(label, pOpen, flags);
			return ret != 0;
		}
		public static bool BeginTabItem(byte* label, bool* pOpen)
		{
			byte ret = ImGuiNative.BeginTabItem(label, pOpen, (ImGuiTabItemFlags)(0));
			return ret != 0;
		}
		public static bool BeginTabItem(byte* label)
		{
			byte ret = ImGuiNative.BeginTabItem(label, (bool*)(default), (ImGuiTabItemFlags)(0));
			return ret != 0;
		}
		public static bool BeginTabItem(byte* label, ImGuiTabItemFlags flags)
		{
			byte ret = ImGuiNative.BeginTabItem(label, (bool*)(default), flags);
			return ret != 0;
		}
		public static bool BeginTabItem(ref byte label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, pOpen, flags);
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ref byte label, bool* pOpen)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, pOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)(default), (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ref byte label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)(default), flags);
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, pOpen, flags);
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ReadOnlySpan<byte> label, bool* pOpen)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, pOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)(default), (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ReadOnlySpan<byte> label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)(default), flags);
				return ret != 0;
			}
		}
		public static bool BeginTabItem(string label, bool* pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTabItem(pStr0, pOpen, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTabItem(string label, bool* pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTabItem(pStr0, pOpen, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTabItem(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTabItem(pStr0, (bool*)(default), (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTabItem(string label, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.BeginTabItem(pStr0, (bool*)(default), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTabItem(byte* label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginTabItem(label, (bool*)ppOpen, flags);
				return ret != 0;
			}
		}
		public static bool BeginTabItem(byte* label, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginTabItem(label, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool BeginTabItem(ref byte label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginTabItem(ref byte label, ref bool pOpen)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginTabItem(ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)ppOpen, flags);
					return ret != 0;
				}
			}
		}
		public static bool BeginTabItem(ReadOnlySpan<byte> label, ref bool pOpen)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiNative.BeginTabItem((byte*)plabel, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool BeginTabItem(string label, ref bool pOpen, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginTabItem(pStr0, (bool*)ppOpen, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginTabItem(string label, ref bool pOpen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiNative.BeginTabItem(pStr0, (bool*)ppOpen, (ImGuiTabItemFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void EndTabItem()
		{
			ImGuiNative.EndTabItem();
		}
		public static bool TabItemButton(byte* label, ImGuiTabItemFlags flags)
		{
			byte ret = ImGuiNative.TabItemButton(label, flags);
			return ret != 0;
		}
		public static bool TabItemButton(byte* label)
		{
			byte ret = ImGuiNative.TabItemButton(label, (ImGuiTabItemFlags)(0));
			return ret != 0;
		}
		public static bool TabItemButton(ref byte label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.TabItemButton((byte*)plabel, flags);
				return ret != 0;
			}
		}
		public static bool TabItemButton(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.TabItemButton((byte*)plabel, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool TabItemButton(ReadOnlySpan<byte> label, ImGuiTabItemFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.TabItemButton((byte*)plabel, flags);
				return ret != 0;
			}
		}
		public static bool TabItemButton(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.TabItemButton((byte*)plabel, (ImGuiTabItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool TabItemButton(string label, ImGuiTabItemFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.TabItemButton(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TabItemButton(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.TabItemButton(pStr0, (ImGuiTabItemFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void SetTabItemClosed(byte* tabOrDockedWindowLabel)
		{
			ImGuiNative.SetTabItemClosed(tabOrDockedWindowLabel);
		}
		public static void SetTabItemClosed(ref byte tabOrDockedWindowLabel)
		{
			fixed (byte* ptabOrDockedWindowLabel = &tabOrDockedWindowLabel)
			{
				ImGuiNative.SetTabItemClosed((byte*)ptabOrDockedWindowLabel);
			}
		}
		public static void SetTabItemClosed(ReadOnlySpan<byte> tabOrDockedWindowLabel)
		{
			fixed (byte* ptabOrDockedWindowLabel = tabOrDockedWindowLabel)
			{
				ImGuiNative.SetTabItemClosed((byte*)ptabOrDockedWindowLabel);
			}
		}
		public static void SetTabItemClosed(string tabOrDockedWindowLabel)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tabOrDockedWindowLabel != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tabOrDockedWindowLabel);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tabOrDockedWindowLabel, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetTabItemClosed(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static uint DockSpace(uint id, Vector2 size, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpace(id, size, flags, windowClass);
			return ret;
		}
		public static uint DockSpace(uint id, Vector2 size, ImGuiDockNodeFlags flags)
		{
			uint ret = ImGuiNative.DockSpace(id, size, flags, (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpace(uint id, Vector2 size)
		{
			uint ret = ImGuiNative.DockSpace(id, size, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpace(uint id)
		{
			uint ret = ImGuiNative.DockSpace(id, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpace(uint id, ImGuiDockNodeFlags flags)
		{
			uint ret = ImGuiNative.DockSpace(id, (Vector2)(new Vector2(0,0)), flags, (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpace(uint id, Vector2 size, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpace(id, size, (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}
		public static uint DockSpace(uint id, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpace(id, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}
		public static uint DockSpace(uint id, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpace(id, (Vector2)(new Vector2(0,0)), flags, windowClass);
			return ret;
		}
		public static uint DockSpace(uint id, Vector2 size, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpace(id, size, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpace(uint id, Vector2 size, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpace(id, size, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpace(uint id, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpace(id, (Vector2)(new Vector2(0,0)), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpace(uint id, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpace(id, (Vector2)(new Vector2(0,0)), flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport(viewport, flags, windowClass);
			return ret;
		}
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport(viewport, flags, (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport(viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpaceOverViewport()
		{
			uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpaceOverViewport(ImGuiDockNodeFlags flags)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)(default), flags, (ImGuiWindowClass*)(default));
			return ret;
		}
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport(viewport, (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}
		public static uint DockSpaceOverViewport(ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), windowClass);
			return ret;
		}
		public static uint DockSpaceOverViewport(ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)(default), flags, windowClass);
			return ret;
		}
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ImGuiWindowClassPtr windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)pviewport, flags, windowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)(default));
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)(default));
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiWindowClassPtr windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), windowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport(viewport, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ImGuiViewportPtr viewport, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport(viewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)(default), (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)(default), flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ImGuiDockNodeFlags flags, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)pviewport, flags, (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}
		public static uint DockSpaceOverViewport(ref ImGuiViewport viewport, ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				fixed (ImGuiWindowClass* pwindowClass = &windowClass)
				{
					uint ret = ImGuiNative.DockSpaceOverViewport((ImGuiViewport*)pviewport, (ImGuiDockNodeFlags)(0), (ImGuiWindowClass*)pwindowClass);
					return ret;
				}
			}
		}
		public static void SetNextWindowDockID(uint dockId, ImGuiCond cond)
		{
			ImGuiNative.SetNextWindowDockID(dockId, cond);
		}
		public static void SetNextWindowDockID(uint dockId)
		{
			ImGuiNative.SetNextWindowDockID(dockId, (ImGuiCond)(0));
		}
		public static void SetNextWindowClass(ImGuiWindowClassPtr windowClass)
		{
			ImGuiNative.SetNextWindowClass(windowClass);
		}
		public static void SetNextWindowClass(ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				ImGuiNative.SetNextWindowClass((ImGuiWindowClass*)pwindowClass);
			}
		}
		public static uint GetWindowDockID()
		{
			uint ret = ImGuiNative.GetWindowDockID();
			return ret;
		}
		public static bool IsWindowDocked()
		{
			byte ret = ImGuiNative.IsWindowDocked();
			return ret != 0;
		}
		public static void LogToTTY(int autoOpenDepth)
		{
			ImGuiNative.LogToTTY(autoOpenDepth);
		}
		public static void LogToTTY()
		{
			ImGuiNative.LogToTTY((int)(-1));
		}
		public static void LogToFile(int autoOpenDepth, byte* filename)
		{
			ImGuiNative.LogToFile(autoOpenDepth, filename);
		}
		public static void LogToFile(int autoOpenDepth)
		{
			ImGuiNative.LogToFile(autoOpenDepth, (byte*)(default));
		}
		public static void LogToFile()
		{
			ImGuiNative.LogToFile((int)(-1), (byte*)(default));
		}
		public static void LogToFile(byte* filename)
		{
			ImGuiNative.LogToFile((int)(-1), filename);
		}
		public static void LogToFile(int autoOpenDepth, ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				ImGuiNative.LogToFile(autoOpenDepth, (byte*)pfilename);
			}
		}
		public static void LogToFile(ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				ImGuiNative.LogToFile((int)(-1), (byte*)pfilename);
			}
		}
		public static void LogToFile(int autoOpenDepth, ReadOnlySpan<byte> filename)
		{
			fixed (byte* pfilename = filename)
			{
				ImGuiNative.LogToFile(autoOpenDepth, (byte*)pfilename);
			}
		}
		public static void LogToFile(ReadOnlySpan<byte> filename)
		{
			fixed (byte* pfilename = filename)
			{
				ImGuiNative.LogToFile((int)(-1), (byte*)pfilename);
			}
		}
		public static void LogToFile(int autoOpenDepth, string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.LogToFile(autoOpenDepth, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LogToFile(string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.LogToFile((int)(-1), pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LogToClipboard(int autoOpenDepth)
		{
			ImGuiNative.LogToClipboard(autoOpenDepth);
		}
		public static void LogToClipboard()
		{
			ImGuiNative.LogToClipboard((int)(-1));
		}
		public static void LogFinish()
		{
			ImGuiNative.LogFinish();
		}
		public static void LogButtons()
		{
			ImGuiNative.LogButtons();
		}
		public static bool BeginDragDropSource(ImGuiDragDropFlags flags)
		{
			byte ret = ImGuiNative.BeginDragDropSource(flags);
			return ret != 0;
		}
		public static bool BeginDragDropSource()
		{
			byte ret = ImGuiNative.BeginDragDropSource((ImGuiDragDropFlags)(0));
			return ret != 0;
		}
		public static bool SetDragDropPayload(byte* type, void* data, nuint sz, ImGuiCond cond)
		{
			byte ret = ImGuiNative.SetDragDropPayload(type, data, sz, cond);
			return ret != 0;
		}
		public static bool SetDragDropPayload(byte* type, void* data, nuint sz)
		{
			byte ret = ImGuiNative.SetDragDropPayload(type, data, sz, (ImGuiCond)(0));
			return ret != 0;
		}
		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz, ImGuiCond cond)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = ImGuiNative.SetDragDropPayload((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}
		public static bool SetDragDropPayload(ref byte type, void* data, nuint sz)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = ImGuiNative.SetDragDropPayload((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}
		public static bool SetDragDropPayload(ReadOnlySpan<byte> type, void* data, nuint sz, ImGuiCond cond)
		{
			fixed (byte* ptype = type)
			{
				byte ret = ImGuiNative.SetDragDropPayload((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}
		public static bool SetDragDropPayload(ReadOnlySpan<byte> type, void* data, nuint sz)
		{
			fixed (byte* ptype = type)
			{
				byte ret = ImGuiNative.SetDragDropPayload((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}
		public static bool SetDragDropPayload(string type, void* data, nuint sz, ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.SetDragDropPayload(pStr0, data, sz, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool SetDragDropPayload(string type, void* data, nuint sz)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.SetDragDropPayload(pStr0, data, sz, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void EndDragDropSource()
		{
			ImGuiNative.EndDragDropSource();
		}
		public static bool BeginDragDropTarget()
		{
			byte ret = ImGuiNative.BeginDragDropTarget();
			return ret != 0;
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(byte* type, ImGuiDragDropFlags flags)
		{
			ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload(type, flags);
			return ret;
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(byte* type)
		{
			ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload(type, (ImGuiDragDropFlags)(0));
			return ret;
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(ref byte type, ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload((byte*)ptype, flags);
				return ret;
			}
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(ReadOnlySpan<byte> type, ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = type)
			{
				ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload((byte*)ptype, flags);
				return ret;
			}
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(string type, ImGuiDragDropFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiPayloadPtr AcceptDragDropPayload(string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayloadPtr ret = ImGuiNative.AcceptDragDropPayload(pStr0, (ImGuiDragDropFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void EndDragDropTarget()
		{
			ImGuiNative.EndDragDropTarget();
		}
		public static ImGuiPayloadPtr GetDragDropPayload()
		{
			ImGuiPayloadPtr ret = ImGuiNative.GetDragDropPayload();
			return ret;
		}
		public static void BeginDisabled(bool disabled)
		{
			ImGuiNative.BeginDisabled(disabled ? (byte)1 : (byte)0);
		}
		public static void BeginDisabled()
		{
			ImGuiNative.BeginDisabled((byte)(1));
		}
		public static void EndDisabled()
		{
			ImGuiNative.EndDisabled();
		}
		public static void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			ImGuiNative.PushClipRect(clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}
		public static void PushClipRect(ImDrawListPtr self, Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			ImGuiNative.PushClipRect(self, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}
		public static void PushClipRect(ImDrawListPtr self, Vector2 clipRectMin, Vector2 clipRectMax)
		{
			ImGuiNative.PushClipRect(self, clipRectMin, clipRectMax, (byte)(0));
		}
		public static void PushClipRect(ref ImDrawList self, Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PushClipRect((ImDrawList*)pself, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}
		public static void PushClipRect(ref ImDrawList self, Vector2 clipRectMin, Vector2 clipRectMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PushClipRect((ImDrawList*)pself, clipRectMin, clipRectMax, (byte)(0));
			}
		}
		public static void PopClipRect()
		{
			ImGuiNative.PopClipRect();
		}
		public static void PopClipRect(ImDrawListPtr self)
		{
			ImGuiNative.PopClipRect(self);
		}
		public static void PopClipRect(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PopClipRect((ImDrawList*)pself);
			}
		}
		public static void SetItemDefaultFocus()
		{
			ImGuiNative.SetItemDefaultFocus();
		}
		public static void SetKeyboardFocusHere(int offset)
		{
			ImGuiNative.SetKeyboardFocusHere(offset);
		}
		public static void SetKeyboardFocusHere()
		{
			ImGuiNative.SetKeyboardFocusHere((int)(0));
		}
		public static bool IsItemHovered(ImGuiHoveredFlags flags)
		{
			byte ret = ImGuiNative.IsItemHovered(flags);
			return ret != 0;
		}
		public static bool IsItemHovered()
		{
			byte ret = ImGuiNative.IsItemHovered((ImGuiHoveredFlags)(0));
			return ret != 0;
		}
		public static bool IsItemActive()
		{
			byte ret = ImGuiNative.IsItemActive();
			return ret != 0;
		}
		public static bool IsItemFocused()
		{
			byte ret = ImGuiNative.IsItemFocused();
			return ret != 0;
		}
		public static bool IsItemClicked(ImGuiMouseButton mouseButton)
		{
			byte ret = ImGuiNative.IsItemClicked(mouseButton);
			return ret != 0;
		}
		public static bool IsItemClicked()
		{
			byte ret = ImGuiNative.IsItemClicked((ImGuiMouseButton)(0));
			return ret != 0;
		}
		public static bool IsItemVisible()
		{
			byte ret = ImGuiNative.IsItemVisible();
			return ret != 0;
		}
		public static bool IsItemEdited()
		{
			byte ret = ImGuiNative.IsItemEdited();
			return ret != 0;
		}
		public static bool IsItemActivated()
		{
			byte ret = ImGuiNative.IsItemActivated();
			return ret != 0;
		}
		public static bool IsItemDeactivated()
		{
			byte ret = ImGuiNative.IsItemDeactivated();
			return ret != 0;
		}
		public static bool IsItemDeactivatedAfterEdit()
		{
			byte ret = ImGuiNative.IsItemDeactivatedAfterEdit();
			return ret != 0;
		}
		public static bool IsItemToggledOpen()
		{
			byte ret = ImGuiNative.IsItemToggledOpen();
			return ret != 0;
		}
		public static bool IsAnyItemHovered()
		{
			byte ret = ImGuiNative.IsAnyItemHovered();
			return ret != 0;
		}
		public static bool IsAnyItemActive()
		{
			byte ret = ImGuiNative.IsAnyItemActive();
			return ret != 0;
		}
		public static bool IsAnyItemFocused()
		{
			byte ret = ImGuiNative.IsAnyItemFocused();
			return ret != 0;
		}
		public static Vector2 GetItemRectMin()
		{
			Vector2 ret;
			ImGuiNative.GetItemRectMin(&ret);
			return ret;
		}
		public static void GetItemRectMin(Vector2* pOut)
		{
			ImGuiNative.GetItemRectMin(pOut);
		}
		public static void GetItemRectMin(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetItemRectMin((Vector2*)ppOut);
			}
		}
		public static Vector2 GetItemRectMax()
		{
			Vector2 ret;
			ImGuiNative.GetItemRectMax(&ret);
			return ret;
		}
		public static void GetItemRectMax(Vector2* pOut)
		{
			ImGuiNative.GetItemRectMax(pOut);
		}
		public static void GetItemRectMax(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetItemRectMax((Vector2*)ppOut);
			}
		}
		public static Vector2 GetItemRectSize()
		{
			Vector2 ret;
			ImGuiNative.GetItemRectSize(&ret);
			return ret;
		}
		public static void GetItemRectSize(Vector2* pOut)
		{
			ImGuiNative.GetItemRectSize(pOut);
		}
		public static void GetItemRectSize(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetItemRectSize((Vector2*)ppOut);
			}
		}
		public static void SetItemAllowOverlap()
		{
			ImGuiNative.SetItemAllowOverlap();
		}
		public static ImGuiViewportPtr GetMainViewport()
		{
			ImGuiViewportPtr ret = ImGuiNative.GetMainViewport();
			return ret;
		}
		public static ImDrawListPtr GetBackgroundDrawList()
		{
			ImDrawListPtr ret = ImGuiNative.GetBackgroundDrawList();
			return ret;
		}
		public static ImDrawListPtr GetBackgroundDrawList(ImGuiViewportPtr viewport)
		{
			ImDrawListPtr ret = ImGuiNative.GetBackgroundDrawList(viewport);
			return ret;
		}
		public static ImDrawListPtr GetBackgroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawListPtr ret = ImGuiNative.GetBackgroundDrawList((ImGuiViewport*)pviewport);
				return ret;
			}
		}
		public static ImDrawListPtr GetForegroundDrawList()
		{
			ImDrawListPtr ret = ImGuiNative.GetForegroundDrawList();
			return ret;
		}
		public static ImDrawListPtr GetForegroundDrawList(ImGuiViewportPtr viewport)
		{
			ImDrawListPtr ret = ImGuiNative.GetForegroundDrawList(viewport);
			return ret;
		}
		public static ImDrawListPtr GetForegroundDrawList(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawListPtr ret = ImGuiNative.GetForegroundDrawList((ImGuiViewport*)pviewport);
				return ret;
			}
		}
		public static bool IsRectVisible(Vector2 size)
		{
			byte ret = ImGuiNative.IsRectVisible(size);
			return ret != 0;
		}
		public static bool IsRectVisible(Vector2 rectMin, Vector2 rectMax)
		{
			byte ret = ImGuiNative.IsRectVisible(rectMin, rectMax);
			return ret != 0;
		}
		public static double GetTime()
		{
			double ret = ImGuiNative.GetTime();
			return ret;
		}
		public static int GetFrameCount()
		{
			int ret = ImGuiNative.GetFrameCount();
			return ret;
		}
		public static ImDrawListSharedDataPtr GetDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImGuiNative.GetDrawListSharedData();
			return ret;
		}
		public static byte* GetStyleColorName(ImGuiCol idx)
		{
			byte* ret = ImGuiNative.GetStyleColorName(idx);
			return ret;
		}
		public static string GetStyleColorNameS(ImGuiCol idx)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.GetStyleColorName(idx));
			return ret;
		}
		public static void SetStateStorage(ImGuiStoragePtr storage)
		{
			ImGuiNative.SetStateStorage(storage);
		}
		public static void SetStateStorage(ref ImGuiStorage storage)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				ImGuiNative.SetStateStorage((ImGuiStorage*)pstorage);
			}
		}
		public static ImGuiStoragePtr GetStateStorage()
		{
			ImGuiStoragePtr ret = ImGuiNative.GetStateStorage();
			return ret;
		}
		public static bool BeginChildFrame(uint id, Vector2 size, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiNative.BeginChildFrame(id, size, flags);
			return ret != 0;
		}
		public static bool BeginChildFrame(uint id, Vector2 size)
		{
			byte ret = ImGuiNative.BeginChildFrame(id, size, (ImGuiWindowFlags)(0));
			return ret != 0;
		}
		public static void EndChildFrame()
		{
			ImGuiNative.EndChildFrame();
		}
		public static Vector4 ColorConvertU32ToFloat4(uint input)
		{
			Vector4 ret;
			ImGuiNative.ColorConvertU32ToFloat4(&ret, input);
			return ret;
		}
		public static void ColorConvertU32ToFloat4(Vector4* pOut, uint input)
		{
			ImGuiNative.ColorConvertU32ToFloat4(pOut, input);
		}
		public static void ColorConvertU32ToFloat4(ref Vector4 pOut, uint input)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ImGuiNative.ColorConvertU32ToFloat4((Vector4*)ppOut, input);
			}
		}
		public static uint ColorConvertFloat4ToU32(Vector4 input)
		{
			uint ret = ImGuiNative.ColorConvertFloat4ToU32(input);
			return ret;
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, float* outV)
		{
			ImGuiNative.ColorConvertRGBtoHSV(r, g, b, outH, outS, outV);
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				ImGuiNative.ColorConvertRGBtoHSV(r, g, b, (float*)poutH, outS, outV);
			}
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, float* outV)
		{
			fixed (float* poutS = &outS)
			{
				ImGuiNative.ColorConvertRGBtoHSV(r, g, b, outH, (float*)poutS, outV);
			}
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					ImGuiNative.ColorConvertRGBtoHSV(r, g, b, (float*)poutH, (float*)poutS, outV);
				}
			}
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, ref float outV)
		{
			fixed (float* poutV = &outV)
			{
				ImGuiNative.ColorConvertRGBtoHSV(r, g, b, outH, outS, (float*)poutV);
			}
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutV = &outV)
				{
					ImGuiNative.ColorConvertRGBtoHSV(r, g, b, (float*)poutH, outS, (float*)poutV);
				}
			}
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, ref float outV)
		{
			fixed (float* poutS = &outS)
			{
				fixed (float* poutV = &outV)
				{
					ImGuiNative.ColorConvertRGBtoHSV(r, g, b, outH, (float*)poutS, (float*)poutV);
				}
			}
		}
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					fixed (float* poutV = &outV)
					{
						ImGuiNative.ColorConvertRGBtoHSV(r, g, b, (float*)poutH, (float*)poutS, (float*)poutV);
					}
				}
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, float* outB)
		{
			ImGuiNative.ColorConvertHSVtoRGB(h, s, v, outR, outG, outB);
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				ImGuiNative.ColorConvertHSVtoRGB(h, s, v, (float*)poutR, outG, outB);
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, float* outB)
		{
			fixed (float* poutG = &outG)
			{
				ImGuiNative.ColorConvertHSVtoRGB(h, s, v, outR, (float*)poutG, outB);
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					ImGuiNative.ColorConvertHSVtoRGB(h, s, v, (float*)poutR, (float*)poutG, outB);
				}
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, ref float outB)
		{
			fixed (float* poutB = &outB)
			{
				ImGuiNative.ColorConvertHSVtoRGB(h, s, v, outR, outG, (float*)poutB);
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutB = &outB)
				{
					ImGuiNative.ColorConvertHSVtoRGB(h, s, v, (float*)poutR, outG, (float*)poutB);
				}
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, ref float outB)
		{
			fixed (float* poutG = &outG)
			{
				fixed (float* poutB = &outB)
				{
					ImGuiNative.ColorConvertHSVtoRGB(h, s, v, outR, (float*)poutG, (float*)poutB);
				}
			}
		}
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					fixed (float* poutB = &outB)
					{
						ImGuiNative.ColorConvertHSVtoRGB(h, s, v, (float*)poutR, (float*)poutG, (float*)poutB);
					}
				}
			}
		}
		public static bool IsKeyDown(ImGuiKey key)
		{
			byte ret = ImGuiNative.IsKeyDown(key);
			return ret != 0;
		}
		public static bool IsKeyPressed(ImGuiKey key, bool repeat)
		{
			byte ret = ImGuiNative.IsKeyPressed(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool IsKeyPressed(ImGuiKey key)
		{
			byte ret = ImGuiNative.IsKeyPressed(key, (byte)(1));
			return ret != 0;
		}
		public static bool IsKeyReleased(ImGuiKey key)
		{
			byte ret = ImGuiNative.IsKeyReleased(key);
			return ret != 0;
		}
		public static int GetKeyPressedAmount(ImGuiKey key, float repeatDelay, float rate)
		{
			int ret = ImGuiNative.GetKeyPressedAmount(key, repeatDelay, rate);
			return ret;
		}
		public static byte* GetKeyName(ImGuiKey key)
		{
			byte* ret = ImGuiNative.GetKeyName(key);
			return ret;
		}
		public static string GetKeyNameS(ImGuiKey key)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.GetKeyName(key));
			return ret;
		}
		public static void SetNextFrameWantCaptureKeyboard(bool wantCaptureKeyboard)
		{
			ImGuiNative.SetNextFrameWantCaptureKeyboard(wantCaptureKeyboard ? (byte)1 : (byte)0);
		}
		public static bool IsMouseDown(ImGuiMouseButton button)
		{
			byte ret = ImGuiNative.IsMouseDown(button);
			return ret != 0;
		}
		public static bool IsMouseClicked(ImGuiMouseButton button, bool repeat)
		{
			byte ret = ImGuiNative.IsMouseClicked(button, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool IsMouseClicked(ImGuiMouseButton button)
		{
			byte ret = ImGuiNative.IsMouseClicked(button, (byte)(0));
			return ret != 0;
		}
		public static bool IsMouseReleased(ImGuiMouseButton button)
		{
			byte ret = ImGuiNative.IsMouseReleased(button);
			return ret != 0;
		}
		public static bool IsMouseDoubleClicked(ImGuiMouseButton button)
		{
			byte ret = ImGuiNative.IsMouseDoubleClicked(button);
			return ret != 0;
		}
		public static int GetMouseClickedCount(ImGuiMouseButton button)
		{
			int ret = ImGuiNative.GetMouseClickedCount(button);
			return ret;
		}
		public static bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax, bool clip)
		{
			byte ret = ImGuiNative.IsMouseHoveringRect(rMin, rMax, clip ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax)
		{
			byte ret = ImGuiNative.IsMouseHoveringRect(rMin, rMax, (byte)(1));
			return ret != 0;
		}
		public static bool IsMousePosValid(Vector2* mousePos)
		{
			byte ret = ImGuiNative.IsMousePosValid(mousePos);
			return ret != 0;
		}
		public static bool IsMousePosValid()
		{
			byte ret = ImGuiNative.IsMousePosValid((Vector2*)(default));
			return ret != 0;
		}
		public static bool IsMousePosValid(ref Vector2 mousePos)
		{
			fixed (Vector2* pmousePos = &mousePos)
			{
				byte ret = ImGuiNative.IsMousePosValid((Vector2*)pmousePos);
				return ret != 0;
			}
		}
		public static bool IsAnyMouseDown()
		{
			byte ret = ImGuiNative.IsAnyMouseDown();
			return ret != 0;
		}
		public static Vector2 GetMousePos()
		{
			Vector2 ret;
			ImGuiNative.GetMousePos(&ret);
			return ret;
		}
		public static void GetMousePos(Vector2* pOut)
		{
			ImGuiNative.GetMousePos(pOut);
		}
		public static void GetMousePos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetMousePos((Vector2*)ppOut);
			}
		}
		public static Vector2 GetMousePosOnOpeningCurrentPopup()
		{
			Vector2 ret;
			ImGuiNative.GetMousePosOnOpeningCurrentPopup(&ret);
			return ret;
		}
		public static void GetMousePosOnOpeningCurrentPopup(Vector2* pOut)
		{
			ImGuiNative.GetMousePosOnOpeningCurrentPopup(pOut);
		}
		public static void GetMousePosOnOpeningCurrentPopup(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetMousePosOnOpeningCurrentPopup((Vector2*)ppOut);
			}
		}
		public static bool IsMouseDragging(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = ImGuiNative.IsMouseDragging(button, lockThreshold);
			return ret != 0;
		}
		public static bool IsMouseDragging(ImGuiMouseButton button)
		{
			byte ret = ImGuiNative.IsMouseDragging(button, (float)(-1.0f));
			return ret != 0;
		}
		public static Vector2 GetMouseDragDelta()
		{
			Vector2 ret;
			ImGuiNative.GetMouseDragDelta(&ret, (ImGuiMouseButton)(0), (float)(-1.0f));
			return ret;
		}
		public static Vector2 GetMouseDragDelta(ImGuiMouseButton button)
		{
			Vector2 ret;
			ImGuiNative.GetMouseDragDelta(&ret, button, (float)(-1.0f));
			return ret;
		}
		public static void GetMouseDragDelta(Vector2* pOut)
		{
			ImGuiNative.GetMouseDragDelta(pOut, (ImGuiMouseButton)(0), (float)(-1.0f));
		}
		public static Vector2 GetMouseDragDelta(float lockThreshold)
		{
			Vector2 ret;
			ImGuiNative.GetMouseDragDelta(&ret, (ImGuiMouseButton)(0), lockThreshold);
			return ret;
		}
		public static Vector2 GetMouseDragDelta(ImGuiMouseButton button, float lockThreshold)
		{
			Vector2 ret;
			ImGuiNative.GetMouseDragDelta(&ret, button, lockThreshold);
			return ret;
		}
		public static void GetMouseDragDelta(Vector2* pOut, ImGuiMouseButton button, float lockThreshold)
		{
			ImGuiNative.GetMouseDragDelta(pOut, button, lockThreshold);
		}
		public static void GetMouseDragDelta(Vector2* pOut, ImGuiMouseButton button)
		{
			ImGuiNative.GetMouseDragDelta(pOut, button, (float)(-1.0f));
		}
		public static void GetMouseDragDelta(Vector2* pOut, float lockThreshold)
		{
			ImGuiNative.GetMouseDragDelta(pOut, (ImGuiMouseButton)(0), lockThreshold);
		}
		public static void GetMouseDragDelta(ref Vector2 pOut, ImGuiMouseButton button, float lockThreshold)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetMouseDragDelta((Vector2*)ppOut, button, lockThreshold);
			}
		}
		public static void GetMouseDragDelta(ref Vector2 pOut, ImGuiMouseButton button)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetMouseDragDelta((Vector2*)ppOut, button, (float)(-1.0f));
			}
		}
		public static void GetMouseDragDelta(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetMouseDragDelta((Vector2*)ppOut, (ImGuiMouseButton)(0), (float)(-1.0f));
			}
		}
		public static void GetMouseDragDelta(ref Vector2 pOut, float lockThreshold)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetMouseDragDelta((Vector2*)ppOut, (ImGuiMouseButton)(0), lockThreshold);
			}
		}
		public static void ResetMouseDragDelta(ImGuiMouseButton button)
		{
			ImGuiNative.ResetMouseDragDelta(button);
		}
		public static void ResetMouseDragDelta()
		{
			ImGuiNative.ResetMouseDragDelta((ImGuiMouseButton)(0));
		}
		public static ImGuiMouseCursor GetMouseCursor()
		{
			ImGuiMouseCursor ret = ImGuiNative.GetMouseCursor();
			return ret;
		}
		public static void SetMouseCursor(ImGuiMouseCursor cursorType)
		{
			ImGuiNative.SetMouseCursor(cursorType);
		}
		public static void SetNextFrameWantCaptureMouse(bool wantCaptureMouse)
		{
			ImGuiNative.SetNextFrameWantCaptureMouse(wantCaptureMouse ? (byte)1 : (byte)0);
		}
		public static byte* GetClipboardText()
		{
			byte* ret = ImGuiNative.GetClipboardText();
			return ret;
		}
		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.GetClipboardText());
			return ret;
		}
		public static void SetClipboardText(byte* text)
		{
			ImGuiNative.SetClipboardText(text);
		}
		public static void SetClipboardText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				ImGuiNative.SetClipboardText((byte*)ptext);
			}
		}
		public static void SetClipboardText(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				ImGuiNative.SetClipboardText((byte*)ptext);
			}
		}
		public static void SetClipboardText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SetClipboardText(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LoadIniSettingsFromDisk(byte* iniFilename)
		{
			ImGuiNative.LoadIniSettingsFromDisk(iniFilename);
		}
		public static void LoadIniSettingsFromDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				ImGuiNative.LoadIniSettingsFromDisk((byte*)piniFilename);
			}
		}
		public static void LoadIniSettingsFromDisk(ReadOnlySpan<byte> iniFilename)
		{
			fixed (byte* piniFilename = iniFilename)
			{
				ImGuiNative.LoadIniSettingsFromDisk((byte*)piniFilename);
			}
		}
		public static void LoadIniSettingsFromDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.LoadIniSettingsFromDisk(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LoadIniSettingsFromMemory(byte* iniData, nuint iniSize)
		{
			ImGuiNative.LoadIniSettingsFromMemory(iniData, iniSize);
		}
		public static void LoadIniSettingsFromMemory(byte* iniData)
		{
			ImGuiNative.LoadIniSettingsFromMemory(iniData, (nuint)(0));
		}
		public static void LoadIniSettingsFromMemory(ref byte iniData, nuint iniSize)
		{
			fixed (byte* piniData = &iniData)
			{
				ImGuiNative.LoadIniSettingsFromMemory((byte*)piniData, iniSize);
			}
		}
		public static void LoadIniSettingsFromMemory(ref byte iniData)
		{
			fixed (byte* piniData = &iniData)
			{
				ImGuiNative.LoadIniSettingsFromMemory((byte*)piniData, (nuint)(0));
			}
		}
		public static void LoadIniSettingsFromMemory(ReadOnlySpan<byte> iniData, nuint iniSize)
		{
			fixed (byte* piniData = iniData)
			{
				ImGuiNative.LoadIniSettingsFromMemory((byte*)piniData, iniSize);
			}
		}
		public static void LoadIniSettingsFromMemory(ReadOnlySpan<byte> iniData)
		{
			fixed (byte* piniData = iniData)
			{
				ImGuiNative.LoadIniSettingsFromMemory((byte*)piniData, (nuint)(0));
			}
		}
		public static void LoadIniSettingsFromMemory(string iniData, nuint iniSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.LoadIniSettingsFromMemory(pStr0, iniSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LoadIniSettingsFromMemory(string iniData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.LoadIniSettingsFromMemory(pStr0, (nuint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void SaveIniSettingsToDisk(byte* iniFilename)
		{
			ImGuiNative.SaveIniSettingsToDisk(iniFilename);
		}
		public static void SaveIniSettingsToDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				ImGuiNative.SaveIniSettingsToDisk((byte*)piniFilename);
			}
		}
		public static void SaveIniSettingsToDisk(ReadOnlySpan<byte> iniFilename)
		{
			fixed (byte* piniFilename = iniFilename)
			{
				ImGuiNative.SaveIniSettingsToDisk((byte*)piniFilename);
			}
		}
		public static void SaveIniSettingsToDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.SaveIniSettingsToDisk(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static byte* SaveIniSettingsToMemory(nuint* outIniSize)
		{
			byte* ret = ImGuiNative.SaveIniSettingsToMemory(outIniSize);
			return ret;
		}
		public static byte* SaveIniSettingsToMemory()
		{
			byte* ret = ImGuiNative.SaveIniSettingsToMemory((nuint*)(default));
			return ret;
		}
		public static string SaveIniSettingsToMemoryS()
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.SaveIniSettingsToMemory((nuint*)(default)));
			return ret;
		}
		public static string SaveIniSettingsToMemoryS(nuint* outIniSize)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.SaveIniSettingsToMemory(outIniSize));
			return ret;
		}
		public static void DebugTextEncoding(byte* text)
		{
			ImGuiNative.DebugTextEncoding(text);
		}
		public static void DebugTextEncoding(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				ImGuiNative.DebugTextEncoding((byte*)ptext);
			}
		}
		public static void DebugTextEncoding(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				ImGuiNative.DebugTextEncoding((byte*)ptext);
			}
		}
		public static void DebugTextEncoding(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.DebugTextEncoding(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static bool DebugCheckVersionAndDataLayout(byte* versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte ret = ImGuiNative.DebugCheckVersionAndDataLayout(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}
		public static bool DebugCheckVersionAndDataLayout(ref byte versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			fixed (byte* pversionStr = &versionStr)
			{
				byte ret = ImGuiNative.DebugCheckVersionAndDataLayout((byte*)pversionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
				return ret != 0;
			}
		}
		public static bool DebugCheckVersionAndDataLayout(ReadOnlySpan<byte> versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			fixed (byte* pversionStr = versionStr)
			{
				byte ret = ImGuiNative.DebugCheckVersionAndDataLayout((byte*)pversionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
				return ret != 0;
			}
		}
		public static bool DebugCheckVersionAndDataLayout(string versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (versionStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(versionStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(versionStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.DebugCheckVersionAndDataLayout(pStr0, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData)
		{
			ImGuiNative.SetAllocatorFunctions(allocFunc, freeFunc, userData);
		}
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc)
		{
			ImGuiNative.SetAllocatorFunctions(allocFunc, freeFunc, (void*)(default));
		}
		public static void GetAllocatorFunctions(delegate*<nuint, void*, void*>* pAllocFunc, delegate*<void*, void*, void>* pFreeFunc, void** pUserData)
		{
			ImGuiNative.GetAllocatorFunctions(pAllocFunc, pFreeFunc, pUserData);
		}
		public static void* MemAlloc(nuint size)
		{
			void* ret = ImGuiNative.MemAlloc(size);
			return ret;
		}
		public static void MemFree(void* ptr)
		{
			ImGuiNative.MemFree(ptr);
		}
		public static ImGuiPlatformIOPtr GetPlatformIO()
		{
			ImGuiPlatformIOPtr ret = ImGuiNative.GetPlatformIO();
			return ret;
		}
		public static void UpdatePlatformWindows()
		{
			ImGuiNative.UpdatePlatformWindows();
		}
		public static void RenderPlatformWindowsDefault(void* platformRenderArg, void* rendererRenderArg)
		{
			ImGuiNative.RenderPlatformWindowsDefault(platformRenderArg, rendererRenderArg);
		}
		public static void RenderPlatformWindowsDefault(void* platformRenderArg)
		{
			ImGuiNative.RenderPlatformWindowsDefault(platformRenderArg, (void*)(default));
		}
		public static void RenderPlatformWindowsDefault()
		{
			ImGuiNative.RenderPlatformWindowsDefault((void*)(default), (void*)(default));
		}
		public static void DestroyPlatformWindows()
		{
			ImGuiNative.DestroyPlatformWindows();
		}
		public static ImGuiViewportPtr FindViewportByID(uint id)
		{
			ImGuiViewportPtr ret = ImGuiNative.FindViewportByID(id);
			return ret;
		}
		public static ImGuiViewportPtr FindViewportByPlatformHandle(void* platformHandle)
		{
			ImGuiViewportPtr ret = ImGuiNative.FindViewportByPlatformHandle(platformHandle);
			return ret;
		}
		public static ImGuiStylePtr ImGuiStyle()
		{
			ImGuiStylePtr ret = ImGuiNative.ImGuiStyle();
			return ret;
		}
		public static void ScaleAllSizes(ImGuiStylePtr self, float scaleFactor)
		{
			ImGuiNative.ScaleAllSizes(self, scaleFactor);
		}
		public static void ScaleAllSizes(ref ImGuiStyle self, float scaleFactor)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				ImGuiNative.ScaleAllSizes((ImGuiStyle*)pself, scaleFactor);
			}
		}
		public static void AddKeyEvent(ImGuiIOPtr self, ImGuiKey key, bool down)
		{
			ImGuiNative.AddKeyEvent(self, key, down ? (byte)1 : (byte)0);
		}
		public static void AddKeyEvent(ref ImGuiIO self, ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddKeyEvent((ImGuiIO*)pself, key, down ? (byte)1 : (byte)0);
			}
		}
		public static void AddKeyAnalogEvent(ImGuiIOPtr self, ImGuiKey key, bool down, float v)
		{
			ImGuiNative.AddKeyAnalogEvent(self, key, down ? (byte)1 : (byte)0, v);
		}
		public static void AddKeyAnalogEvent(ref ImGuiIO self, ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddKeyAnalogEvent((ImGuiIO*)pself, key, down ? (byte)1 : (byte)0, v);
			}
		}
		public static void AddMousePosEvent(ImGuiIOPtr self, float x, float y)
		{
			ImGuiNative.AddMousePosEvent(self, x, y);
		}
		public static void AddMousePosEvent(ref ImGuiIO self, float x, float y)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddMousePosEvent((ImGuiIO*)pself, x, y);
			}
		}
		public static void AddMouseButtonEvent(ImGuiIOPtr self, int button, bool down)
		{
			ImGuiNative.AddMouseButtonEvent(self, button, down ? (byte)1 : (byte)0);
		}
		public static void AddMouseButtonEvent(ref ImGuiIO self, int button, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddMouseButtonEvent((ImGuiIO*)pself, button, down ? (byte)1 : (byte)0);
			}
		}
		public static void AddMouseWheelEvent(ImGuiIOPtr self, float whX, float whY)
		{
			ImGuiNative.AddMouseWheelEvent(self, whX, whY);
		}
		public static void AddMouseWheelEvent(ref ImGuiIO self, float whX, float whY)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddMouseWheelEvent((ImGuiIO*)pself, whX, whY);
			}
		}
		public static void AddMouseViewportEvent(ImGuiIOPtr self, uint id)
		{
			ImGuiNative.AddMouseViewportEvent(self, id);
		}
		public static void AddMouseViewportEvent(ref ImGuiIO self, uint id)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddMouseViewportEvent((ImGuiIO*)pself, id);
			}
		}
		public static void AddFocusEvent(ImGuiIOPtr self, bool focused)
		{
			ImGuiNative.AddFocusEvent(self, focused ? (byte)1 : (byte)0);
		}
		public static void AddFocusEvent(ref ImGuiIO self, bool focused)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddFocusEvent((ImGuiIO*)pself, focused ? (byte)1 : (byte)0);
			}
		}
		public static void AddInputCharacter(ImGuiIOPtr self, uint c)
		{
			ImGuiNative.AddInputCharacter(self, c);
		}
		public static void AddInputCharacter(ref ImGuiIO self, uint c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddInputCharacter((ImGuiIO*)pself, c);
			}
		}
		public static void AddInputCharacterUTF16(ImGuiIOPtr self, ushort c)
		{
			ImGuiNative.AddInputCharacterUTF16(self, c);
		}
		public static void AddInputCharacterUTF16(ref ImGuiIO self, ushort c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddInputCharacterUTF16((ImGuiIO*)pself, c);
			}
		}
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, byte* str)
		{
			ImGuiNative.AddInputCharactersUTF8(self, str);
		}
		public static void AddInputCharactersUTF8(ref ImGuiIO self, byte* str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.AddInputCharactersUTF8((ImGuiIO*)pself, str);
			}
		}
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImGuiNative.AddInputCharactersUTF8(self, (byte*)pstr);
			}
		}
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				ImGuiNative.AddInputCharactersUTF8(self, (byte*)pstr);
			}
		}
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiNative.AddInputCharactersUTF8(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void AddInputCharactersUTF8(ref ImGuiIO self, ref byte str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					ImGuiNative.AddInputCharactersUTF8((ImGuiIO*)pself, (byte*)pstr);
				}
			}
		}
		public static void AddInputCharactersUTF8(ref ImGuiIO self, ReadOnlySpan<byte> str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					ImGuiNative.AddInputCharactersUTF8((ImGuiIO*)pself, (byte*)pstr);
				}
			}
		}
		public static void AddInputCharactersUTF8(ref ImGuiIO self, string str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiNative.AddInputCharactersUTF8((ImGuiIO*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void SetKeyEventNativeData(ImGuiIOPtr self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			ImGuiNative.SetKeyEventNativeData(self, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
		}
		public static void SetKeyEventNativeData(ImGuiIOPtr self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			ImGuiNative.SetKeyEventNativeData(self, key, nativeKeycode, nativeScancode, (int)(-1));
		}
		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.SetKeyEventNativeData((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}
		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.SetKeyEventNativeData((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, (int)(-1));
			}
		}
		public static void SetAppAcceptingEvents(ImGuiIOPtr self, bool acceptingEvents)
		{
			ImGuiNative.SetAppAcceptingEvents(self, acceptingEvents ? (byte)1 : (byte)0);
		}
		public static void SetAppAcceptingEvents(ref ImGuiIO self, bool acceptingEvents)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.SetAppAcceptingEvents((ImGuiIO*)pself, acceptingEvents ? (byte)1 : (byte)0);
			}
		}
		public static void ClearInputCharacters(ImGuiIOPtr self)
		{
			ImGuiNative.ClearInputCharacters(self);
		}
		public static void ClearInputCharacters(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.ClearInputCharacters((ImGuiIO*)pself);
			}
		}
		public static void ClearInputKeys(ImGuiIOPtr self)
		{
			ImGuiNative.ClearInputKeys(self);
		}
		public static void ClearInputKeys(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ImGuiNative.ClearInputKeys((ImGuiIO*)pself);
			}
		}
		public static ImGuiIOPtr ImGuiIO()
		{
			ImGuiIOPtr ret = ImGuiNative.ImGuiIO();
			return ret;
		}
		public static ImGuiInputTextCallbackDataPtr ImGuiInputTextCallbackData()
		{
			ImGuiInputTextCallbackDataPtr ret = ImGuiNative.ImGuiInputTextCallbackData();
			return ret;
		}
		public static void DeleteChars(ImGuiInputTextCallbackDataPtr self, int pos, int bytesCount)
		{
			ImGuiNative.DeleteChars(self, pos, bytesCount);
		}
		public static void DeleteChars(ref ImGuiInputTextCallbackData self, int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				ImGuiNative.DeleteChars((ImGuiInputTextCallbackData*)pself, pos, bytesCount);
			}
		}
		public static void SelectAll(ImGuiInputTextCallbackDataPtr self)
		{
			ImGuiNative.SelectAll(self);
		}
		public static void SelectAll(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				ImGuiNative.SelectAll((ImGuiInputTextCallbackData*)pself);
			}
		}
		public static void ClearSelection(ImGuiInputTextCallbackDataPtr self)
		{
			ImGuiNative.ClearSelection(self);
		}
		public static void ClearSelection(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				ImGuiNative.ClearSelection((ImGuiInputTextCallbackData*)pself);
			}
		}
		public static bool HasSelection(ImGuiInputTextCallbackDataPtr self)
		{
			byte ret = ImGuiNative.HasSelection(self);
			return ret != 0;
		}
		public static bool HasSelection(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte ret = ImGuiNative.HasSelection((ImGuiInputTextCallbackData*)pself);
				return ret != 0;
			}
		}
		public static ImGuiWindowClassPtr ImGuiWindowClass()
		{
			ImGuiWindowClassPtr ret = ImGuiNative.ImGuiWindowClass();
			return ret;
		}
		public static ImGuiPayloadPtr ImGuiPayload()
		{
			ImGuiPayloadPtr ret = ImGuiNative.ImGuiPayload();
			return ret;
		}
		public static void Clear(ImGuiPayloadPtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				ImGuiNative.Clear((ImGuiPayload*)pself);
			}
		}
		public static void Clear(ImGuiTextFilterPtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				ImGuiNative.Clear((ImGuiTextFilter*)pself);
			}
		}
		public static void Clear(ImGuiStoragePtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImGuiStorage self)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.Clear((ImGuiStorage*)pself);
			}
		}
		public static void Clear(ImDrawListSplitterPtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ImGuiNative.Clear((ImDrawListSplitter*)pself);
			}
		}
		public static void Clear(ImDrawDataPtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				ImGuiNative.Clear((ImDrawData*)pself);
			}
		}
		public static void Clear(ImFontGlyphRangesBuilderPtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImFontGlyphRangesBuilder self)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ImGuiNative.Clear((ImFontGlyphRangesBuilder*)pself);
			}
		}
		public static void Clear(ImFontAtlasPtr self)
		{
			ImGuiNative.Clear(self);
		}
		public static void Clear(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.Clear((ImFontAtlas*)pself);
			}
		}
		public static bool IsDataType(ImGuiPayloadPtr self, byte* type)
		{
			byte ret = ImGuiNative.IsDataType(self, type);
			return ret != 0;
		}
		public static bool IsDataType(ref ImGuiPayload self, byte* type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte ret = ImGuiNative.IsDataType((ImGuiPayload*)pself, type);
				return ret != 0;
			}
		}
		public static bool IsDataType(ImGuiPayloadPtr self, ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = ImGuiNative.IsDataType(self, (byte*)ptype);
				return ret != 0;
			}
		}
		public static bool IsDataType(ImGuiPayloadPtr self, ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				byte ret = ImGuiNative.IsDataType(self, (byte*)ptype);
				return ret != 0;
			}
		}
		public static bool IsDataType(ImGuiPayloadPtr self, string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.IsDataType(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool IsDataType(ref ImGuiPayload self, ref byte type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				fixed (byte* ptype = &type)
				{
					byte ret = ImGuiNative.IsDataType((ImGuiPayload*)pself, (byte*)ptype);
					return ret != 0;
				}
			}
		}
		public static bool IsDataType(ref ImGuiPayload self, ReadOnlySpan<byte> type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				fixed (byte* ptype = type)
				{
					byte ret = ImGuiNative.IsDataType((ImGuiPayload*)pself, (byte*)ptype);
					return ret != 0;
				}
			}
		}
		public static bool IsDataType(ref ImGuiPayload self, string type)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.IsDataType((ImGuiPayload*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool IsPreview(ImGuiPayloadPtr self)
		{
			byte ret = ImGuiNative.IsPreview(self);
			return ret != 0;
		}
		public static bool IsPreview(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte ret = ImGuiNative.IsPreview((ImGuiPayload*)pself);
				return ret != 0;
			}
		}
		public static bool IsDelivery(ImGuiPayloadPtr self)
		{
			byte ret = ImGuiNative.IsDelivery(self);
			return ret != 0;
		}
		public static bool IsDelivery(ref ImGuiPayload self)
		{
			fixed (ImGuiPayload* pself = &self)
			{
				byte ret = ImGuiNative.IsDelivery((ImGuiPayload*)pself);
				return ret != 0;
			}
		}
		public static ImGuiTableColumnSortSpecsPtr ImGuiTableColumnSortSpecs()
		{
			ImGuiTableColumnSortSpecsPtr ret = ImGuiNative.ImGuiTableColumnSortSpecs();
			return ret;
		}
		public static ImGuiTableSortSpecsPtr ImGuiTableSortSpecs()
		{
			ImGuiTableSortSpecsPtr ret = ImGuiNative.ImGuiTableSortSpecs();
			return ret;
		}
		public static ImGuiOnceUponAFramePtr ImGuiOnceUponAFrame()
		{
			ImGuiOnceUponAFramePtr ret = ImGuiNative.ImGuiOnceUponAFrame();
			return ret;
		}
		public static ImGuiTextFilterPtr ImGuiTextFilter(byte* defaultFilter)
		{
			ImGuiTextFilterPtr ret = ImGuiNative.ImGuiTextFilter(defaultFilter);
			return ret;
		}
		public static ImGuiTextFilterPtr ImGuiTextFilter()
		{
			ImGuiTextFilterPtr ret = ImGuiTextFilter((string)"");
			return ret;
		}
		public static ImGuiTextFilterPtr ImGuiTextFilter(ref byte defaultFilter)
		{
			fixed (byte* pdefaultFilter = &defaultFilter)
			{
				ImGuiTextFilterPtr ret = ImGuiNative.ImGuiTextFilter((byte*)pdefaultFilter);
				return ret;
			}
		}
		public static ImGuiTextFilterPtr ImGuiTextFilter(ReadOnlySpan<byte> defaultFilter)
		{
			fixed (byte* pdefaultFilter = defaultFilter)
			{
				ImGuiTextFilterPtr ret = ImGuiNative.ImGuiTextFilter((byte*)pdefaultFilter);
				return ret;
			}
		}
		public static ImGuiTextFilterPtr ImGuiTextFilter(string defaultFilter)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (defaultFilter != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(defaultFilter);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(defaultFilter, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextFilterPtr ret = ImGuiNative.ImGuiTextFilter(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static bool Draw(ImGuiTextFilterPtr self, byte* label, float width)
		{
			byte ret = ImGuiNative.Draw(self, label, width);
			return ret != 0;
		}
		public static bool Draw(ImGuiTextFilterPtr self, byte* label)
		{
			byte ret = ImGuiNative.Draw(self, label, (float)(0.0f));
			return ret != 0;
		}
		public static bool Draw(ImGuiTextFilterPtr self)
		{
			bool ret = Draw(self, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}
		public static bool Draw(ImGuiTextFilterPtr self, float width)
		{
			bool ret = Draw(self, (string)"Filter(inc,-exc)", width);
			return ret;
		}
		public static bool Draw(ref ImGuiTextFilter self, byte* label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, label, width);
				return ret != 0;
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, byte* label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, label, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool Draw(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = Draw((ImGuiTextFilter*)pself, (string)"Filter(inc,-exc)", (float)(0.0f));
				return ret;
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				bool ret = Draw((ImGuiTextFilter*)pself, (string)"Filter(inc,-exc)", width);
				return ret;
			}
		}
		public static bool Draw(ImGuiTextFilterPtr self, ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Draw(self, (byte*)plabel, width);
				return ret != 0;
			}
		}
		public static bool Draw(ImGuiTextFilterPtr self, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Draw(self, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool Draw(ImGuiTextFilterPtr self, ReadOnlySpan<byte> label, float width)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Draw(self, (byte*)plabel, width);
				return ret != 0;
			}
		}
		public static bool Draw(ImGuiTextFilterPtr self, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Draw(self, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool Draw(ImGuiTextFilterPtr self, string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Draw(self, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Draw(ImGuiTextFilterPtr self, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Draw(self, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool Draw(ref ImGuiTextFilter self, ref byte label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, ref byte label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, ReadOnlySpan<byte> label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = label)
				{
					byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				fixed (byte* plabel = label)
				{
					byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, string label, float width)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool Draw(ref ImGuiTextFilter self, string label)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiNative.Draw((ImGuiTextFilter*)pself, pStr0, (float)(0.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static void Build(ImGuiTextFilterPtr self)
		{
			ImGuiNative.Build(self);
		}
		public static void Build(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				ImGuiNative.Build((ImGuiTextFilter*)pself);
			}
		}
		public static bool Build(ImFontAtlasPtr self)
		{
			byte ret = ImGuiNative.Build(self);
			return ret != 0;
		}
		public static bool Build(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte ret = ImGuiNative.Build((ImFontAtlas*)pself);
				return ret != 0;
			}
		}
		public static bool IsActive(ImGuiTextFilterPtr self)
		{
			byte ret = ImGuiNative.IsActive(self);
			return ret != 0;
		}
		public static bool IsActive(ref ImGuiTextFilter self)
		{
			fixed (ImGuiTextFilter* pself = &self)
			{
				byte ret = ImGuiNative.IsActive((ImGuiTextFilter*)pself);
				return ret != 0;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange()
		{
			ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange();
			return ret;
		}
		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, byte* e)
		{
			ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(b, e);
			return ret;
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ref byte b, byte* e)
		{
			fixed (byte* pb = &b)
			{
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, e);
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ReadOnlySpan<byte> b, byte* e)
		{
			fixed (byte* pb = b)
			{
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, e);
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(string b, byte* e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(pStr0, e);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, ref byte e)
		{
			fixed (byte* pe = &e)
			{
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(b, (byte*)pe);
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, ReadOnlySpan<byte> e)
		{
			fixed (byte* pe = e)
			{
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(b, (byte*)pe);
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(byte* b, string e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (e != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(e);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(e, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(b, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ref byte b, ref byte e)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pe = &e)
				{
					ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, (byte*)pe);
					return ret;
				}
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ReadOnlySpan<byte> b, ReadOnlySpan<byte> e)
		{
			fixed (byte* pb = b)
			{
				fixed (byte* pe = e)
				{
					ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, (byte*)pe);
					return ret;
				}
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(string b, string e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (e != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(e);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(e, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ref byte b, ReadOnlySpan<byte> e)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pe = e)
				{
					ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, (byte*)pe);
					return ret;
				}
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ref byte b, string e)
		{
			fixed (byte* pb = &b)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (e != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(e);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(e, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ReadOnlySpan<byte> b, ref byte e)
		{
			fixed (byte* pb = b)
			{
				fixed (byte* pe = &e)
				{
					ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, (byte*)pe);
					return ret;
				}
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(ReadOnlySpan<byte> b, string e)
		{
			fixed (byte* pb = b)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (e != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(e);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(e, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange((byte*)pb, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(string b, ref byte e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pe = &e)
			{
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(pStr0, (byte*)pe);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static ImGuiTextRangePtr ImGuiTextRange(string b, ReadOnlySpan<byte> e)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (b != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(b);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(b, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pe = e)
			{
				ImGuiTextRangePtr ret = ImGuiNative.ImGuiTextRange(pStr0, (byte*)pe);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static bool empty(ImGuiTextRangePtr self)
		{
			byte ret = ImGuiNative.empty(self);
			return ret != 0;
		}
		public static bool empty(ref ImGuiTextRange self)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				byte ret = ImGuiNative.empty((ImGuiTextRange*)pself);
				return ret != 0;
			}
		}
		public static bool empty(ImGuiTextBufferPtr self)
		{
			byte ret = ImGuiNative.empty(self);
			return ret != 0;
		}
		public static bool empty(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte ret = ImGuiNative.empty((ImGuiTextBuffer*)pself);
				return ret != 0;
			}
		}
		public static void split(ImGuiTextRangePtr self, byte separator, ImVector<ImGuiTextRange>* output)
		{
			ImGuiNative.split(self, separator, output);
		}
		public static void split(ref ImGuiTextRange self, byte separator, ImVector<ImGuiTextRange>* output)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				ImGuiNative.split((ImGuiTextRange*)pself, separator, output);
			}
		}
		public static void split(ImGuiTextRangePtr self, byte separator, ref ImVector<ImGuiTextRange> output)
		{
			fixed (ImVector<ImGuiTextRange>* poutput = &output)
			{
				ImGuiNative.split(self, separator, (ImVector<ImGuiTextRange>*)poutput);
			}
		}
		public static void split(ref ImGuiTextRange self, byte separator, ref ImVector<ImGuiTextRange> output)
		{
			fixed (ImGuiTextRange* pself = &self)
			{
				fixed (ImVector<ImGuiTextRange>* poutput = &output)
				{
					ImGuiNative.split((ImGuiTextRange*)pself, separator, (ImVector<ImGuiTextRange>*)poutput);
				}
			}
		}
		public static ImGuiTextBufferPtr ImGuiTextBuffer()
		{
			ImGuiTextBufferPtr ret = ImGuiNative.ImGuiTextBuffer();
			return ret;
		}
		public static byte* begin(ImGuiTextBufferPtr self)
		{
			byte* ret = ImGuiNative.begin(self);
			return ret;
		}
		public static byte* begin(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = ImGuiNative.begin((ImGuiTextBuffer*)pself);
				return ret;
			}
		}
		public static string beginS(ImGuiTextBufferPtr self)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.begin(self));
			return ret;
		}
		public static string beginS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiNative.begin((ImGuiTextBuffer*)pself));
				return ret;
			}
		}
		public static byte* end(ImGuiTextBufferPtr self)
		{
			byte* ret = ImGuiNative.end(self);
			return ret;
		}
		public static byte* end(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = ImGuiNative.end((ImGuiTextBuffer*)pself);
				return ret;
			}
		}
		public static string endS(ImGuiTextBufferPtr self)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.end(self));
			return ret;
		}
		public static string endS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiNative.end((ImGuiTextBuffer*)pself));
				return ret;
			}
		}
		public static int size(ImGuiTextBufferPtr self)
		{
			int ret = ImGuiNative.size(self);
			return ret;
		}
		public static int size(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				int ret = ImGuiNative.size((ImGuiTextBuffer*)pself);
				return ret;
			}
		}
		public static void clear(ImGuiTextBufferPtr self)
		{
			ImGuiNative.clear(self);
		}
		public static void clear(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				ImGuiNative.clear((ImGuiTextBuffer*)pself);
			}
		}
		public static void reserve(ImGuiTextBufferPtr self, int capacity)
		{
			ImGuiNative.reserve(self, capacity);
		}
		public static void reserve(ref ImGuiTextBuffer self, int capacity)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				ImGuiNative.reserve((ImGuiTextBuffer*)pself, capacity);
			}
		}
		public static byte* c_str(ImGuiTextBufferPtr self)
		{
			byte* ret = ImGuiNative.c_str(self);
			return ret;
		}
		public static byte* c_str(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				byte* ret = ImGuiNative.c_str((ImGuiTextBuffer*)pself);
				return ret;
			}
		}
		public static string c_strS(ImGuiTextBufferPtr self)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.c_str(self));
			return ret;
		}
		public static string c_strS(ref ImGuiTextBuffer self)
		{
			fixed (ImGuiTextBuffer* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiNative.c_str((ImGuiTextBuffer*)pself));
				return ret;
			}
		}
		public static ImGuiStoragePairPtr ImGuiStoragePair(uint key, int valI)
		{
			ImGuiStoragePairPtr ret = ImGuiNative.ImGuiStoragePair(key, valI);
			return ret;
		}
		public static ImGuiStoragePairPtr ImGuiStoragePair(uint key, float valF)
		{
			ImGuiStoragePairPtr ret = ImGuiNative.ImGuiStoragePair(key, valF);
			return ret;
		}
		public static ImGuiStoragePairPtr ImGuiStoragePair(uint key, void* valP)
		{
			ImGuiStoragePairPtr ret = ImGuiNative.ImGuiStoragePair(key, valP);
			return ret;
		}
		public static int GetInt(ImGuiStoragePtr self, uint key, int defaultVal)
		{
			int ret = ImGuiNative.GetInt(self, key, defaultVal);
			return ret;
		}
		public static int GetInt(ImGuiStoragePtr self, uint key)
		{
			int ret = ImGuiNative.GetInt(self, key, (int)(0));
			return ret;
		}
		public static int GetInt(ref ImGuiStorage self, uint key, int defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int ret = ImGuiNative.GetInt((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}
		public static int GetInt(ref ImGuiStorage self, uint key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				int ret = ImGuiNative.GetInt((ImGuiStorage*)pself, key, (int)(0));
				return ret;
			}
		}
		public static void SetInt(ImGuiStoragePtr self, uint key, int val)
		{
			ImGuiNative.SetInt(self, key, val);
		}
		public static void SetInt(ref ImGuiStorage self, uint key, int val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.SetInt((ImGuiStorage*)pself, key, val);
			}
		}
		public static bool GetBool(ImGuiStoragePtr self, uint key, bool defaultVal)
		{
			byte ret = ImGuiNative.GetBool(self, key, defaultVal ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool GetBool(ImGuiStoragePtr self, uint key)
		{
			byte ret = ImGuiNative.GetBool(self, key, (byte)(0));
			return ret != 0;
		}
		public static bool GetBool(ref ImGuiStorage self, uint key, bool defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				byte ret = ImGuiNative.GetBool((ImGuiStorage*)pself, key, defaultVal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool GetBool(ref ImGuiStorage self, uint key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				byte ret = ImGuiNative.GetBool((ImGuiStorage*)pself, key, (byte)(0));
				return ret != 0;
			}
		}
		public static void SetBool(ImGuiStoragePtr self, uint key, bool val)
		{
			ImGuiNative.SetBool(self, key, val ? (byte)1 : (byte)0);
		}
		public static void SetBool(ref ImGuiStorage self, uint key, bool val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.SetBool((ImGuiStorage*)pself, key, val ? (byte)1 : (byte)0);
			}
		}
		public static float GetFloat(ImGuiStoragePtr self, uint key, float defaultVal)
		{
			float ret = ImGuiNative.GetFloat(self, key, defaultVal);
			return ret;
		}
		public static float GetFloat(ImGuiStoragePtr self, uint key)
		{
			float ret = ImGuiNative.GetFloat(self, key, (float)(0.0f));
			return ret;
		}
		public static float GetFloat(ref ImGuiStorage self, uint key, float defaultVal)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float ret = ImGuiNative.GetFloat((ImGuiStorage*)pself, key, defaultVal);
				return ret;
			}
		}
		public static float GetFloat(ref ImGuiStorage self, uint key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				float ret = ImGuiNative.GetFloat((ImGuiStorage*)pself, key, (float)(0.0f));
				return ret;
			}
		}
		public static void SetFloat(ImGuiStoragePtr self, uint key, float val)
		{
			ImGuiNative.SetFloat(self, key, val);
		}
		public static void SetFloat(ref ImGuiStorage self, uint key, float val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.SetFloat((ImGuiStorage*)pself, key, val);
			}
		}
		public static void* GetVoidPtr(ImGuiStoragePtr self, uint key)
		{
			void* ret = ImGuiNative.GetVoidPtr(self, key);
			return ret;
		}
		public static void* GetVoidPtr(ref ImGuiStorage self, uint key)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				void* ret = ImGuiNative.GetVoidPtr((ImGuiStorage*)pself, key);
				return ret;
			}
		}
		public static void SetVoidPtr(ImGuiStoragePtr self, uint key, void* val)
		{
			ImGuiNative.SetVoidPtr(self, key, val);
		}
		public static void SetVoidPtr(ref ImGuiStorage self, uint key, void* val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.SetVoidPtr((ImGuiStorage*)pself, key, val);
			}
		}
		public static void SetAllInt(ImGuiStoragePtr self, int val)
		{
			ImGuiNative.SetAllInt(self, val);
		}
		public static void SetAllInt(ref ImGuiStorage self, int val)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.SetAllInt((ImGuiStorage*)pself, val);
			}
		}
		public static void BuildSortByKey(ImGuiStoragePtr self)
		{
			ImGuiNative.BuildSortByKey(self);
		}
		public static void BuildSortByKey(ref ImGuiStorage self)
		{
			fixed (ImGuiStorage* pself = &self)
			{
				ImGuiNative.BuildSortByKey((ImGuiStorage*)pself);
			}
		}
		public static ImGuiListClipperPtr ImGuiListClipper()
		{
			ImGuiListClipperPtr ret = ImGuiNative.ImGuiListClipper();
			return ret;
		}
		public static bool Step(ImGuiListClipperPtr self)
		{
			byte ret = ImGuiNative.Step(self);
			return ret != 0;
		}
		public static bool Step(ref ImGuiListClipper self)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				byte ret = ImGuiNative.Step((ImGuiListClipper*)pself);
				return ret != 0;
			}
		}
		public static void ForceDisplayRangeByIndices(ImGuiListClipperPtr self, int itemMin, int itemMax)
		{
			ImGuiNative.ForceDisplayRangeByIndices(self, itemMin, itemMax);
		}
		public static void ForceDisplayRangeByIndices(ref ImGuiListClipper self, int itemMin, int itemMax)
		{
			fixed (ImGuiListClipper* pself = &self)
			{
				ImGuiNative.ForceDisplayRangeByIndices((ImGuiListClipper*)pself, itemMin, itemMax);
			}
		}
		public static ImColorPtr ImColor()
		{
			ImColorPtr ret = ImGuiNative.ImColor();
			return ret;
		}
		public static ImColorPtr ImColor(float r, float g, float b, float a)
		{
			ImColorPtr ret = ImGuiNative.ImColor(r, g, b, a);
			return ret;
		}
		public static ImColorPtr ImColor(float r, float g, float b)
		{
			ImColorPtr ret = ImGuiNative.ImColor(r, g, b, (float)(1.0f));
			return ret;
		}
		public static ImColorPtr ImColor(Vector4 col)
		{
			ImColorPtr ret = ImGuiNative.ImColor(col);
			return ret;
		}
		public static ImColorPtr ImColor(int r, int g, int b, int a)
		{
			ImColorPtr ret = ImGuiNative.ImColor(r, g, b, a);
			return ret;
		}
		public static ImColorPtr ImColor(int r, int g, int b)
		{
			ImColorPtr ret = ImGuiNative.ImColor(r, g, b, (int)(255));
			return ret;
		}
		public static ImColorPtr ImColor(uint rgba)
		{
			ImColorPtr ret = ImGuiNative.ImColor(rgba);
			return ret;
		}
		public static void SetHSV(ImColorPtr self, float h, float s, float v, float a)
		{
			ImGuiNative.SetHSV(self, h, s, v, a);
		}
		public static void SetHSV(ImColorPtr self, float h, float s, float v)
		{
			ImGuiNative.SetHSV(self, h, s, v, (float)(1.0f));
		}
		public static void SetHSV(ref ImColor self, float h, float s, float v, float a)
		{
			fixed (ImColor* pself = &self)
			{
				ImGuiNative.SetHSV((ImColor*)pself, h, s, v, a);
			}
		}
		public static void SetHSV(ref ImColor self, float h, float s, float v)
		{
			fixed (ImColor* pself = &self)
			{
				ImGuiNative.SetHSV((ImColor*)pself, h, s, v, (float)(1.0f));
			}
		}
		public static ImColor HSV(float h, float s, float v)
		{
			ImColor ret;
			ImGuiNative.HSV(&ret, h, s, v, (float)(1.0f));
			return ret;
		}
		public static ImColor HSV(float h, float s, float v, float a)
		{
			ImColor ret;
			ImGuiNative.HSV(&ret, h, s, v, a);
			return ret;
		}
		public static void HSV(ImColorPtr pOut, float h, float s, float v, float a)
		{
			ImGuiNative.HSV(pOut, h, s, v, a);
		}
		public static void HSV(ImColorPtr pOut, float h, float s, float v)
		{
			ImGuiNative.HSV(pOut, h, s, v, (float)(1.0f));
		}
		public static void HSV(ref ImColor pOut, float h, float s, float v, float a)
		{
			fixed (ImColor* ppOut = &pOut)
			{
				ImGuiNative.HSV((ImColor*)ppOut, h, s, v, a);
			}
		}
		public static void HSV(ref ImColor pOut, float h, float s, float v)
		{
			fixed (ImColor* ppOut = &pOut)
			{
				ImGuiNative.HSV((ImColor*)ppOut, h, s, v, (float)(1.0f));
			}
		}
		public static ImDrawCmdPtr ImDrawCmd()
		{
			ImDrawCmdPtr ret = ImGuiNative.ImDrawCmd();
			return ret;
		}
		public static ImTextureID GetTexID(ImDrawCmdPtr self)
		{
			ImTextureID ret = ImGuiNative.GetTexID(self);
			return ret;
		}
		public static ImTextureID GetTexID(ref ImDrawCmd self)
		{
			fixed (ImDrawCmd* pself = &self)
			{
				ImTextureID ret = ImGuiNative.GetTexID((ImDrawCmd*)pself);
				return ret;
			}
		}
		public static ImDrawListSplitterPtr ImDrawListSplitter()
		{
			ImDrawListSplitterPtr ret = ImGuiNative.ImDrawListSplitter();
			return ret;
		}
		public static void ClearFreeMemory(ImDrawListSplitterPtr self)
		{
			ImGuiNative.ClearFreeMemory(self);
		}
		public static void ClearFreeMemory(ref ImDrawListSplitter self)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ImGuiNative.ClearFreeMemory((ImDrawListSplitter*)pself);
			}
		}
		public static void Split(ImDrawListSplitterPtr self, ImDrawListPtr drawList, int count)
		{
			ImGuiNative.Split(self, drawList, count);
		}
		public static void Split(ref ImDrawListSplitter self, ImDrawListPtr drawList, int count)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ImGuiNative.Split((ImDrawListSplitter*)pself, drawList, count);
			}
		}
		public static void Split(ImDrawListSplitterPtr self, ref ImDrawList drawList, int count)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiNative.Split(self, (ImDrawList*)pdrawList, count);
			}
		}
		public static void Split(ref ImDrawListSplitter self, ref ImDrawList drawList, int count)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiNative.Split((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList, count);
				}
			}
		}
		public static void Merge(ImDrawListSplitterPtr self, ImDrawListPtr drawList)
		{
			ImGuiNative.Merge(self, drawList);
		}
		public static void Merge(ref ImDrawListSplitter self, ImDrawListPtr drawList)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ImGuiNative.Merge((ImDrawListSplitter*)pself, drawList);
			}
		}
		public static void Merge(ImDrawListSplitterPtr self, ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiNative.Merge(self, (ImDrawList*)pdrawList);
			}
		}
		public static void Merge(ref ImDrawListSplitter self, ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiNative.Merge((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList);
				}
			}
		}
		public static void SetCurrentChannel(ImDrawListSplitterPtr self, ImDrawListPtr drawList, int channelIdx)
		{
			ImGuiNative.SetCurrentChannel(self, drawList, channelIdx);
		}
		public static void SetCurrentChannel(ref ImDrawListSplitter self, ImDrawListPtr drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				ImGuiNative.SetCurrentChannel((ImDrawListSplitter*)pself, drawList, channelIdx);
			}
		}
		public static void SetCurrentChannel(ImDrawListSplitterPtr self, ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiNative.SetCurrentChannel(self, (ImDrawList*)pdrawList, channelIdx);
			}
		}
		public static void SetCurrentChannel(ref ImDrawListSplitter self, ref ImDrawList drawList, int channelIdx)
		{
			fixed (ImDrawListSplitter* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiNative.SetCurrentChannel((ImDrawListSplitter*)pself, (ImDrawList*)pdrawList, channelIdx);
				}
			}
		}
		public static ImDrawListPtr ImDrawList(ImDrawListSharedDataPtr sharedData)
		{
			ImDrawListPtr ret = ImGuiNative.ImDrawList(sharedData);
			return ret;
		}
		public static ImDrawListPtr ImDrawList(ref ImDrawListSharedData sharedData)
		{
			fixed (ImDrawListSharedData* psharedData = &sharedData)
			{
				ImDrawListPtr ret = ImGuiNative.ImDrawList((ImDrawListSharedData*)psharedData);
				return ret;
			}
		}
		public static void PushClipRectFullScreen(ImDrawListPtr self)
		{
			ImGuiNative.PushClipRectFullScreen(self);
		}
		public static void PushClipRectFullScreen(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PushClipRectFullScreen((ImDrawList*)pself);
			}
		}
		public static void PushTextureID(ImDrawListPtr self, ImTextureID textureId)
		{
			ImGuiNative.PushTextureID(self, textureId);
		}
		public static void PushTextureID(ref ImDrawList self, ImTextureID textureId)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PushTextureID((ImDrawList*)pself, textureId);
			}
		}
		public static void PopTextureID(ImDrawListPtr self)
		{
			ImGuiNative.PopTextureID(self);
		}
		public static void PopTextureID(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PopTextureID((ImDrawList*)pself);
			}
		}
		public static Vector2 GetClipRectMin(ImDrawListPtr self)
		{
			Vector2 ret;
			ImGuiNative.GetClipRectMin(&ret, self);
			return ret;
		}
		public static void GetClipRectMin(Vector2* pOut, ImDrawListPtr self)
		{
			ImGuiNative.GetClipRectMin(pOut, self);
		}
		public static void GetClipRectMin(ref Vector2 pOut, ImDrawListPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetClipRectMin((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetClipRectMin(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				Vector2 ret;
				ImGuiNative.GetClipRectMin(&ret, (ImDrawList*)pself);
				return ret;
			}
		}
		public static void GetClipRectMin(Vector2* pOut, ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.GetClipRectMin(pOut, (ImDrawList*)pself);
			}
		}
		public static void GetClipRectMin(ref Vector2 pOut, ref ImDrawList self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImDrawList* pself = &self)
				{
					ImGuiNative.GetClipRectMin((Vector2*)ppOut, (ImDrawList*)pself);
				}
			}
		}
		public static Vector2 GetClipRectMax(ImDrawListPtr self)
		{
			Vector2 ret;
			ImGuiNative.GetClipRectMax(&ret, self);
			return ret;
		}
		public static void GetClipRectMax(Vector2* pOut, ImDrawListPtr self)
		{
			ImGuiNative.GetClipRectMax(pOut, self);
		}
		public static void GetClipRectMax(ref Vector2 pOut, ImDrawListPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetClipRectMax((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetClipRectMax(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				Vector2 ret;
				ImGuiNative.GetClipRectMax(&ret, (ImDrawList*)pself);
				return ret;
			}
		}
		public static void GetClipRectMax(Vector2* pOut, ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.GetClipRectMax(pOut, (ImDrawList*)pself);
			}
		}
		public static void GetClipRectMax(ref Vector2 pOut, ref ImDrawList self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImDrawList* pself = &self)
				{
					ImGuiNative.GetClipRectMax((Vector2*)ppOut, (ImDrawList*)pself);
				}
			}
		}
		public static void AddLine(ImDrawListPtr self, Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			ImGuiNative.AddLine(self, p1, p2, col, thickness);
		}
		public static void AddLine(ImDrawListPtr self, Vector2 p1, Vector2 p2, uint col)
		{
			ImGuiNative.AddLine(self, p1, p2, col, (float)(1.0f));
		}
		public static void AddLine(ref ImDrawList self, Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddLine((ImDrawList*)pself, p1, p2, col, thickness);
			}
		}
		public static void AddLine(ref ImDrawList self, Vector2 p1, Vector2 p2, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddLine((ImDrawList*)pself, p1, p2, col, (float)(1.0f));
			}
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, rounding, flags, thickness);
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, rounding, flags, (float)(1.0f));
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
		}
		public static void AddRect(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			ImGuiNative.AddRect(self, pMin, pMax, col, (float)(0.0f), flags, thickness);
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, flags, thickness);
			}
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
			}
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
			}
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
			}
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
			}
		}
		public static void AddRect(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRect((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), flags, thickness);
			}
		}
		public static void AddRectFilled(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGuiNative.AddRectFilled(self, pMin, pMax, col, rounding, flags);
		}
		public static void AddRectFilled(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGuiNative.AddRectFilled(self, pMin, pMax, col, rounding, (ImDrawFlags)(0));
		}
		public static void AddRectFilled(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGuiNative.AddRectFilled(self, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
		}
		public static void AddRectFilled(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGuiNative.AddRectFilled(self, pMin, pMax, col, (float)(0.0f), flags);
		}
		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRectFilled((ImDrawList*)pself, pMin, pMax, col, rounding, flags);
			}
		}
		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRectFilled((ImDrawList*)pself, pMin, pMax, col, rounding, (ImDrawFlags)(0));
			}
		}
		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRectFilled((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
			}
		}
		public static void AddRectFilled(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRectFilled((ImDrawList*)pself, pMin, pMax, col, (float)(0.0f), flags);
			}
		}
		public static void AddRectFilledMultiColor(ImDrawListPtr self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			ImGuiNative.AddRectFilledMultiColor(self, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
		}
		public static void AddRectFilledMultiColor(ref ImDrawList self, Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddRectFilledMultiColor((ImDrawList*)pself, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}
		public static void AddQuad(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGuiNative.AddQuad(self, p1, p2, p3, p4, col, thickness);
		}
		public static void AddQuad(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGuiNative.AddQuad(self, p1, p2, p3, p4, col, (float)(1.0f));
		}
		public static void AddQuad(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddQuad((ImDrawList*)pself, p1, p2, p3, p4, col, thickness);
			}
		}
		public static void AddQuad(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddQuad((ImDrawList*)pself, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}
		public static void AddQuadFilled(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGuiNative.AddQuadFilled(self, p1, p2, p3, p4, col);
		}
		public static void AddQuadFilled(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddQuadFilled((ImDrawList*)pself, p1, p2, p3, p4, col);
			}
		}
		public static void AddTriangle(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGuiNative.AddTriangle(self, p1, p2, p3, col, thickness);
		}
		public static void AddTriangle(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGuiNative.AddTriangle(self, p1, p2, p3, col, (float)(1.0f));
		}
		public static void AddTriangle(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddTriangle((ImDrawList*)pself, p1, p2, p3, col, thickness);
			}
		}
		public static void AddTriangle(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddTriangle((ImDrawList*)pself, p1, p2, p3, col, (float)(1.0f));
			}
		}
		public static void AddTriangleFilled(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGuiNative.AddTriangleFilled(self, p1, p2, p3, col);
		}
		public static void AddTriangleFilled(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddTriangleFilled((ImDrawList*)pself, p1, p2, p3, col);
			}
		}
		public static void AddCircle(ImDrawListPtr self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGuiNative.AddCircle(self, center, radius, col, numSegments, thickness);
		}
		public static void AddCircle(ImDrawListPtr self, Vector2 center, float radius, uint col, int numSegments)
		{
			ImGuiNative.AddCircle(self, center, radius, col, numSegments, (float)(1.0f));
		}
		public static void AddCircle(ImDrawListPtr self, Vector2 center, float radius, uint col)
		{
			ImGuiNative.AddCircle(self, center, radius, col, (int)(0), (float)(1.0f));
		}
		public static void AddCircle(ImDrawListPtr self, Vector2 center, float radius, uint col, float thickness)
		{
			ImGuiNative.AddCircle(self, center, radius, col, (int)(0), thickness);
		}
		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCircle((ImDrawList*)pself, center, radius, col, numSegments, thickness);
			}
		}
		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCircle((ImDrawList*)pself, center, radius, col, numSegments, (float)(1.0f));
			}
		}
		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCircle((ImDrawList*)pself, center, radius, col, (int)(0), (float)(1.0f));
			}
		}
		public static void AddCircle(ref ImDrawList self, Vector2 center, float radius, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCircle((ImDrawList*)pself, center, radius, col, (int)(0), thickness);
			}
		}
		public static void AddCircleFilled(ImDrawListPtr self, Vector2 center, float radius, uint col, int numSegments)
		{
			ImGuiNative.AddCircleFilled(self, center, radius, col, numSegments);
		}
		public static void AddCircleFilled(ImDrawListPtr self, Vector2 center, float radius, uint col)
		{
			ImGuiNative.AddCircleFilled(self, center, radius, col, (int)(0));
		}
		public static void AddCircleFilled(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCircleFilled((ImDrawList*)pself, center, radius, col, numSegments);
			}
		}
		public static void AddCircleFilled(ref ImDrawList self, Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCircleFilled((ImDrawList*)pself, center, radius, col, (int)(0));
			}
		}
		public static void AddNgon(ImDrawListPtr self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGuiNative.AddNgon(self, center, radius, col, numSegments, thickness);
		}
		public static void AddNgon(ImDrawListPtr self, Vector2 center, float radius, uint col, int numSegments)
		{
			ImGuiNative.AddNgon(self, center, radius, col, numSegments, (float)(1.0f));
		}
		public static void AddNgon(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddNgon((ImDrawList*)pself, center, radius, col, numSegments, thickness);
			}
		}
		public static void AddNgon(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddNgon((ImDrawList*)pself, center, radius, col, numSegments, (float)(1.0f));
			}
		}
		public static void AddNgonFilled(ImDrawListPtr self, Vector2 center, float radius, uint col, int numSegments)
		{
			ImGuiNative.AddNgonFilled(self, center, radius, col, numSegments);
		}
		public static void AddNgonFilled(ref ImDrawList self, Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddNgonFilled((ImDrawList*)pself, center, radius, col, numSegments);
			}
		}
		public static void AddPolyline(ImDrawListPtr self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			ImGuiNative.AddPolyline(self, points, numPoints, col, flags, thickness);
		}
		public static void AddPolyline(ref ImDrawList self, Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddPolyline((ImDrawList*)pself, points, numPoints, col, flags, thickness);
			}
		}
		public static void AddPolyline(ImDrawListPtr self, ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGuiNative.AddPolyline(self, (Vector2*)ppoints, numPoints, col, flags, thickness);
			}
		}
		public static void AddPolyline(ref ImDrawList self, ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGuiNative.AddPolyline((ImDrawList*)pself, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}
		public static void AddConvexPolyFilled(ImDrawListPtr self, Vector2* points, int numPoints, uint col)
		{
			ImGuiNative.AddConvexPolyFilled(self, points, numPoints, col);
		}
		public static void AddConvexPolyFilled(ref ImDrawList self, Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddConvexPolyFilled((ImDrawList*)pself, points, numPoints, col);
			}
		}
		public static void AddConvexPolyFilled(ImDrawListPtr self, ref Vector2 points, int numPoints, uint col)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGuiNative.AddConvexPolyFilled(self, (Vector2*)ppoints, numPoints, col);
			}
		}
		public static void AddConvexPolyFilled(ref ImDrawList self, ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGuiNative.AddConvexPolyFilled((ImDrawList*)pself, (Vector2*)ppoints, numPoints, col);
				}
			}
		}
		public static void AddBezierCubic(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			ImGuiNative.AddBezierCubic(self, p1, p2, p3, p4, col, thickness, numSegments);
		}
		public static void AddBezierCubic(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGuiNative.AddBezierCubic(self, p1, p2, p3, p4, col, thickness, (int)(0));
		}
		public static void AddBezierCubic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddBezierCubic((ImDrawList*)pself, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}
		public static void AddBezierCubic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddBezierCubic((ImDrawList*)pself, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}
		public static void AddBezierQuadratic(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			ImGuiNative.AddBezierQuadratic(self, p1, p2, p3, col, thickness, numSegments);
		}
		public static void AddBezierQuadratic(ImDrawListPtr self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGuiNative.AddBezierQuadratic(self, p1, p2, p3, col, thickness, (int)(0));
		}
		public static void AddBezierQuadratic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddBezierQuadratic((ImDrawList*)pself, p1, p2, p3, col, thickness, numSegments);
			}
		}
		public static void AddBezierQuadratic(ref ImDrawList self, Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddBezierQuadratic((ImDrawList*)pself, p1, p2, p3, col, thickness, (int)(0));
			}
		}
		public static void AddImage(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			ImGuiNative.AddImage(self, userTextureId, pMin, pMax, uvMin, uvMax, col);
		}
		public static void AddImage(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			ImGuiNative.AddImage(self, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
		}
		public static void AddImage(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			ImGuiNative.AddImage(self, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}
		public static void AddImage(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			ImGuiNative.AddImage(self, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}
		public static void AddImage(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			ImGuiNative.AddImage(self, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
		}
		public static void AddImage(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGuiNative.AddImage(self, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
		}
		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}
		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}
		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}
		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}
		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
			}
		}
		public static void AddImage(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImage((ImDrawList*)pself, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
			}
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}
		public static void AddImageQuad(ImDrawListPtr self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGuiNative.AddImageQuad(self, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}
		public static void AddImageQuad(ref ImDrawList self, ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageQuad((ImDrawList*)pself, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}
		public static void AddImageRounded(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGuiNative.AddImageRounded(self, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
		}
		public static void AddImageRounded(ImDrawListPtr self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			ImGuiNative.AddImageRounded(self, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
		}
		public static void AddImageRounded(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageRounded((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}
		public static void AddImageRounded(ref ImDrawList self, ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddImageRounded((ImDrawList*)pself, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
			}
		}
		public static void PathClear(ImDrawListPtr self)
		{
			ImGuiNative.PathClear(self);
		}
		public static void PathClear(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathClear((ImDrawList*)pself);
			}
		}
		public static void PathLineTo(ImDrawListPtr self, Vector2 pos)
		{
			ImGuiNative.PathLineTo(self, pos);
		}
		public static void PathLineTo(ref ImDrawList self, Vector2 pos)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathLineTo((ImDrawList*)pself, pos);
			}
		}
		public static void PathLineToMergeDuplicate(ImDrawListPtr self, Vector2 pos)
		{
			ImGuiNative.PathLineToMergeDuplicate(self, pos);
		}
		public static void PathLineToMergeDuplicate(ref ImDrawList self, Vector2 pos)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathLineToMergeDuplicate((ImDrawList*)pself, pos);
			}
		}
		public static void PathFillConvex(ImDrawListPtr self, uint col)
		{
			ImGuiNative.PathFillConvex(self, col);
		}
		public static void PathFillConvex(ref ImDrawList self, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathFillConvex((ImDrawList*)pself, col);
			}
		}
		public static void PathStroke(ImDrawListPtr self, uint col, ImDrawFlags flags, float thickness)
		{
			ImGuiNative.PathStroke(self, col, flags, thickness);
		}
		public static void PathStroke(ImDrawListPtr self, uint col, ImDrawFlags flags)
		{
			ImGuiNative.PathStroke(self, col, flags, (float)(1.0f));
		}
		public static void PathStroke(ImDrawListPtr self, uint col)
		{
			ImGuiNative.PathStroke(self, col, (ImDrawFlags)(0), (float)(1.0f));
		}
		public static void PathStroke(ImDrawListPtr self, uint col, float thickness)
		{
			ImGuiNative.PathStroke(self, col, (ImDrawFlags)(0), thickness);
		}
		public static void PathStroke(ref ImDrawList self, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathStroke((ImDrawList*)pself, col, flags, thickness);
			}
		}
		public static void PathStroke(ref ImDrawList self, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathStroke((ImDrawList*)pself, col, flags, (float)(1.0f));
			}
		}
		public static void PathStroke(ref ImDrawList self, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathStroke((ImDrawList*)pself, col, (ImDrawFlags)(0), (float)(1.0f));
			}
		}
		public static void PathStroke(ref ImDrawList self, uint col, float thickness)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathStroke((ImDrawList*)pself, col, (ImDrawFlags)(0), thickness);
			}
		}
		public static void PathArcTo(ImDrawListPtr self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGuiNative.PathArcTo(self, center, radius, aMin, aMax, numSegments);
		}
		public static void PathArcTo(ImDrawListPtr self, Vector2 center, float radius, float aMin, float aMax)
		{
			ImGuiNative.PathArcTo(self, center, radius, aMin, aMax, (int)(0));
		}
		public static void PathArcTo(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathArcTo((ImDrawList*)pself, center, radius, aMin, aMax, numSegments);
			}
		}
		public static void PathArcTo(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathArcTo((ImDrawList*)pself, center, radius, aMin, aMax, (int)(0));
			}
		}
		public static void PathArcToFast(ImDrawListPtr self, Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			ImGuiNative.PathArcToFast(self, center, radius, aMinOf12, aMaxOf12);
		}
		public static void PathArcToFast(ref ImDrawList self, Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathArcToFast((ImDrawList*)pself, center, radius, aMinOf12, aMaxOf12);
			}
		}
		public static void PathBezierCubicCurveTo(ImDrawListPtr self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			ImGuiNative.PathBezierCubicCurveTo(self, p2, p3, p4, numSegments);
		}
		public static void PathBezierCubicCurveTo(ImDrawListPtr self, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGuiNative.PathBezierCubicCurveTo(self, p2, p3, p4, (int)(0));
		}
		public static void PathBezierCubicCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathBezierCubicCurveTo((ImDrawList*)pself, p2, p3, p4, numSegments);
			}
		}
		public static void PathBezierCubicCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathBezierCubicCurveTo((ImDrawList*)pself, p2, p3, p4, (int)(0));
			}
		}
		public static void PathBezierQuadraticCurveTo(ImDrawListPtr self, Vector2 p2, Vector2 p3, int numSegments)
		{
			ImGuiNative.PathBezierQuadraticCurveTo(self, p2, p3, numSegments);
		}
		public static void PathBezierQuadraticCurveTo(ImDrawListPtr self, Vector2 p2, Vector2 p3)
		{
			ImGuiNative.PathBezierQuadraticCurveTo(self, p2, p3, (int)(0));
		}
		public static void PathBezierQuadraticCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathBezierQuadraticCurveTo((ImDrawList*)pself, p2, p3, numSegments);
			}
		}
		public static void PathBezierQuadraticCurveTo(ref ImDrawList self, Vector2 p2, Vector2 p3)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathBezierQuadraticCurveTo((ImDrawList*)pself, p2, p3, (int)(0));
			}
		}
		public static void PathRect(ImDrawListPtr self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			ImGuiNative.PathRect(self, rectMin, rectMax, rounding, flags);
		}
		public static void PathRect(ImDrawListPtr self, Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			ImGuiNative.PathRect(self, rectMin, rectMax, rounding, (ImDrawFlags)(0));
		}
		public static void PathRect(ImDrawListPtr self, Vector2 rectMin, Vector2 rectMax)
		{
			ImGuiNative.PathRect(self, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
		}
		public static void PathRect(ImDrawListPtr self, Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			ImGuiNative.PathRect(self, rectMin, rectMax, (float)(0.0f), flags);
		}
		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathRect((ImDrawList*)pself, rectMin, rectMax, rounding, flags);
			}
		}
		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathRect((ImDrawList*)pself, rectMin, rectMax, rounding, (ImDrawFlags)(0));
			}
		}
		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathRect((ImDrawList*)pself, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
			}
		}
		public static void PathRect(ref ImDrawList self, Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PathRect((ImDrawList*)pself, rectMin, rectMax, (float)(0.0f), flags);
			}
		}
		public static void AddCallback(ImDrawListPtr self, ImDrawCallback callback, void* callbackData)
		{
			ImGuiNative.AddCallback(self, callback, callbackData);
		}
		public static void AddCallback(ref ImDrawList self, ImDrawCallback callback, void* callbackData)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddCallback((ImDrawList*)pself, callback, callbackData);
			}
		}
		public static void AddDrawCmd(ImDrawListPtr self)
		{
			ImGuiNative.AddDrawCmd(self);
		}
		public static void AddDrawCmd(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.AddDrawCmd((ImDrawList*)pself);
			}
		}
		public static ImDrawListPtr CloneOutput(ImDrawListPtr self)
		{
			ImDrawListPtr ret = ImGuiNative.CloneOutput(self);
			return ret;
		}
		public static ImDrawListPtr CloneOutput(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImDrawListPtr ret = ImGuiNative.CloneOutput((ImDrawList*)pself);
				return ret;
			}
		}
		public static void ChannelsSplit(ImDrawListPtr self, int count)
		{
			ImGuiNative.ChannelsSplit(self, count);
		}
		public static void ChannelsSplit(ref ImDrawList self, int count)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.ChannelsSplit((ImDrawList*)pself, count);
			}
		}
		public static void ChannelsMerge(ImDrawListPtr self)
		{
			ImGuiNative.ChannelsMerge(self);
		}
		public static void ChannelsMerge(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.ChannelsMerge((ImDrawList*)pself);
			}
		}
		public static void ChannelsSetCurrent(ImDrawListPtr self, int n)
		{
			ImGuiNative.ChannelsSetCurrent(self, n);
		}
		public static void ChannelsSetCurrent(ref ImDrawList self, int n)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.ChannelsSetCurrent((ImDrawList*)pself, n);
			}
		}
		public static void PrimReserve(ImDrawListPtr self, int idxCount, int vtxCount)
		{
			ImGuiNative.PrimReserve(self, idxCount, vtxCount);
		}
		public static void PrimReserve(ref ImDrawList self, int idxCount, int vtxCount)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimReserve((ImDrawList*)pself, idxCount, vtxCount);
			}
		}
		public static void PrimUnreserve(ImDrawListPtr self, int idxCount, int vtxCount)
		{
			ImGuiNative.PrimUnreserve(self, idxCount, vtxCount);
		}
		public static void PrimUnreserve(ref ImDrawList self, int idxCount, int vtxCount)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimUnreserve((ImDrawList*)pself, idxCount, vtxCount);
			}
		}
		public static void PrimRect(ImDrawListPtr self, Vector2 a, Vector2 b, uint col)
		{
			ImGuiNative.PrimRect(self, a, b, col);
		}
		public static void PrimRect(ref ImDrawList self, Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimRect((ImDrawList*)pself, a, b, col);
			}
		}
		public static void PrimRectUV(ImDrawListPtr self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			ImGuiNative.PrimRectUV(self, a, b, uvA, uvB, col);
		}
		public static void PrimRectUV(ref ImDrawList self, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimRectUV((ImDrawList*)pself, a, b, uvA, uvB, col);
			}
		}
		public static void PrimQuadUV(ImDrawListPtr self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			ImGuiNative.PrimQuadUV(self, a, b, c, d, uvA, uvB, uvC, uvD, col);
		}
		public static void PrimQuadUV(ref ImDrawList self, Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimQuadUV((ImDrawList*)pself, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}
		public static void PrimWriteVtx(ImDrawListPtr self, Vector2 pos, Vector2 uv, uint col)
		{
			ImGuiNative.PrimWriteVtx(self, pos, uv, col);
		}
		public static void PrimWriteVtx(ref ImDrawList self, Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimWriteVtx((ImDrawList*)pself, pos, uv, col);
			}
		}
		public static void PrimWriteIdx(ImDrawListPtr self, ushort idx)
		{
			ImGuiNative.PrimWriteIdx(self, idx);
		}
		public static void PrimWriteIdx(ref ImDrawList self, ushort idx)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimWriteIdx((ImDrawList*)pself, idx);
			}
		}
		public static void PrimVtx(ImDrawListPtr self, Vector2 pos, Vector2 uv, uint col)
		{
			ImGuiNative.PrimVtx(self, pos, uv, col);
		}
		public static void PrimVtx(ref ImDrawList self, Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative.PrimVtx((ImDrawList*)pself, pos, uv, col);
			}
		}
		public static void _ResetForNewFrame(ImDrawListPtr self)
		{
			ImGuiNative._ResetForNewFrame(self);
		}
		public static void _ResetForNewFrame(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._ResetForNewFrame((ImDrawList*)pself);
			}
		}
		public static void _ClearFreeMemory(ImDrawListPtr self)
		{
			ImGuiNative._ClearFreeMemory(self);
		}
		public static void _ClearFreeMemory(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._ClearFreeMemory((ImDrawList*)pself);
			}
		}
		public static void _PopUnusedDrawCmd(ImDrawListPtr self)
		{
			ImGuiNative._PopUnusedDrawCmd(self);
		}
		public static void _PopUnusedDrawCmd(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._PopUnusedDrawCmd((ImDrawList*)pself);
			}
		}
		public static void _TryMergeDrawCmds(ImDrawListPtr self)
		{
			ImGuiNative._TryMergeDrawCmds(self);
		}
		public static void _TryMergeDrawCmds(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._TryMergeDrawCmds((ImDrawList*)pself);
			}
		}
		public static void _OnChangedClipRect(ImDrawListPtr self)
		{
			ImGuiNative._OnChangedClipRect(self);
		}
		public static void _OnChangedClipRect(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._OnChangedClipRect((ImDrawList*)pself);
			}
		}
		public static void _OnChangedTextureID(ImDrawListPtr self)
		{
			ImGuiNative._OnChangedTextureID(self);
		}
		public static void _OnChangedTextureID(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._OnChangedTextureID((ImDrawList*)pself);
			}
		}
		public static void _OnChangedVtxOffset(ImDrawListPtr self)
		{
			ImGuiNative._OnChangedVtxOffset(self);
		}
		public static void _OnChangedVtxOffset(ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._OnChangedVtxOffset((ImDrawList*)pself);
			}
		}
		public static int _CalcCircleAutoSegmentCount(ImDrawListPtr self, float radius)
		{
			int ret = ImGuiNative._CalcCircleAutoSegmentCount(self, radius);
			return ret;
		}
		public static int _CalcCircleAutoSegmentCount(ref ImDrawList self, float radius)
		{
			fixed (ImDrawList* pself = &self)
			{
				int ret = ImGuiNative._CalcCircleAutoSegmentCount((ImDrawList*)pself, radius);
				return ret;
			}
		}
		public static void _PathArcToFastEx(ImDrawListPtr self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			ImGuiNative._PathArcToFastEx(self, center, radius, aMinSample, aMaxSample, aStep);
		}
		public static void _PathArcToFastEx(ref ImDrawList self, Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._PathArcToFastEx((ImDrawList*)pself, center, radius, aMinSample, aMaxSample, aStep);
			}
		}
		public static void _PathArcToN(ImDrawListPtr self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGuiNative._PathArcToN(self, center, radius, aMin, aMax, numSegments);
		}
		public static void _PathArcToN(ref ImDrawList self, Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* pself = &self)
			{
				ImGuiNative._PathArcToN((ImDrawList*)pself, center, radius, aMin, aMax, numSegments);
			}
		}
		public static ImDrawDataPtr ImDrawData()
		{
			ImDrawDataPtr ret = ImGuiNative.ImDrawData();
			return ret;
		}
		public static void DeIndexAllBuffers(ImDrawDataPtr self)
		{
			ImGuiNative.DeIndexAllBuffers(self);
		}
		public static void DeIndexAllBuffers(ref ImDrawData self)
		{
			fixed (ImDrawData* pself = &self)
			{
				ImGuiNative.DeIndexAllBuffers((ImDrawData*)pself);
			}
		}
		public static void ScaleClipRects(ImDrawDataPtr self, Vector2 fbScale)
		{
			ImGuiNative.ScaleClipRects(self, fbScale);
		}
		public static void ScaleClipRects(ref ImDrawData self, Vector2 fbScale)
		{
			fixed (ImDrawData* pself = &self)
			{
				ImGuiNative.ScaleClipRects((ImDrawData*)pself, fbScale);
			}
		}
		public static ImFontConfigPtr ImFontConfig()
		{
			ImFontConfigPtr ret = ImGuiNative.ImFontConfig();
			return ret;
		}
		public static ImFontGlyphRangesBuilderPtr ImFontGlyphRangesBuilder()
		{
			ImFontGlyphRangesBuilderPtr ret = ImGuiNative.ImFontGlyphRangesBuilder();
			return ret;
		}
		public static bool GetBit(ImFontGlyphRangesBuilderPtr self, nuint n)
		{
			byte ret = ImGuiNative.GetBit(self, n);
			return ret != 0;
		}
		public static bool GetBit(ref ImFontGlyphRangesBuilder self, nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				byte ret = ImGuiNative.GetBit((ImFontGlyphRangesBuilder*)pself, n);
				return ret != 0;
			}
		}
		public static void SetBit(ImFontGlyphRangesBuilderPtr self, nuint n)
		{
			ImGuiNative.SetBit(self, n);
		}
		public static void SetBit(ref ImFontGlyphRangesBuilder self, nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ImGuiNative.SetBit((ImFontGlyphRangesBuilder*)pself, n);
			}
		}
		public static void AddChar(ImFontGlyphRangesBuilderPtr self, ushort c)
		{
			ImGuiNative.AddChar(self, c);
		}
		public static void AddChar(ref ImFontGlyphRangesBuilder self, ushort c)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ImGuiNative.AddChar((ImFontGlyphRangesBuilder*)pself, c);
			}
		}
		public static void AddRanges(ImFontGlyphRangesBuilderPtr self, ushort* ranges)
		{
			ImGuiNative.AddRanges(self, ranges);
		}
		public static void AddRanges(ref ImFontGlyphRangesBuilder self, ushort* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ImGuiNative.AddRanges((ImFontGlyphRangesBuilder*)pself, ranges);
			}
		}
		public static void BuildRanges(ImFontGlyphRangesBuilderPtr self, ImVector<ushort>* outRanges)
		{
			ImGuiNative.BuildRanges(self, outRanges);
		}
		public static void BuildRanges(ref ImFontGlyphRangesBuilder self, ImVector<ushort>* outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				ImGuiNative.BuildRanges((ImFontGlyphRangesBuilder*)pself, outRanges);
			}
		}
		public static void BuildRanges(ImFontGlyphRangesBuilderPtr self, ref ImVector<ushort> outRanges)
		{
			fixed (ImVector<ushort>* poutRanges = &outRanges)
			{
				ImGuiNative.BuildRanges(self, (ImVector<ushort>*)poutRanges);
			}
		}
		public static void BuildRanges(ref ImFontGlyphRangesBuilder self, ref ImVector<ushort> outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* pself = &self)
			{
				fixed (ImVector<ushort>* poutRanges = &outRanges)
				{
					ImGuiNative.BuildRanges((ImFontGlyphRangesBuilder*)pself, (ImVector<ushort>*)poutRanges);
				}
			}
		}
		public static ImFontAtlasCustomRectPtr ImFontAtlasCustomRect()
		{
			ImFontAtlasCustomRectPtr ret = ImGuiNative.ImFontAtlasCustomRect();
			return ret;
		}
		public static bool IsPacked(ImFontAtlasCustomRectPtr self)
		{
			byte ret = ImGuiNative.IsPacked(self);
			return ret != 0;
		}
		public static bool IsPacked(ref ImFontAtlasCustomRect self)
		{
			fixed (ImFontAtlasCustomRect* pself = &self)
			{
				byte ret = ImGuiNative.IsPacked((ImFontAtlasCustomRect*)pself);
				return ret != 0;
			}
		}
		public static ImFontAtlasPtr ImFontAtlas()
		{
			ImFontAtlasPtr ret = ImGuiNative.ImFontAtlas();
			return ret;
		}
		public static ImFontPtr AddFont(ImFontAtlasPtr self, ImFontConfigPtr fontCfg)
		{
			ImFontPtr ret = ImGuiNative.AddFont(self, fontCfg);
			return ret;
		}
		public static ImFontPtr AddFont(ref ImFontAtlas self, ImFontConfigPtr fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = ImGuiNative.AddFont((ImFontAtlas*)pself, fontCfg);
				return ret;
			}
		}
		public static ImFontPtr AddFont(ImFontAtlasPtr self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGuiNative.AddFont(self, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}
		public static ImFontPtr AddFont(ref ImFontAtlas self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGuiNative.AddFont((ImFontAtlas*)pself, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}
		public static ImFontPtr AddFontDefault(ImFontAtlasPtr self, ImFontConfigPtr fontCfg)
		{
			ImFontPtr ret = ImGuiNative.AddFontDefault(self, fontCfg);
			return ret;
		}
		public static ImFontPtr AddFontDefault(ImFontAtlasPtr self)
		{
			ImFontPtr ret = ImGuiNative.AddFontDefault(self, (ImFontConfig*)(default));
			return ret;
		}
		public static ImFontPtr AddFontDefault(ref ImFontAtlas self, ImFontConfigPtr fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = ImGuiNative.AddFontDefault((ImFontAtlas*)pself, fontCfg);
				return ret;
			}
		}
		public static ImFontPtr AddFontDefault(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontPtr ret = ImGuiNative.AddFontDefault((ImFontAtlas*)pself, (ImFontConfig*)(default));
				return ret;
			}
		}
		public static ImFontPtr AddFontDefault(ImFontAtlasPtr self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontConfig* pfontCfg = &fontCfg)
			{
				ImFontPtr ret = ImGuiNative.AddFontDefault(self, (ImFontConfig*)pfontCfg);
				return ret;
			}
		}
		public static ImFontPtr AddFontDefault(ref ImFontAtlas self, ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFontPtr ret = ImGuiNative.AddFontDefault((ImFontAtlas*)pself, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}
		public static void ClearInputData(ImFontAtlasPtr self)
		{
			ImGuiNative.ClearInputData(self);
		}
		public static void ClearInputData(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.ClearInputData((ImFontAtlas*)pself);
			}
		}
		public static void ClearTexData(ImFontAtlasPtr self)
		{
			ImGuiNative.ClearTexData(self);
		}
		public static void ClearTexData(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.ClearTexData((ImFontAtlas*)pself);
			}
		}
		public static void ClearFonts(ImFontAtlasPtr self)
		{
			ImGuiNative.ClearFonts(self);
		}
		public static void ClearFonts(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.ClearFonts((ImFontAtlas*)pself);
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, outWidth, outHeight, outBytesPerPixel);
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight)
		{
			ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, outWidth, outHeight, (int*)(default));
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, outHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsAlpha8(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsAlpha8(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGuiNative.GetTexDataAsAlpha8((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, outWidth, outHeight, outBytesPerPixel);
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight)
		{
			ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, outWidth, outHeight, (int*)(default));
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, outHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, int* outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, int* outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, byte** outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ImFontAtlasPtr self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGuiNative.GetTexDataAsRGBA32(self, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}
		public static void GetTexDataAsRGBA32(ref ImFontAtlas self, int textureIndex, ref byte* outPixels, ref int outWidth, ref int outHeight, ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGuiNative.GetTexDataAsRGBA32((ImFontAtlas*)pself, textureIndex, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}
		public static bool IsBuilt(ImFontAtlasPtr self)
		{
			byte ret = ImGuiNative.IsBuilt(self);
			return ret != 0;
		}
		public static bool IsBuilt(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte ret = ImGuiNative.IsBuilt((ImFontAtlas*)pself);
				return ret != 0;
			}
		}
		public static void SetTexID(ImFontAtlasPtr self, int textureIndex, ImTextureID id)
		{
			ImGuiNative.SetTexID(self, textureIndex, id);
		}
		public static void SetTexID(ref ImFontAtlas self, int textureIndex, ImTextureID id)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.SetTexID((ImFontAtlas*)pself, textureIndex, id);
			}
		}
		public static void ClearTexID(ImFontAtlasPtr self, ImTextureID nullId)
		{
			ImGuiNative.ClearTexID(self, nullId);
		}
		public static void ClearTexID(ref ImFontAtlas self, ImTextureID nullId)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.ClearTexID((ImFontAtlas*)pself, nullId);
			}
		}
		public static ushort* GetGlyphRangesDefault(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesDefault(self);
			return ret;
		}
		public static ushort* GetGlyphRangesDefault(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesDefault((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesKorean(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesKorean(self);
			return ret;
		}
		public static ushort* GetGlyphRangesKorean(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesKorean((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesJapanese(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesJapanese(self);
			return ret;
		}
		public static ushort* GetGlyphRangesJapanese(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesJapanese((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesChineseFull(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesChineseFull(self);
			return ret;
		}
		public static ushort* GetGlyphRangesChineseFull(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesChineseFull((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesChineseSimplifiedCommon(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesChineseSimplifiedCommon(self);
			return ret;
		}
		public static ushort* GetGlyphRangesChineseSimplifiedCommon(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesChineseSimplifiedCommon((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesCyrillic(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesCyrillic(self);
			return ret;
		}
		public static ushort* GetGlyphRangesCyrillic(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesCyrillic((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesThai(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesThai(self);
			return ret;
		}
		public static ushort* GetGlyphRangesThai(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesThai((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static ushort* GetGlyphRangesVietnamese(ImFontAtlasPtr self)
		{
			ushort* ret = ImGuiNative.GetGlyphRangesVietnamese(self);
			return ret;
		}
		public static ushort* GetGlyphRangesVietnamese(ref ImFontAtlas self)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ushort* ret = ImGuiNative.GetGlyphRangesVietnamese((ImFontAtlas*)pself);
				return ret;
			}
		}
		public static int AddCustomRectRegular(ImFontAtlasPtr self, int width, int height)
		{
			int ret = ImGuiNative.AddCustomRectRegular(self, width, height);
			return ret;
		}
		public static int AddCustomRectRegular(ref ImFontAtlas self, int width, int height)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = ImGuiNative.AddCustomRectRegular((ImFontAtlas*)pself, width, height);
				return ret;
			}
		}
		public static int AddCustomRectFontGlyph(ImFontAtlasPtr self, ImFontPtr font, ushort id, int width, int height, float advanceX, Vector2 offset)
		{
			int ret = ImGuiNative.AddCustomRectFontGlyph(self, font, id, width, height, advanceX, offset);
			return ret;
		}
		public static int AddCustomRectFontGlyph(ImFontAtlasPtr self, ImFontPtr font, ushort id, int width, int height, float advanceX)
		{
			int ret = ImGuiNative.AddCustomRectFontGlyph(self, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
			return ret;
		}
		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ImFontPtr font, ushort id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = ImGuiNative.AddCustomRectFontGlyph((ImFontAtlas*)pself, font, id, width, height, advanceX, offset);
				return ret;
			}
		}
		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ImFontPtr font, ushort id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				int ret = ImGuiNative.AddCustomRectFontGlyph((ImFontAtlas*)pself, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}
		public static int AddCustomRectFontGlyph(ImFontAtlasPtr self, ref ImFont font, ushort id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = ImGuiNative.AddCustomRectFontGlyph(self, (ImFont*)pfont, id, width, height, advanceX, offset);
				return ret;
			}
		}
		public static int AddCustomRectFontGlyph(ImFontAtlasPtr self, ref ImFont font, ushort id, int width, int height, float advanceX)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = ImGuiNative.AddCustomRectFontGlyph(self, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}
		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ref ImFont font, ushort id, int width, int height, float advanceX, Vector2 offset)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGuiNative.AddCustomRectFontGlyph((ImFontAtlas*)pself, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}
		public static int AddCustomRectFontGlyph(ref ImFontAtlas self, ref ImFont font, ushort id, int width, int height, float advanceX)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGuiNative.AddCustomRectFontGlyph((ImFontAtlas*)pself, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
					return ret;
				}
			}
		}
		public static ImFontAtlasCustomRectPtr GetCustomRectByIndex(ImFontAtlasPtr self, int index)
		{
			ImFontAtlasCustomRectPtr ret = ImGuiNative.GetCustomRectByIndex(self, index);
			return ret;
		}
		public static ImFontAtlasCustomRectPtr GetCustomRectByIndex(ref ImFontAtlas self, int index)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImFontAtlasCustomRectPtr ret = ImGuiNative.GetCustomRectByIndex((ImFontAtlas*)pself, index);
				return ret;
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ImFontAtlasCustomRectPtr rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			ImGuiNative.CalcCustomRectUV(self, rect, outUvMin, outUvMax);
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRectPtr rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, rect, outUvMin, outUvMax);
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				ImGuiNative.CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ImFontAtlasCustomRectPtr rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				ImGuiNative.CalcCustomRectUV(self, rect, (Vector2*)poutUvMin, outUvMax);
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRectPtr rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGuiNative.CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, Vector2* outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ImFontAtlasCustomRectPtr rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMax = &outUvMax)
			{
				ImGuiNative.CalcCustomRectUV(self, rect, outUvMin, (Vector2*)poutUvMax);
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRectPtr rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGuiNative.CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, Vector2* outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ImFontAtlasCustomRectPtr rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGuiNative.CalcCustomRectUV(self, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
				}
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ImFontAtlasCustomRectPtr rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}
		public static void CalcCustomRectUV(ImFontAtlasPtr self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGuiNative.CalcCustomRectUV(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}
		public static void CalcCustomRectUV(ref ImFontAtlas self, ref ImFontAtlasCustomRect rect, ref Vector2 outUvMin, ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							ImGuiNative.CalcCustomRectUV((ImFontAtlas*)pself, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, outUvFill, textureIndex);
			return ret != 0;
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, outUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutUvBorder = outUvBorder)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = outUvBorder)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutUvFill = outUvFill)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutUvBorder = outUvBorder)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, int* textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = outUvBorder)
						{
							fixed (Vector2* poutUvFill = outUvFill)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, textureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (int* ptextureIndex = &textureIndex)
			{
				byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, outUvFill, (int*)ptextureIndex);
				return ret != 0;
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, outUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutUvBorder = outUvBorder)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, Vector2* outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = outUvBorder)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutUvFill = outUvFill)
			{
				fixed (int* ptextureIndex = &textureIndex)
				{
					byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
					return ret != 0;
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, Vector2* outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutUvBorder = outUvBorder)
			{
				fixed (Vector2* poutUvFill = outUvFill)
				{
					fixed (int* ptextureIndex = &textureIndex)
					{
						byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
						return ret != 0;
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, Vector2* outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = outUvBorder)
				{
					fixed (Vector2* poutUvFill = outUvFill)
					{
						fixed (int* ptextureIndex = &textureIndex)
						{
							byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, Vector2* outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ImFontAtlasPtr self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = outUvBorder)
					{
						fixed (Vector2* poutUvFill = outUvFill)
						{
							fixed (int* ptextureIndex = &textureIndex)
							{
								byte ret = ImGuiNative.GetMouseCursorTexData(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
								return ret != 0;
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ref Vector2 outUvBorder, ref Vector2 outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								fixed (int* ptextureIndex = &textureIndex)
								{
									byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}
		public static bool GetMouseCursorTexData(ref ImFontAtlas self, ImGuiMouseCursor cursor, ref Vector2 outOffset, ref Vector2 outSize, ReadOnlySpan<Vector2> outUvBorder, ReadOnlySpan<Vector2> outUvFill, ref int textureIndex)
		{
			fixed (ImFontAtlas* pself = &self)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = outUvBorder)
						{
							fixed (Vector2* poutUvFill = outUvFill)
							{
								fixed (int* ptextureIndex = &textureIndex)
								{
									byte ret = ImGuiNative.GetMouseCursorTexData((ImFontAtlas*)pself, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill, (int*)ptextureIndex);
									return ret != 0;
								}
							}
						}
					}
				}
			}
		}
		public static ImFontPtr ImFont()
		{
			ImFontPtr ret = ImGuiNative.ImFont();
			return ret;
		}
		public static ImFontGlyphPtr FindGlyph(ImFontPtr self, ushort c)
		{
			ImFontGlyphPtr ret = ImGuiNative.FindGlyph(self, c);
			return ret;
		}
		public static ImFontGlyphPtr FindGlyph(ref ImFont self, ushort c)
		{
			fixed (ImFont* pself = &self)
			{
				ImFontGlyphPtr ret = ImGuiNative.FindGlyph((ImFont*)pself, c);
				return ret;
			}
		}
		public static ImFontGlyphPtr FindGlyphNoFallback(ImFontPtr self, ushort c)
		{
			ImFontGlyphPtr ret = ImGuiNative.FindGlyphNoFallback(self, c);
			return ret;
		}
		public static ImFontGlyphPtr FindGlyphNoFallback(ref ImFont self, ushort c)
		{
			fixed (ImFont* pself = &self)
			{
				ImFontGlyphPtr ret = ImGuiNative.FindGlyphNoFallback((ImFont*)pself, c);
				return ret;
			}
		}
		public static float GetDistanceAdjustmentForPair(ImFontPtr self, ushort leftC, ushort rightC)
		{
			float ret = ImGuiNative.GetDistanceAdjustmentForPair(self, leftC, rightC);
			return ret;
		}
		public static float GetDistanceAdjustmentForPair(ref ImFont self, ushort leftC, ushort rightC)
		{
			fixed (ImFont* pself = &self)
			{
				float ret = ImGuiNative.GetDistanceAdjustmentForPair((ImFont*)pself, leftC, rightC);
				return ret;
			}
		}
		public static float GetCharAdvance(ImFontPtr self, ushort c)
		{
			float ret = ImGuiNative.GetCharAdvance(self, c);
			return ret;
		}
		public static float GetCharAdvance(ref ImFont self, ushort c)
		{
			fixed (ImFont* pself = &self)
			{
				float ret = ImGuiNative.GetCharAdvance((ImFont*)pself, c);
				return ret;
			}
		}
		public static bool IsLoaded(ImFontPtr self)
		{
			byte ret = ImGuiNative.IsLoaded(self);
			return ret != 0;
		}
		public static bool IsLoaded(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				byte ret = ImGuiNative.IsLoaded((ImFont*)pself);
				return ret != 0;
			}
		}
		public static byte* GetDebugName(ImFontPtr self)
		{
			byte* ret = ImGuiNative.GetDebugName(self);
			return ret;
		}
		public static byte* GetDebugName(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				byte* ret = ImGuiNative.GetDebugName((ImFont*)pself);
				return ret;
			}
		}
		public static string GetDebugNameS(ImFontPtr self)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiNative.GetDebugName(self));
			return ret;
		}
		public static string GetDebugNameS(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiNative.GetDebugName((ImFont*)pself));
				return ret;
			}
		}
		public static void RenderChar(ImFontPtr self, ImDrawListPtr drawList, float size, Vector2 pos, uint col, ushort c)
		{
			ImGuiNative.RenderChar(self, drawList, size, pos, col, c);
		}
		public static void RenderChar(ref ImFont self, ImDrawListPtr drawList, float size, Vector2 pos, uint col, ushort c)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.RenderChar((ImFont*)pself, drawList, size, pos, col, c);
			}
		}
		public static void RenderChar(ImFontPtr self, ref ImDrawList drawList, float size, Vector2 pos, uint col, ushort c)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiNative.RenderChar(self, (ImDrawList*)pdrawList, size, pos, col, c);
			}
		}
		public static void RenderChar(ref ImFont self, ref ImDrawList drawList, float size, Vector2 pos, uint col, ushort c)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiNative.RenderChar((ImFont*)pself, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}
		public static void BuildLookupTable(ImFontPtr self)
		{
			ImGuiNative.BuildLookupTable(self);
		}
		public static void BuildLookupTable(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.BuildLookupTable((ImFont*)pself);
			}
		}
		public static void ClearOutputData(ImFontPtr self)
		{
			ImGuiNative.ClearOutputData(self);
		}
		public static void ClearOutputData(ref ImFont self)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.ClearOutputData((ImFont*)pself);
			}
		}
		public static void GrowIndex(ImFontPtr self, int newSize)
		{
			ImGuiNative.GrowIndex(self, newSize);
		}
		public static void GrowIndex(ref ImFont self, int newSize)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.GrowIndex((ImFont*)pself, newSize);
			}
		}
		public static void AddGlyph(ImFontPtr self, ImFontConfigPtr srcCfg, ushort c, int textureIndex, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			ImGuiNative.AddGlyph(self, srcCfg, c, textureIndex, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
		}
		public static void AddGlyph(ref ImFont self, ImFontConfigPtr srcCfg, ushort c, int textureIndex, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.AddGlyph((ImFont*)pself, srcCfg, c, textureIndex, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}
		public static void AddGlyph(ImFontPtr self, ref ImFontConfig srcCfg, ushort c, int textureIndex, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFontConfig* psrcCfg = &srcCfg)
			{
				ImGuiNative.AddGlyph(self, (ImFontConfig*)psrcCfg, c, textureIndex, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}
		public static void AddGlyph(ref ImFont self, ref ImFontConfig srcCfg, ushort c, int textureIndex, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					ImGuiNative.AddGlyph((ImFont*)pself, (ImFontConfig*)psrcCfg, c, textureIndex, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}
		public static void AddRemapChar(ImFontPtr self, ushort dst, ushort src, bool overwriteDst)
		{
			ImGuiNative.AddRemapChar(self, dst, src, overwriteDst ? (byte)1 : (byte)0);
		}
		public static void AddRemapChar(ImFontPtr self, ushort dst, ushort src)
		{
			ImGuiNative.AddRemapChar(self, dst, src, (byte)(1));
		}
		public static void AddRemapChar(ref ImFont self, ushort dst, ushort src, bool overwriteDst)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.AddRemapChar((ImFont*)pself, dst, src, overwriteDst ? (byte)1 : (byte)0);
			}
		}
		public static void AddRemapChar(ref ImFont self, ushort dst, ushort src)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.AddRemapChar((ImFont*)pself, dst, src, (byte)(1));
			}
		}
		public static void SetGlyphVisible(ImFontPtr self, ushort c, bool visible)
		{
			ImGuiNative.SetGlyphVisible(self, c, visible ? (byte)1 : (byte)0);
		}
		public static void SetGlyphVisible(ref ImFont self, ushort c, bool visible)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.SetGlyphVisible((ImFont*)pself, c, visible ? (byte)1 : (byte)0);
			}
		}
		public static bool IsGlyphRangeUnused(ImFontPtr self, uint cBegin, uint cLast)
		{
			byte ret = ImGuiNative.IsGlyphRangeUnused(self, cBegin, cLast);
			return ret != 0;
		}
		public static bool IsGlyphRangeUnused(ref ImFont self, uint cBegin, uint cLast)
		{
			fixed (ImFont* pself = &self)
			{
				byte ret = ImGuiNative.IsGlyphRangeUnused((ImFont*)pself, cBegin, cLast);
				return ret != 0;
			}
		}
		public static void AddKerningPair(ImFontPtr self, ushort leftC, ushort rightC, float distanceAdjustment)
		{
			ImGuiNative.AddKerningPair(self, leftC, rightC, distanceAdjustment);
		}
		public static void AddKerningPair(ref ImFont self, ushort leftC, ushort rightC, float distanceAdjustment)
		{
			fixed (ImFont* pself = &self)
			{
				ImGuiNative.AddKerningPair((ImFont*)pself, leftC, rightC, distanceAdjustment);
			}
		}
		public static float GetDistanceAdjustmentForPairFromHotData(ImFontPtr self, ushort leftC, ImFontGlyphHotDataPtr rightCInfo)
		{
			float ret = ImGuiNative.GetDistanceAdjustmentForPairFromHotData(self, leftC, rightCInfo);
			return ret;
		}
		public static float GetDistanceAdjustmentForPairFromHotData(ref ImFont self, ushort leftC, ImFontGlyphHotDataPtr rightCInfo)
		{
			fixed (ImFont* pself = &self)
			{
				float ret = ImGuiNative.GetDistanceAdjustmentForPairFromHotData((ImFont*)pself, leftC, rightCInfo);
				return ret;
			}
		}
		public static float GetDistanceAdjustmentForPairFromHotData(ImFontPtr self, ushort leftC, ref ImFontGlyphHotData rightCInfo)
		{
			fixed (ImFontGlyphHotData* prightCInfo = &rightCInfo)
			{
				float ret = ImGuiNative.GetDistanceAdjustmentForPairFromHotData(self, leftC, (ImFontGlyphHotData*)prightCInfo);
				return ret;
			}
		}
		public static float GetDistanceAdjustmentForPairFromHotData(ref ImFont self, ushort leftC, ref ImFontGlyphHotData rightCInfo)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (ImFontGlyphHotData* prightCInfo = &rightCInfo)
				{
					float ret = ImGuiNative.GetDistanceAdjustmentForPairFromHotData((ImFont*)pself, leftC, (ImFontGlyphHotData*)prightCInfo);
					return ret;
				}
			}
		}
		public static ImGuiViewportPtr ImGuiViewport()
		{
			ImGuiViewportPtr ret = ImGuiNative.ImGuiViewport();
			return ret;
		}
		public static Vector2 GetCenter(ImGuiViewportPtr self)
		{
			Vector2 ret;
			ImGuiNative.GetCenter(&ret, self);
			return ret;
		}
		public static void GetCenter(Vector2* pOut, ImGuiViewportPtr self)
		{
			ImGuiNative.GetCenter(pOut, self);
		}
		public static void GetCenter(ref Vector2 pOut, ImGuiViewportPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetCenter((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetCenter(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				Vector2 ret;
				ImGuiNative.GetCenter(&ret, (ImGuiViewport*)pself);
				return ret;
			}
		}
		public static void GetCenter(Vector2* pOut, ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				ImGuiNative.GetCenter(pOut, (ImGuiViewport*)pself);
			}
		}
		public static void GetCenter(ref Vector2 pOut, ref ImGuiViewport self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					ImGuiNative.GetCenter((Vector2*)ppOut, (ImGuiViewport*)pself);
				}
			}
		}
		public static Vector2 GetWorkCenter(ImGuiViewportPtr self)
		{
			Vector2 ret;
			ImGuiNative.GetWorkCenter(&ret, self);
			return ret;
		}
		public static void GetWorkCenter(Vector2* pOut, ImGuiViewportPtr self)
		{
			ImGuiNative.GetWorkCenter(pOut, self);
		}
		public static void GetWorkCenter(ref Vector2 pOut, ImGuiViewportPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiNative.GetWorkCenter((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetWorkCenter(ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				Vector2 ret;
				ImGuiNative.GetWorkCenter(&ret, (ImGuiViewport*)pself);
				return ret;
			}
		}
		public static void GetWorkCenter(Vector2* pOut, ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				ImGuiNative.GetWorkCenter(pOut, (ImGuiViewport*)pself);
			}
		}
		public static void GetWorkCenter(ref Vector2 pOut, ref ImGuiViewport self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewport* pself = &self)
				{
					ImGuiNative.GetWorkCenter((Vector2*)ppOut, (ImGuiViewport*)pself);
				}
			}
		}
		public static ImGuiPlatformIOPtr ImGuiPlatformIO()
		{
			ImGuiPlatformIOPtr ret = ImGuiNative.ImGuiPlatformIO();
			return ret;
		}
		public static ImGuiPlatformMonitorPtr ImGuiPlatformMonitor()
		{
			ImGuiPlatformMonitorPtr ret = ImGuiNative.ImGuiPlatformMonitor();
			return ret;
		}
		public static ImGuiPlatformImeDataPtr ImGuiPlatformImeData()
		{
			ImGuiPlatformImeDataPtr ret = ImGuiNative.ImGuiPlatformImeData();
			return ret;
		}
		public static int GetKeyIndex(ImGuiKey key)
		{
			int ret = ImGuiNative.GetKeyIndex(key);
			return ret;
		}
		public static float GETFLTMAX()
		{
			float ret = ImGuiNative.GETFLTMAX();
			return ret;
		}
		public static float GETFLTMIN()
		{
			float ret = ImGuiNative.GETFLTMIN();
			return ret;
		}
		public static ImVector<ushort>* ImVectorImWcharCreate()
		{
			ImVector<ushort>* ret = ImGuiNative.ImVectorImWcharCreate();
			return ret;
		}
		public static void ImVectorImWcharDestroy(ImVector<ushort>* self)
		{
			ImGuiNative.ImVectorImWcharDestroy(self);
		}
		public static void ImVectorImWcharDestroy(ref ImVector<ushort> self)
		{
			fixed (ImVector<ushort>* pself = &self)
			{
				ImGuiNative.ImVectorImWcharDestroy((ImVector<ushort>*)pself);
			}
		}
		public static void ImVectorImWcharInit(ImVector<ushort>* p)
		{
			ImGuiNative.ImVectorImWcharInit(p);
		}
		public static void ImVectorImWcharInit(ref ImVector<ushort> p)
		{
			fixed (ImVector<ushort>* pp = &p)
			{
				ImGuiNative.ImVectorImWcharInit((ImVector<ushort>*)pp);
			}
		}
		public static void ImVectorImWcharUnInit(ImVector<ushort>* p)
		{
			ImGuiNative.ImVectorImWcharUnInit(p);
		}
		public static void ImVectorImWcharUnInit(ref ImVector<ushort> p)
		{
			fixed (ImVector<ushort>* pp = &p)
			{
				ImGuiNative.ImVectorImWcharUnInit((ImVector<ushort>*)pp);
			}
		}
}
// DISCARDED: AddFontFromFileTTF
// DISCARDED: AddFontFromMemoryCompressedBase85TTF
// DISCARDED: AddFontFromMemoryCompressedTTF
// DISCARDED: AddFontFromMemoryTTF
// DISCARDED: AddText
// DISCARDED: append
// DISCARDED: appendf
// DISCARDED: appendfv
// DISCARDED: BulletText
// DISCARDED: BulletTextV
// DISCARDED: CalcTextSize
// DISCARDED: CalcTextSizeA
// DISCARDED: CalcWordWrapPositionA
// DISCARDED: CalcWordWrapPositionAS
// DISCARDED: ColorEdit3
// DISCARDED: ColorEdit4
// DISCARDED: ColorPicker3
// DISCARDED: ColorPicker4
// DISCARDED: DragFloat
// DISCARDED: DragFloat2
// DISCARDED: DragFloat3
// DISCARDED: DragFloat4
// DISCARDED: DragFloatRange2
// DISCARDED: DragInt
// DISCARDED: DragInt2
// DISCARDED: DragInt3
// DISCARDED: DragInt4
// DISCARDED: DragIntRange2
// DISCARDED: DragScalar
// DISCARDED: DragScalarN
// DISCARDED: GetBoolRef
// DISCARDED: GetFloatRef
// DISCARDED: GetID
// DISCARDED: GetIntRef
// DISCARDED: InputDouble
// DISCARDED: InputFloat
// DISCARDED: InputFloat2
// DISCARDED: InputFloat3
// DISCARDED: InputFloat4
// DISCARDED: InputInt
// DISCARDED: InputInt2
// DISCARDED: InputInt3
// DISCARDED: InputInt4
// DISCARDED: InputScalar
// DISCARDED: InputScalarN
// DISCARDED: InsertChars
// DISCARDED: LabelText
// DISCARDED: LabelTextV
// DISCARDED: LogText
// DISCARDED: LogTextV
// DISCARDED: PassFilter
// DISCARDED: PlotHistogram
// DISCARDED: PlotLines
// DISCARDED: PushID
// DISCARDED: RenderText
// DISCARDED: SetTooltip
// DISCARDED: SetTooltipV
// DISCARDED: SliderAngle
// DISCARDED: SliderFloat
// DISCARDED: SliderFloat2
// DISCARDED: SliderFloat3
// DISCARDED: SliderFloat4
// DISCARDED: SliderInt
// DISCARDED: SliderInt2
// DISCARDED: SliderInt3
// DISCARDED: SliderInt4
// DISCARDED: SliderScalar
// DISCARDED: SliderScalarN
// DISCARDED: Text
// DISCARDED: TextColored
// DISCARDED: TextColoredV
// DISCARDED: TextDisabled
// DISCARDED: TextDisabledV
// DISCARDED: TextUnformatted
// DISCARDED: TextV
// DISCARDED: TextWrapped
// DISCARDED: TextWrappedV
// DISCARDED: TreeNode
// DISCARDED: TreeNodeEx
// DISCARDED: TreeNodeExV
// DISCARDED: TreeNodeV
// DISCARDED: VSliderFloat
// DISCARDED: VSliderInt
// DISCARDED: VSliderScalar

