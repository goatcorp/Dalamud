// <auto-generated/>

using HexaGen.Runtime;
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Dalamud.Bindings.ImGui;

public unsafe partial struct ImGuiTextFilterPtr
{
		public unsafe void Build()
		{
			ImGuiNative.Build(Handle);
		}
		public unsafe void Clear()
		{
			ImGuiNative.Clear(Handle);
		}
		public unsafe void Destroy()
		{
			ImGuiNative.Destroy(Handle);
		}
		public unsafe bool Draw(byte* label, float width)
		{
			byte ret = ImGuiNative.Draw(Handle, label, width);
			return ret != 0;
		}
		public unsafe bool Draw(byte* label)
		{
			byte ret = ImGuiNative.Draw(Handle, label, (float)(0.0f));
			return ret != 0;
		}
		public unsafe bool Draw()
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}
		public unsafe bool Draw(float width)
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", width);
			return ret;
		}
		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Draw(Handle, (byte*)plabel, width);
				return ret != 0;
			}
		}
		public unsafe bool Draw(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiNative.Draw(Handle, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}
		public unsafe bool Draw(ReadOnlySpan<byte> label, float width)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Draw(Handle, (byte*)plabel, width);
				return ret != 0;
			}
		}
		public unsafe bool Draw(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiNative.Draw(Handle, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}
		public unsafe bool Draw(string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Draw(Handle, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public unsafe bool Draw(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiNative.Draw(Handle, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public unsafe bool IsActive()
		{
			byte ret = ImGuiNative.IsActive(Handle);
			return ret != 0;
		}
}
// DISCARDED: PassFilter

