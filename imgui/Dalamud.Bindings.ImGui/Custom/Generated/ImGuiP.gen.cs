// <auto-generated/>

using HexaGen.Runtime;
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Dalamud.Bindings.ImGui;

public unsafe partial class ImGuiP
{
		public static void ImQsort(void* baseValue, nuint count, nuint sizeOfElement, delegate*<void*, nuint, nuint, delegate*<void*, void*, int>, int> compareFunc)
		{
			ImGuiPNative.ImQsort(baseValue, count, sizeOfElement, compareFunc);
		}
		public static uint ImAlphaBlendColors(uint colA, uint colB)
		{
			uint ret = ImGuiPNative.ImAlphaBlendColors(colA, colB);
			return ret;
		}
		public static bool ImIsPowerOfTwo(int v)
		{
			byte ret = ImGuiPNative.ImIsPowerOfTwo(v);
			return ret != 0;
		}
		public static bool ImIsPowerOfTwo(ulong v)
		{
			byte ret = ImGuiPNative.ImIsPowerOfTwo(v);
			return ret != 0;
		}
		public static int ImUpperPowerOfTwo(int v)
		{
			int ret = ImGuiPNative.ImUpperPowerOfTwo(v);
			return ret;
		}
		public static int ImStricmp(byte* str1, byte* str2)
		{
			int ret = ImGuiPNative.ImStricmp(str1, str2);
			return ret;
		}
		public static int ImStricmp(ref byte str1, byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = ImGuiPNative.ImStricmp((byte*)pstr1, str2);
				return ret;
			}
		}
		public static int ImStricmp(ReadOnlySpan<byte> str1, byte* str2)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = ImGuiPNative.ImStricmp((byte*)pstr1, str2);
				return ret;
			}
		}
		public static int ImStricmp(string str1, byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImStricmp(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImStricmp(byte* str1, ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImGuiPNative.ImStricmp(str1, (byte*)pstr2);
				return ret;
			}
		}
		public static int ImStricmp(byte* str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = ImGuiPNative.ImStricmp(str1, (byte*)pstr2);
				return ret;
			}
		}
		public static int ImStricmp(byte* str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImStricmp(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImStricmp(ref byte str1, ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImGuiPNative.ImStricmp((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}
		public static int ImStricmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = ImGuiPNative.ImStricmp((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}
		public static int ImStricmp(string str1, string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiPNative.ImStricmp(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImStricmp(ref byte str1, ReadOnlySpan<byte> str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = ImGuiPNative.ImStricmp((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}
		public static int ImStricmp(ref byte str1, string str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str2 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImStricmp((byte*)pstr1, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStricmp(ReadOnlySpan<byte> str1, ref byte str2)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImGuiPNative.ImStricmp((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}
		public static int ImStricmp(ReadOnlySpan<byte> str1, string str2)
		{
			fixed (byte* pstr1 = str1)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str2 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImStricmp((byte*)pstr1, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStricmp(string str1, ref byte str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImGuiPNative.ImStricmp(pStr0, (byte*)pstr2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStricmp(string str1, ReadOnlySpan<byte> str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr2 = str2)
			{
				int ret = ImGuiPNative.ImStricmp(pStr0, (byte*)pstr2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStrnicmp(byte* str1, byte* str2, nuint count)
		{
			int ret = ImGuiPNative.ImStrnicmp(str1, str2, count);
			return ret;
		}
		public static int ImStrnicmp(ref byte str1, byte* str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, str2, count);
				return ret;
			}
		}
		public static int ImStrnicmp(ReadOnlySpan<byte> str1, byte* str2, nuint count)
		{
			fixed (byte* pstr1 = str1)
			{
				int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, str2, count);
				return ret;
			}
		}
		public static int ImStrnicmp(string str1, byte* str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImStrnicmp(pStr0, str2, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImStrnicmp(byte* str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImGuiPNative.ImStrnicmp(str1, (byte*)pstr2, count);
				return ret;
			}
		}
		public static int ImStrnicmp(byte* str1, ReadOnlySpan<byte> str2, nuint count)
		{
			fixed (byte* pstr2 = str2)
			{
				int ret = ImGuiPNative.ImStrnicmp(str1, (byte*)pstr2, count);
				return ret;
			}
		}
		public static int ImStrnicmp(byte* str1, string str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImStrnicmp(str1, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImStrnicmp(ref byte str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, (byte*)pstr2, count);
					return ret;
				}
			}
		}
		public static int ImStrnicmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2, nuint count)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, (byte*)pstr2, count);
					return ret;
				}
			}
		}
		public static int ImStrnicmp(string str1, string str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiPNative.ImStrnicmp(pStr0, pStr1, count);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImStrnicmp(ref byte str1, ReadOnlySpan<byte> str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = str2)
				{
					int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, (byte*)pstr2, count);
					return ret;
				}
			}
		}
		public static int ImStrnicmp(ref byte str1, string str2, nuint count)
		{
			fixed (byte* pstr1 = &str1)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str2 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, pStr0, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStrnicmp(ReadOnlySpan<byte> str1, ref byte str2, nuint count)
		{
			fixed (byte* pstr1 = str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, (byte*)pstr2, count);
					return ret;
				}
			}
		}
		public static int ImStrnicmp(ReadOnlySpan<byte> str1, string str2, nuint count)
		{
			fixed (byte* pstr1 = str1)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str2 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImStrnicmp((byte*)pstr1, pStr0, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStrnicmp(string str1, ref byte str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImGuiPNative.ImStrnicmp(pStr0, (byte*)pstr2, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStrnicmp(string str1, ReadOnlySpan<byte> str2, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr2 = str2)
			{
				int ret = ImGuiPNative.ImStrnicmp(pStr0, (byte*)pstr2, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void ImStrncpy(byte* dst, byte* src, nuint count)
		{
			ImGuiPNative.ImStrncpy(dst, src, count);
		}
		public static void ImStrncpy(ref byte dst, byte* src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				ImGuiPNative.ImStrncpy((byte*)pdst, src, count);
			}
		}
		public static void ImStrncpy(ref string dst, byte* src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.ImStrncpy(pStr0, src, count);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ImStrncpy(byte* dst, ref byte src, nuint count)
		{
			fixed (byte* psrc = &src)
			{
				ImGuiPNative.ImStrncpy(dst, (byte*)psrc, count);
			}
		}
		public static void ImStrncpy(byte* dst, ReadOnlySpan<byte> src, nuint count)
		{
			fixed (byte* psrc = src)
			{
				ImGuiPNative.ImStrncpy(dst, (byte*)psrc, count);
			}
		}
		public static void ImStrncpy(byte* dst, string src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.ImStrncpy(dst, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ImStrncpy(ref byte dst, ref byte src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					ImGuiPNative.ImStrncpy((byte*)pdst, (byte*)psrc, count);
				}
			}
		}
		public static void ImStrncpy(ref byte dst, ReadOnlySpan<byte> src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = src)
				{
					ImGuiPNative.ImStrncpy((byte*)pdst, (byte*)psrc, count);
				}
			}
		}
		public static void ImStrncpy(ref string dst, string src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiPNative.ImStrncpy(pStr0, pStr1, count);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ImStrncpy(ref byte dst, string src, nuint count)
		{
			fixed (byte* pdst = &dst)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (src != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(src);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.ImStrncpy((byte*)pdst, pStr0, count);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void ImStrncpy(ref string dst, ref byte src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* psrc = &src)
			{
				ImGuiPNative.ImStrncpy(pStr0, (byte*)psrc, count);
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void ImStrncpy(ref string dst, ReadOnlySpan<byte> src, nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* psrc = src)
			{
				ImGuiPNative.ImStrncpy(pStr0, (byte*)psrc, count);
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static byte* ImStrdup(byte* str)
		{
			byte* ret = ImGuiPNative.ImStrdup(str);
			return ret;
		}
		public static byte* ImStrdup(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImGuiPNative.ImStrdup((byte*)pstr);
				return ret;
			}
		}
		public static byte* ImStrdup(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = ImGuiPNative.ImStrdup((byte*)pstr);
				return ret;
			}
		}
		public static byte* ImStrdup(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStrdup(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStrdupS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdup(str));
			return ret;
		}
		public static string ImStrdupS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdup((byte*)pstr));
				return ret;
			}
		}
		public static string ImStrdupS(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdup((byte*)pstr));
				return ret;
			}
		}
		public static string ImStrdupS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdup(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, byte* str)
		{
			byte* ret = ImGuiPNative.ImStrdupcpy(dst, pDstSize, str);
			return ret;
		}
		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				byte* ret = ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, str);
				return ret;
			}
		}
		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, str);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImGuiPNative.ImStrdupcpy(dst, pDstSize, (byte*)pstr);
				return ret;
			}
		}
		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = ImGuiPNative.ImStrdupcpy(dst, pDstSize, (byte*)pstr);
				return ret;
			}
		}
		public static byte* ImStrdupcpy(byte* dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStrdupcpy(dst, pDstSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = &str)
				{
					byte* ret = ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, (byte*)pstr);
					return ret;
				}
			}
		}
		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, ReadOnlySpan<byte> str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = str)
				{
					byte* ret = ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, (byte*)pstr);
					return ret;
				}
			}
		}
		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, pStr1);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStrdupcpy(ref byte dst, nuint* pDstSize, string str)
		{
			fixed (byte* pdst = &dst)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, ref byte str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr = &str)
			{
				byte* ret = ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, (byte*)pstr);
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStrdupcpy(ref string dst, nuint* pDstSize, ReadOnlySpan<byte> str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr = str)
			{
				byte* ret = ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, (byte*)pstr);
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(dst, pDstSize, str));
			return ret;
		}
		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, byte* str)
		{
			fixed (byte* pdst = &dst)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, str));
				return ret;
			}
		}
		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, str));
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(dst, pDstSize, (byte*)pstr));
				return ret;
			}
		}
		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(dst, pDstSize, (byte*)pstr));
				return ret;
			}
		}
		public static string ImStrdupcpyS(byte* dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(dst, pDstSize, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, ref byte str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = &str)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, (byte*)pstr));
					return ret;
				}
			}
		}
		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, ReadOnlySpan<byte> str)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* pstr = str)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, (byte*)pstr));
					return ret;
				}
			}
		}
		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, pStr1));
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStrdupcpyS(ref byte dst, nuint* pDstSize, string str)
		{
			fixed (byte* pdst = &dst)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy((byte*)pdst, pDstSize, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, ref byte str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, (byte*)pstr));
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStrdupcpyS(ref string dst, nuint* pDstSize, ReadOnlySpan<byte> str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrdupcpy(pStr0, pDstSize, (byte*)pstr));
				dst = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImStrlenW(ushort* str)
		{
			int ret = ImGuiPNative.ImStrlenW(str);
			return ret;
		}
		public static ushort* ImStrbolW(ushort* bufMidLine, ushort* bufBegin)
		{
			ushort* ret = ImGuiPNative.ImStrbolW(bufMidLine, bufBegin);
			return ret;
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, needle, needleEnd);
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, needleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, needleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, needleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, needleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, needle, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, needleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, needleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, needleEnd);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, needle, (byte*)pneedleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, needle, (byte*)pneedleEnd);
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, needle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, (byte*)pneedleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, (byte*)pneedleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, needle, (byte*)pneedleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, needle, (byte*)pneedleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, needle, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, needle, (byte*)pneedleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, needle, (byte*)pneedleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, (byte*)pneedleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, (byte*)pneedleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, (byte*)pneedleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, (byte*)pneedleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, pStr1, (byte*)pneedleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(byte* haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(haystack, pStr0, pStr1, (byte*)pneedleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (needleEnd != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(needleEnd, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, pStr3);
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ref byte haystack, string haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, pStr2);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
							return ret;
						}
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, pStr2);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, pStr2);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, pStr2);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, pStr2);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, pStr2);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, (byte*)pneedleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static byte* ImStristr(string haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				byte* ret = ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, (byte*)pneedleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, needle, needleEnd));
			return ret;
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, needleEnd));
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, needleEnd));
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, needleEnd));
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, needleEnd));
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, needle, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, needleEnd));
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, needleEnd));
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, needleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, needleEnd));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, needleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, byte* needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, needleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, needleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, needleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ref byte needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, needleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, needleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, needle, (byte*)pneedleEnd));
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, needle, (byte*)pneedleEnd));
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, needle, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, needle, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, (byte*)pneedleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, needle, (byte*)pneedleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, needle, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, needle, (byte*)pneedleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, needle, (byte*)pneedleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, needle, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, needle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, byte* needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, needle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, byte* needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, needle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, needle, (byte*)pneedleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, byte* needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, needle, (byte*)pneedleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* pneedle = needle)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needleEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, (byte*)pneedle, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, (byte*)pneedleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, haystackEnd, pStr0, (byte*)pneedleEnd));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, byte* haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, haystackEnd, pStr0, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, (byte*)pneedle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, (byte*)pneedleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, byte* haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, haystackEnd, pStr1, (byte*)pneedleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needleEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (needle != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(needle);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, (byte*)phaystackEnd, pStr0, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needleEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, (byte*)pneedle, pStr1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, pStr1, (byte*)pneedleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(byte* haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(haystack, pStr0, pStr1, (byte*)pneedleEnd));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* pStr3 = null;
			int pStrSize3 = 0;
			if (needleEnd != null)
			{
				pStrSize3 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize3 >= Utils.MaxStackallocSize)
				{
					pStr3 = Utils.Alloc<byte>(pStrSize3 + 1);
				}
				else
				{
					byte* pStrStack3 = stackalloc byte[pStrSize3 + 1];
					pStr3 = pStrStack3;
				}
				int pStrOffset3 = Utils.EncodeStringUTF8(needleEnd, pStr3, pStrSize3);
				pStr3[pStrOffset3] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, pStr3));
			if (pStrSize3 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr3);
			}
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ref byte haystack, string haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, pStr2));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = &haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						fixed (byte* pneedleEnd = needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = &needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						fixed (byte* pneedleEnd = &needleEnd)
						{
							string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
							return ret;
						}
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					fixed (byte* pneedle = needle)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (needleEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, (byte*)pneedle, pStr0));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				fixed (byte* phaystackEnd = haystackEnd)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (needle != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(needle);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, (byte*)phaystackEnd, pStr0, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(ReadOnlySpan<byte> haystack, string haystackEnd, string needle, string needleEnd)
		{
			fixed (byte* phaystack = haystack)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (haystackEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr((byte*)phaystack, pStr0, pStr1, pStr2));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ref byte haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, pStr2));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					fixed (byte* pneedleEnd = needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				fixed (byte* pneedle = needle)
				{
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (needleEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, (byte*)pneedle, pStr1));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, ReadOnlySpan<byte> haystackEnd, string needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* phaystackEnd = haystackEnd)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (needle != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(needle);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, (byte*)phaystackEnd, pStr1, pStr2));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ref byte needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ref byte needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ref byte needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = &needle)
			{
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, pStr2));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				fixed (byte* pneedleEnd = needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, (byte*)pneedleEnd));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, ReadOnlySpan<byte> needle, string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pneedle = needle)
			{
				byte* pStr2 = null;
				int pStrSize2 = 0;
				if (needleEnd != null)
				{
					pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
					if (pStrSize2 >= Utils.MaxStackallocSize)
					{
						pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
					}
					else
					{
						byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
						pStr2 = pStrStack2;
					}
					int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
					pStr2[pStrOffset2] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, (byte*)pneedle, pStr2));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, string needle, ref byte needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, (byte*)pneedleEnd));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static string ImStristrS(string haystack, string haystackEnd, string needle, ReadOnlySpan<byte> needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (haystackEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(haystackEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needle != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needle);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needle, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			fixed (byte* pneedleEnd = needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStristr(pStr0, pStr1, pStr2, (byte*)pneedleEnd));
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr2);
				}
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void ImStrTrimBlanks(byte* str)
		{
			ImGuiPNative.ImStrTrimBlanks(str);
		}
		public static void ImStrTrimBlanks(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				ImGuiPNative.ImStrTrimBlanks((byte*)pstr);
			}
		}
		public static void ImStrTrimBlanks(ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.ImStrTrimBlanks(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static byte* ImStrSkipBlank(byte* str)
		{
			byte* ret = ImGuiPNative.ImStrSkipBlank(str);
			return ret;
		}
		public static byte* ImStrSkipBlank(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImGuiPNative.ImStrSkipBlank((byte*)pstr);
				return ret;
			}
		}
		public static byte* ImStrSkipBlank(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				byte* ret = ImGuiPNative.ImStrSkipBlank((byte*)pstr);
				return ret;
			}
		}
		public static byte* ImStrSkipBlank(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImStrSkipBlank(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImStrSkipBlankS(byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrSkipBlank(str));
			return ret;
		}
		public static string ImStrSkipBlankS(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrSkipBlank((byte*)pstr));
				return ret;
			}
		}
		public static string ImStrSkipBlankS(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrSkipBlank((byte*)pstr));
				return ret;
			}
		}
		public static string ImStrSkipBlankS(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImStrSkipBlank(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static bool ImCharIsBlankA(byte c)
		{
			byte ret = ImGuiPNative.ImCharIsBlankA(c);
			return ret != 0;
		}
		public static bool ImCharIsBlankW(uint c)
		{
			byte ret = ImGuiPNative.ImCharIsBlankW(c);
			return ret != 0;
		}
		public static byte* ImParseFormatFindStart(byte* format)
		{
			byte* ret = ImGuiPNative.ImParseFormatFindStart(format);
			return ret;
		}
		public static byte* ImParseFormatFindStart(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImGuiPNative.ImParseFormatFindStart((byte*)pformat);
				return ret;
			}
		}
		public static byte* ImParseFormatFindStart(ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				byte* ret = ImGuiPNative.ImParseFormatFindStart((byte*)pformat);
				return ret;
			}
		}
		public static byte* ImParseFormatFindStart(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImParseFormatFindStart(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImParseFormatFindStartS(byte* format)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindStart(format));
			return ret;
		}
		public static string ImParseFormatFindStartS(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindStart((byte*)pformat));
				return ret;
			}
		}
		public static string ImParseFormatFindStartS(ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindStart((byte*)pformat));
				return ret;
			}
		}
		public static string ImParseFormatFindStartS(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindStart(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImParseFormatFindEnd(byte* format)
		{
			byte* ret = ImGuiPNative.ImParseFormatFindEnd(format);
			return ret;
		}
		public static byte* ImParseFormatFindEnd(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte* ret = ImGuiPNative.ImParseFormatFindEnd((byte*)pformat);
				return ret;
			}
		}
		public static byte* ImParseFormatFindEnd(ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				byte* ret = ImGuiPNative.ImParseFormatFindEnd((byte*)pformat);
				return ret;
			}
		}
		public static byte* ImParseFormatFindEnd(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiPNative.ImParseFormatFindEnd(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static string ImParseFormatFindEndS(byte* format)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindEnd(format));
			return ret;
		}
		public static string ImParseFormatFindEndS(ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindEnd((byte*)pformat));
				return ret;
			}
		}
		public static string ImParseFormatFindEndS(ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindEnd((byte*)pformat));
				return ret;
			}
		}
		public static string ImParseFormatFindEndS(string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImParseFormatFindEnd(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImParseFormatPrecision(byte* format, int defaultValue)
		{
			int ret = ImGuiPNative.ImParseFormatPrecision(format, defaultValue);
			return ret;
		}
		public static int ImParseFormatPrecision(ref byte format, int defaultValue)
		{
			fixed (byte* pformat = &format)
			{
				int ret = ImGuiPNative.ImParseFormatPrecision((byte*)pformat, defaultValue);
				return ret;
			}
		}
		public static int ImParseFormatPrecision(ReadOnlySpan<byte> format, int defaultValue)
		{
			fixed (byte* pformat = format)
			{
				int ret = ImGuiPNative.ImParseFormatPrecision((byte*)pformat, defaultValue);
				return ret;
			}
		}
		public static int ImParseFormatPrecision(string format, int defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImParseFormatPrecision(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static byte* ImTextCharToUtf8(byte* outBuf, uint c)
		{
			byte* ret = ImGuiPNative.ImTextCharToUtf8(outBuf, c);
			return ret;
		}
		public static byte* ImTextCharToUtf8(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				byte* ret = ImGuiPNative.ImTextCharToUtf8((byte*)poutBuf, c);
				return ret;
			}
		}
		public static byte* ImTextCharToUtf8(ReadOnlySpan<byte> outBuf, uint c)
		{
			fixed (byte* poutBuf = outBuf)
			{
				byte* ret = ImGuiPNative.ImTextCharToUtf8((byte*)poutBuf, c);
				return ret;
			}
		}
		public static string ImTextCharToUtf8S(byte* outBuf, uint c)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImTextCharToUtf8(outBuf, c));
			return ret;
		}
		public static string ImTextCharToUtf8S(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImTextCharToUtf8((byte*)poutBuf, c));
				return ret;
			}
		}
		public static string ImTextCharToUtf8S(ReadOnlySpan<byte> outBuf, uint c)
		{
			fixed (byte* poutBuf = outBuf)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.ImTextCharToUtf8((byte*)poutBuf, c));
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, byte* inTextEnd)
		{
			int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, inText, inTextEnd);
			return ret;
		}
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, inText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, inTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, inTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, pStr0, inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, inText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, inText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, inText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, string inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, (byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, string inText, ref byte inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(uint* outChar, string inText, ReadOnlySpan<byte> inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCharFromUtf8(outChar, pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					fixed (byte* pinTextEnd = inTextEnd)
					{
						int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = inTextEnd)
					{
						int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (inTextEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (inTextEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, (byte*)pinText, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, pStr0, (byte*)pinTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCharFromUtf8((uint*)poutChar, pStr0, (byte*)pinTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}
		public static int ImTextCountCharsFromUtf8(byte* inText, byte* inTextEnd)
		{
			int ret = ImGuiPNative.ImTextCountCharsFromUtf8(inText, inTextEnd);
			return ret;
		}
		public static int ImTextCountCharsFromUtf8(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImTextCountCharsFromUtf8(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCountCharsFromUtf8(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8(inText, (byte*)pinTextEnd);
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8(inText, (byte*)pinTextEnd);
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImTextCountCharsFromUtf8(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCountCharsFromUtf8(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountCharsFromUtf8(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiPNative.ImTextCountCharsFromUtf8(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCountCharsFromUtf8(ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountCharsFromUtf8(ref byte inText, string inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(string inText, ref byte inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountCharsFromUtf8(string inText, ReadOnlySpan<byte> inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountCharsFromUtf8(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(byte* inText, byte* inTextEnd)
		{
			int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(inText, inTextEnd);
			return ret;
		}
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, inTextEnd);
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCountUtf8BytesFromChar(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(inText, (byte*)pinTextEnd);
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(inText, (byte*)pinTextEnd);
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountUtf8BytesFromChar(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, string inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(string inText, ref byte inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromChar(string inText, ReadOnlySpan<byte> inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImGuiPNative.ImTextCountUtf8BytesFromChar(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int ImTextCountUtf8BytesFromStr(ushort* inText, ushort* inTextEnd)
		{
			int ret = ImGuiPNative.ImTextCountUtf8BytesFromStr(inText, inTextEnd);
			return ret;
		}
		public static ImFileHandle ImFileOpen(byte* filename, byte* mode)
		{
			ImFileHandle ret = ImGuiPNative.ImFileOpen(filename, mode);
			return ret;
		}
		public static ImFileHandle ImFileOpen(ref byte filename, byte* mode)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, mode);
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, byte* mode)
		{
			fixed (byte* pfilename = filename)
			{
				ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, mode);
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(string filename, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImGuiPNative.ImFileOpen(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImFileHandle ImFileOpen(byte* filename, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImGuiPNative.ImFileOpen(filename, (byte*)pmode);
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(byte* filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				ImFileHandle ret = ImGuiPNative.ImFileOpen(filename, (byte*)pmode);
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(byte* filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImGuiPNative.ImFileOpen(filename, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImFileHandle ImFileOpen(ref byte filename, ref byte mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}
		public static ImFileHandle ImFileOpen(string filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImFileHandle ret = ImGuiPNative.ImFileOpen(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImFileHandle ImFileOpen(ref byte filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}
		public static ImFileHandle ImFileOpen(ref byte filename, string mode)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, ref byte mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, string mode)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFileHandle ret = ImGuiPNative.ImFileOpen((byte*)pfilename, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(string filename, ref byte mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImGuiPNative.ImFileOpen(pStr0, (byte*)pmode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static ImFileHandle ImFileOpen(string filename, ReadOnlySpan<byte> mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				ImFileHandle ret = ImGuiPNative.ImFileOpen(pStr0, (byte*)pmode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static bool ImFileClose(ImFileHandle file)
		{
			byte ret = ImGuiPNative.ImFileClose(file);
			return ret != 0;
		}
		public static ulong ImFileGetSize(ImFileHandle file)
		{
			ulong ret = ImGuiPNative.ImFileGetSize(file);
			return ret;
		}
		public static ulong ImFileRead(void* data, ulong size, ulong count, ImFileHandle file)
		{
			ulong ret = ImGuiPNative.ImFileRead(data, size, count, file);
			return ret;
		}
		public static ulong ImFileWrite(void* data, ulong size, ulong count, ImFileHandle file)
		{
			ulong ret = ImGuiPNative.ImFileWrite(data, size, count, file);
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, mode, outFileSize, paddingBytes);
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, byte* mode, nuint* outFileSize)
		{
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, mode, outFileSize, (int)(0));
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, byte* mode)
		{
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, mode, (nuint*)(default), (int)(0));
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, byte* mode, int paddingBytes)
		{
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, mode, (nuint*)(default), paddingBytes);
			return ret;
		}
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, outFileSize, paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, outFileSize, (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, (nuint*)(default), (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, (nuint*)(default), paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, outFileSize, paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, outFileSize, (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, (nuint*)(default), (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, mode, (nuint*)(default), paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, byte* mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, mode, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(string filename, byte* mode, nuint* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, mode, outFileSize, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(string filename, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, mode, (nuint*)(default), (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(string filename, byte* mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, mode, (nuint*)(default), paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, nuint* outFileSize)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, outFileSize, (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, (nuint*)(default), (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, (nuint*)(default), paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode, nuint* outFileSize)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, outFileSize, (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, (nuint*)(default), (int)(0));
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(filename, (byte*)pmode, (nuint*)(default), paddingBytes);
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(byte* filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, pStr0, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, string mode, nuint* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, pStr0, outFileSize, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, pStr0, (nuint*)(default), (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(byte* filename, string mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(filename, pStr0, (nuint*)(default), paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(string filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, pStr1, outFileSize, paddingBytes);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(string filename, string mode, nuint* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, pStr1, outFileSize, (int)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(string filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, pStr1, (nuint*)(default), (int)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(string filename, string mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, pStr1, (nuint*)(default), paddingBytes);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, string mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, string mode)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, (nuint*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ref byte filename, string mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, (nuint*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), (int)(0));
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, (byte*)pmode, (nuint*)(default), paddingBytes);
					return ret;
				}
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode, nuint* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode, nuint* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, (nuint*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImGuiPNative.ImFileLoadToMemory((byte*)pfilename, pStr0, (nuint*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ref byte mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ref byte mode, nuint* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ref byte mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, (nuint*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ref byte mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, (nuint*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode, nuint* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode, nuint* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, (nuint*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImGuiPNative.ImFileLoadToMemory(pStr0, (byte*)pmode, (nuint*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static float ImPow(float x, float y)
		{
			float ret = ImGuiPNative.ImPow(x, y);
			return ret;
		}
		public static double ImPow(double x, double y)
		{
			double ret = ImGuiPNative.ImPow(x, y);
			return ret;
		}
		public static float ImLog(float x)
		{
			float ret = ImGuiPNative.ImLog(x);
			return ret;
		}
		public static double ImLog(double x)
		{
			double ret = ImGuiPNative.ImLog(x);
			return ret;
		}
		public static int ImAbs(int x)
		{
			int ret = ImGuiPNative.ImAbs(x);
			return ret;
		}
		public static float ImAbs(float x)
		{
			float ret = ImGuiPNative.ImAbs(x);
			return ret;
		}
		public static double ImAbs(double x)
		{
			double ret = ImGuiPNative.ImAbs(x);
			return ret;
		}
		public static float ImSign(float x)
		{
			float ret = ImGuiPNative.ImSign(x);
			return ret;
		}
		public static double ImSign(double x)
		{
			double ret = ImGuiPNative.ImSign(x);
			return ret;
		}
		public static float ImRsqrt(float x)
		{
			float ret = ImGuiPNative.ImRsqrt(x);
			return ret;
		}
		public static double ImRsqrt(double x)
		{
			double ret = ImGuiPNative.ImRsqrt(x);
			return ret;
		}
		public static Vector2 ImMin(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImGuiPNative.ImMin(&ret, lhs, rhs);
			return ret;
		}
		public static void ImMin(Vector2* pOut, Vector2 lhs, Vector2 rhs)
		{
			ImGuiPNative.ImMin(pOut, lhs, rhs);
		}
		public static void ImMin(ref Vector2 pOut, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImMin((Vector2*)ppOut, lhs, rhs);
			}
		}
		public static Vector2 ImMax(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImGuiPNative.ImMax(&ret, lhs, rhs);
			return ret;
		}
		public static void ImMax(Vector2* pOut, Vector2 lhs, Vector2 rhs)
		{
			ImGuiPNative.ImMax(pOut, lhs, rhs);
		}
		public static void ImMax(ref Vector2 pOut, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImMax((Vector2*)ppOut, lhs, rhs);
			}
		}
		public static Vector2 ImClamp(Vector2 v, Vector2 mn, Vector2 mx)
		{
			Vector2 ret;
			ImGuiPNative.ImClamp(&ret, v, mn, mx);
			return ret;
		}
		public static void ImClamp(Vector2* pOut, Vector2 v, Vector2 mn, Vector2 mx)
		{
			ImGuiPNative.ImClamp(pOut, v, mn, mx);
		}
		public static void ImClamp(ref Vector2 pOut, Vector2 v, Vector2 mn, Vector2 mx)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImClamp((Vector2*)ppOut, v, mn, mx);
			}
		}
		public static Vector2 ImLerp(Vector2 a, Vector2 b, float t)
		{
			Vector2 ret;
			ImGuiPNative.ImLerp(&ret, a, b, t);
			return ret;
		}
		public static void ImLerp(Vector2* pOut, Vector2 a, Vector2 b, float t)
		{
			ImGuiPNative.ImLerp(pOut, a, b, t);
		}
		public static void ImLerp(ref Vector2 pOut, Vector2 a, Vector2 b, float t)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImLerp((Vector2*)ppOut, a, b, t);
			}
		}
		public static Vector2 ImLerp(Vector2 a, Vector2 b, Vector2 t)
		{
			Vector2 ret;
			ImGuiPNative.ImLerp(&ret, a, b, t);
			return ret;
		}
		public static void ImLerp(Vector2* pOut, Vector2 a, Vector2 b, Vector2 t)
		{
			ImGuiPNative.ImLerp(pOut, a, b, t);
		}
		public static void ImLerp(ref Vector2 pOut, Vector2 a, Vector2 b, Vector2 t)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImLerp((Vector2*)ppOut, a, b, t);
			}
		}
		public static Vector4 ImLerp(Vector4 a, Vector4 b, float t)
		{
			Vector4 ret;
			ImGuiPNative.ImLerp(&ret, a, b, t);
			return ret;
		}
		public static void ImLerp(Vector4* pOut, Vector4 a, Vector4 b, float t)
		{
			ImGuiPNative.ImLerp(pOut, a, b, t);
		}
		public static void ImLerp(ref Vector4 pOut, Vector4 a, Vector4 b, float t)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ImGuiPNative.ImLerp((Vector4*)ppOut, a, b, t);
			}
		}
		public static float ImSaturate(float f)
		{
			float ret = ImGuiPNative.ImSaturate(f);
			return ret;
		}
		public static float ImLengthSqr(Vector2 lhs)
		{
			float ret = ImGuiPNative.ImLengthSqr(lhs);
			return ret;
		}
		public static float ImLengthSqr(Vector4 lhs)
		{
			float ret = ImGuiPNative.ImLengthSqr(lhs);
			return ret;
		}
		public static float ImInvLength(Vector2 lhs, float failValue)
		{
			float ret = ImGuiPNative.ImInvLength(lhs, failValue);
			return ret;
		}
		public static float ImFloor(float f)
		{
			float ret = ImGuiPNative.ImFloor(f);
			return ret;
		}
		public static Vector2 ImFloor(Vector2 v)
		{
			Vector2 ret;
			ImGuiPNative.ImFloor(&ret, v);
			return ret;
		}
		public static void ImFloor(Vector2* pOut, Vector2 v)
		{
			ImGuiPNative.ImFloor(pOut, v);
		}
		public static void ImFloor(ref Vector2 pOut, Vector2 v)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImFloor((Vector2*)ppOut, v);
			}
		}
		public static float ImFloorSigned(float f)
		{
			float ret = ImGuiPNative.ImFloorSigned(f);
			return ret;
		}
		public static Vector2 ImFloorSigned(Vector2 v)
		{
			Vector2 ret;
			ImGuiPNative.ImFloorSigned(&ret, v);
			return ret;
		}
		public static void ImFloorSigned(Vector2* pOut, Vector2 v)
		{
			ImGuiPNative.ImFloorSigned(pOut, v);
		}
		public static void ImFloorSigned(ref Vector2 pOut, Vector2 v)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImFloorSigned((Vector2*)ppOut, v);
			}
		}
		public static int ImModPositive(int a, int b)
		{
			int ret = ImGuiPNative.ImModPositive(a, b);
			return ret;
		}
		public static float ImDot(Vector2 a, Vector2 b)
		{
			float ret = ImGuiPNative.ImDot(a, b);
			return ret;
		}
		public static Vector2 ImRotate(Vector2 v, float cosA, float sinA)
		{
			Vector2 ret;
			ImGuiPNative.ImRotate(&ret, v, cosA, sinA);
			return ret;
		}
		public static void ImRotate(Vector2* pOut, Vector2 v, float cosA, float sinA)
		{
			ImGuiPNative.ImRotate(pOut, v, cosA, sinA);
		}
		public static void ImRotate(ref Vector2 pOut, Vector2 v, float cosA, float sinA)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImRotate((Vector2*)ppOut, v, cosA, sinA);
			}
		}
		public static float ImLinearSweep(float current, float target, float speed)
		{
			float ret = ImGuiPNative.ImLinearSweep(current, target, speed);
			return ret;
		}
		public static Vector2 ImMul(Vector2 lhs, Vector2 rhs)
		{
			Vector2 ret;
			ImGuiPNative.ImMul(&ret, lhs, rhs);
			return ret;
		}
		public static void ImMul(Vector2* pOut, Vector2 lhs, Vector2 rhs)
		{
			ImGuiPNative.ImMul(pOut, lhs, rhs);
		}
		public static void ImMul(ref Vector2 pOut, Vector2 lhs, Vector2 rhs)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImMul((Vector2*)ppOut, lhs, rhs);
			}
		}
		public static bool ImIsFloatAboveGuaranteedIntegerPrecision(float f)
		{
			byte ret = ImGuiPNative.ImIsFloatAboveGuaranteedIntegerPrecision(f);
			return ret != 0;
		}
		public static Vector2 ImBezierCubicCalc(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			Vector2 ret;
			ImGuiPNative.ImBezierCubicCalc(&ret, p1, p2, p3, p4, t);
			return ret;
		}
		public static void ImBezierCubicCalc(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			ImGuiPNative.ImBezierCubicCalc(pOut, p1, p2, p3, p4, t);
		}
		public static void ImBezierCubicCalc(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImBezierCubicCalc((Vector2*)ppOut, p1, p2, p3, p4, t);
			}
		}
		public static Vector2 ImBezierCubicClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			Vector2 ret;
			ImGuiPNative.ImBezierCubicClosestPoint(&ret, p1, p2, p3, p4, p, numSegments);
			return ret;
		}
		public static void ImBezierCubicClosestPoint(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			ImGuiPNative.ImBezierCubicClosestPoint(pOut, p1, p2, p3, p4, p, numSegments);
		}
		public static void ImBezierCubicClosestPoint(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImBezierCubicClosestPoint((Vector2*)ppOut, p1, p2, p3, p4, p, numSegments);
			}
		}
		public static Vector2 ImBezierCubicClosestPointCasteljau(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			Vector2 ret;
			ImGuiPNative.ImBezierCubicClosestPointCasteljau(&ret, p1, p2, p3, p4, p, tessTol);
			return ret;
		}
		public static void ImBezierCubicClosestPointCasteljau(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			ImGuiPNative.ImBezierCubicClosestPointCasteljau(pOut, p1, p2, p3, p4, p, tessTol);
		}
		public static void ImBezierCubicClosestPointCasteljau(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImBezierCubicClosestPointCasteljau((Vector2*)ppOut, p1, p2, p3, p4, p, tessTol);
			}
		}
		public static Vector2 ImBezierQuadraticCalc(Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			Vector2 ret;
			ImGuiPNative.ImBezierQuadraticCalc(&ret, p1, p2, p3, t);
			return ret;
		}
		public static void ImBezierQuadraticCalc(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			ImGuiPNative.ImBezierQuadraticCalc(pOut, p1, p2, p3, t);
		}
		public static void ImBezierQuadraticCalc(ref Vector2 pOut, Vector2 p1, Vector2 p2, Vector2 p3, float t)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImBezierQuadraticCalc((Vector2*)ppOut, p1, p2, p3, t);
			}
		}
		public static Vector2 ImLineClosestPoint(Vector2 a, Vector2 b, Vector2 p)
		{
			Vector2 ret;
			ImGuiPNative.ImLineClosestPoint(&ret, a, b, p);
			return ret;
		}
		public static void ImLineClosestPoint(Vector2* pOut, Vector2 a, Vector2 b, Vector2 p)
		{
			ImGuiPNative.ImLineClosestPoint(pOut, a, b, p);
		}
		public static void ImLineClosestPoint(ref Vector2 pOut, Vector2 a, Vector2 b, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImLineClosestPoint((Vector2*)ppOut, a, b, p);
			}
		}
		public static bool ImTriangleContainsPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			byte ret = ImGuiPNative.ImTriangleContainsPoint(a, b, c, p);
			return ret != 0;
		}
		public static Vector2 ImTriangleClosestPoint(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			Vector2 ret;
			ImGuiPNative.ImTriangleClosestPoint(&ret, a, b, c, p);
			return ret;
		}
		public static void ImTriangleClosestPoint(Vector2* pOut, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			ImGuiPNative.ImTriangleClosestPoint(pOut, a, b, c, p);
		}
		public static void ImTriangleClosestPoint(ref Vector2 pOut, Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ImTriangleClosestPoint((Vector2*)ppOut, a, b, c, p);
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW)
		{
			ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, outU, outV, outW);
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, outV, outW);
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, float* outW)
		{
			fixed (float* poutV = &outV)
			{
				ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, outU, (float*)poutV, outW);
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, float* outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, (float*)poutV, outW);
				}
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, ref float outW)
		{
			fixed (float* poutW = &outW)
			{
				ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, outU, outV, (float*)poutW);
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, float* outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutW = &outW)
				{
					ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, outV, (float*)poutW);
				}
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, ref float outV, ref float outW)
		{
			fixed (float* poutV = &outV)
			{
				fixed (float* poutW = &outW)
				{
					ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, outU, (float*)poutV, (float*)poutW);
				}
			}
		}
		public static void ImTriangleBarycentricCoords(Vector2 a, Vector2 b, Vector2 c, Vector2 p, ref float outU, ref float outV, ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					fixed (float* poutW = &outW)
					{
						ImGuiPNative.ImTriangleBarycentricCoords(a, b, c, p, (float*)poutU, (float*)poutV, (float*)poutW);
					}
				}
			}
		}
		public static float ImTriangleArea(Vector2 a, Vector2 b, Vector2 c)
		{
			float ret = ImGuiPNative.ImTriangleArea(a, b, c);
			return ret;
		}
		public static ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
		{
			ImGuiDir ret = ImGuiPNative.ImGetDirQuadrantFromDelta(dx, dy);
			return ret;
		}
		public static ImVec1Ptr ImVec1()
		{
			ImVec1Ptr ret = ImGuiPNative.ImVec1();
			return ret;
		}
		public static ImVec1Ptr ImVec1(float x)
		{
			ImVec1Ptr ret = ImGuiPNative.ImVec1(x);
			return ret;
		}
		public static ImVec2IhPtr ImVec2ih()
		{
			ImVec2IhPtr ret = ImGuiPNative.ImVec2ih();
			return ret;
		}
		public static ImVec2IhPtr ImVec2ih(short x, short y)
		{
			ImVec2IhPtr ret = ImGuiPNative.ImVec2ih(x, y);
			return ret;
		}
		public static ImVec2IhPtr ImVec2ih(Vector2 rhs)
		{
			ImVec2IhPtr ret = ImGuiPNative.ImVec2ih(rhs);
			return ret;
		}
		public static ImRectPtr ImRect()
		{
			ImRectPtr ret = ImGuiPNative.ImRect();
			return ret;
		}
		public static ImRectPtr ImRect(Vector2 min, Vector2 max)
		{
			ImRectPtr ret = ImGuiPNative.ImRect(min, max);
			return ret;
		}
		public static ImRectPtr ImRect(Vector4 v)
		{
			ImRectPtr ret = ImGuiPNative.ImRect(v);
			return ret;
		}
		public static ImRectPtr ImRect(float x1, float y1, float x2, float y2)
		{
			ImRectPtr ret = ImGuiPNative.ImRect(x1, y1, x2, y2);
			return ret;
		}
		public static Vector2 GetCenter(ImRectPtr self)
		{
			Vector2 ret;
			ImGuiPNative.GetCenter(&ret, self);
			return ret;
		}
		public static void GetCenter(Vector2* pOut, ImRectPtr self)
		{
			ImGuiPNative.GetCenter(pOut, self);
		}
		public static void GetCenter(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetCenter((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetCenter(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.GetCenter(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void GetCenter(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.GetCenter(pOut, (ImRect*)pself);
			}
		}
		public static void GetCenter(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.GetCenter((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static Vector2 GetSize(ImRectPtr self)
		{
			Vector2 ret;
			ImGuiPNative.GetSize(&ret, self);
			return ret;
		}
		public static void GetSize(Vector2* pOut, ImRectPtr self)
		{
			ImGuiPNative.GetSize(pOut, self);
		}
		public static void GetSize(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetSize((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetSize(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.GetSize(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void GetSize(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.GetSize(pOut, (ImRect*)pself);
			}
		}
		public static void GetSize(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.GetSize((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static float GetWidth(ImRectPtr self)
		{
			float ret = ImGuiPNative.GetWidth(self);
			return ret;
		}
		public static float GetWidth(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImGuiPNative.GetWidth((ImRect*)pself);
				return ret;
			}
		}
		public static float GetHeight(ImRectPtr self)
		{
			float ret = ImGuiPNative.GetHeight(self);
			return ret;
		}
		public static float GetHeight(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImGuiPNative.GetHeight((ImRect*)pself);
				return ret;
			}
		}
		public static float GetArea(ImRectPtr self)
		{
			float ret = ImGuiPNative.GetArea(self);
			return ret;
		}
		public static float GetArea(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				float ret = ImGuiPNative.GetArea((ImRect*)pself);
				return ret;
			}
		}
		public static Vector2 GetTL(ImRectPtr self)
		{
			Vector2 ret;
			ImGuiPNative.GetTL(&ret, self);
			return ret;
		}
		public static void GetTL(Vector2* pOut, ImRectPtr self)
		{
			ImGuiPNative.GetTL(pOut, self);
		}
		public static void GetTL(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetTL((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetTL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.GetTL(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void GetTL(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.GetTL(pOut, (ImRect*)pself);
			}
		}
		public static void GetTL(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.GetTL((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static Vector2 GetTR(ImRectPtr self)
		{
			Vector2 ret;
			ImGuiPNative.GetTR(&ret, self);
			return ret;
		}
		public static void GetTR(Vector2* pOut, ImRectPtr self)
		{
			ImGuiPNative.GetTR(pOut, self);
		}
		public static void GetTR(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetTR((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetTR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.GetTR(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void GetTR(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.GetTR(pOut, (ImRect*)pself);
			}
		}
		public static void GetTR(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.GetTR((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static Vector2 GetBL(ImRectPtr self)
		{
			Vector2 ret;
			ImGuiPNative.GetBL(&ret, self);
			return ret;
		}
		public static void GetBL(Vector2* pOut, ImRectPtr self)
		{
			ImGuiPNative.GetBL(pOut, self);
		}
		public static void GetBL(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetBL((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetBL(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.GetBL(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void GetBL(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.GetBL(pOut, (ImRect*)pself);
			}
		}
		public static void GetBL(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.GetBL((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static Vector2 GetBR(ImRectPtr self)
		{
			Vector2 ret;
			ImGuiPNative.GetBR(&ret, self);
			return ret;
		}
		public static void GetBR(Vector2* pOut, ImRectPtr self)
		{
			ImGuiPNative.GetBR(pOut, self);
		}
		public static void GetBR(ref Vector2 pOut, ImRectPtr self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetBR((Vector2*)ppOut, self);
			}
		}
		public static Vector2 GetBR(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.GetBR(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void GetBR(Vector2* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.GetBR(pOut, (ImRect*)pself);
			}
		}
		public static void GetBR(ref Vector2 pOut, ref ImRect self)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.GetBR((Vector2*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static bool Contains(ImRectPtr self, Vector2 p)
		{
			byte ret = ImGuiPNative.Contains(self, p);
			return ret != 0;
		}
		public static bool Contains(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImGuiPNative.Contains((ImRect*)pself, p);
				return ret != 0;
			}
		}
		public static bool Contains(ImRectPtr self, ImRect r)
		{
			byte ret = ImGuiPNative.Contains(self, r);
			return ret != 0;
		}
		public static bool Contains(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImGuiPNative.Contains((ImRect*)pself, r);
				return ret != 0;
			}
		}
		public static bool Overlaps(ImRectPtr self, ImRect r)
		{
			byte ret = ImGuiPNative.Overlaps(self, r);
			return ret != 0;
		}
		public static bool Overlaps(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImGuiPNative.Overlaps((ImRect*)pself, r);
				return ret != 0;
			}
		}
		public static void Add(ImRectPtr self, Vector2 p)
		{
			ImGuiPNative.Add(self, p);
		}
		public static void Add(ref ImRect self, Vector2 p)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.Add((ImRect*)pself, p);
			}
		}
		public static void Add(ImRectPtr self, ImRect r)
		{
			ImGuiPNative.Add(self, r);
		}
		public static void Add(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.Add((ImRect*)pself, r);
			}
		}
		public static void Expand(ImRectPtr self, float amount)
		{
			ImGuiPNative.Expand(self, amount);
		}
		public static void Expand(ref ImRect self, float amount)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.Expand((ImRect*)pself, amount);
			}
		}
		public static void Expand(ImRectPtr self, Vector2 amount)
		{
			ImGuiPNative.Expand(self, amount);
		}
		public static void Expand(ref ImRect self, Vector2 amount)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.Expand((ImRect*)pself, amount);
			}
		}
		public static void Translate(ImRectPtr self, Vector2 d)
		{
			ImGuiPNative.Translate(self, d);
		}
		public static void Translate(ref ImRect self, Vector2 d)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.Translate((ImRect*)pself, d);
			}
		}
		public static void TranslateX(ImRectPtr self, float dx)
		{
			ImGuiPNative.TranslateX(self, dx);
		}
		public static void TranslateX(ref ImRect self, float dx)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.TranslateX((ImRect*)pself, dx);
			}
		}
		public static void TranslateY(ImRectPtr self, float dy)
		{
			ImGuiPNative.TranslateY(self, dy);
		}
		public static void TranslateY(ref ImRect self, float dy)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.TranslateY((ImRect*)pself, dy);
			}
		}
		public static void ClipWith(ImRectPtr self, ImRect r)
		{
			ImGuiPNative.ClipWith(self, r);
		}
		public static void ClipWith(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.ClipWith((ImRect*)pself, r);
			}
		}
		public static void ClipWithFull(ImRectPtr self, ImRect r)
		{
			ImGuiPNative.ClipWithFull(self, r);
		}
		public static void ClipWithFull(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.ClipWithFull((ImRect*)pself, r);
			}
		}
		public static void Floor(ImRectPtr self)
		{
			ImGuiPNative.Floor(self);
		}
		public static void Floor(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.Floor((ImRect*)pself);
			}
		}
		public static bool IsInverted(ImRectPtr self)
		{
			byte ret = ImGuiPNative.IsInverted(self);
			return ret != 0;
		}
		public static bool IsInverted(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = ImGuiPNative.IsInverted((ImRect*)pself);
				return ret != 0;
			}
		}
		public static Vector4 ToVec4(ImRectPtr self)
		{
			Vector4 ret;
			ImGuiPNative.ToVec4(&ret, self);
			return ret;
		}
		public static void ToVec4(Vector4* pOut, ImRectPtr self)
		{
			ImGuiPNative.ToVec4(pOut, self);
		}
		public static void ToVec4(ref Vector4 pOut, ImRectPtr self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ImGuiPNative.ToVec4((Vector4*)ppOut, self);
			}
		}
		public static Vector4 ToVec4(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector4 ret;
				ImGuiPNative.ToVec4(&ret, (ImRect*)pself);
				return ret;
			}
		}
		public static void ToVec4(Vector4* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImGuiPNative.ToVec4(pOut, (ImRect*)pself);
			}
		}
		public static void ToVec4(ref Vector4 pOut, ref ImRect self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ImGuiPNative.ToVec4((Vector4*)ppOut, (ImRect*)pself);
				}
			}
		}
		public static bool ImBitArrayTestBit(uint* arr, int n)
		{
			byte ret = ImGuiPNative.ImBitArrayTestBit(arr, n);
			return ret != 0;
		}
		public static void ImBitArrayClearBit(uint* arr, int n)
		{
			ImGuiPNative.ImBitArrayClearBit(arr, n);
		}
		public static void ImBitArraySetBit(uint* arr, int n)
		{
			ImGuiPNative.ImBitArraySetBit(arr, n);
		}
		public static void ImBitArraySetBitRange(uint* arr, int n, int n2)
		{
			ImGuiPNative.ImBitArraySetBitRange(arr, n, n2);
		}
		public static void Create(ImBitVectorPtr self, int sz)
		{
			ImGuiPNative.Create(self, sz);
		}
		public static void Create(ref ImBitVector self, int sz)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImGuiPNative.Create((ImBitVector*)pself, sz);
			}
		}
		public static void Clear(ImBitVectorPtr self)
		{
			ImGuiPNative.Clear(self);
		}
		public static void Clear(ref ImBitVector self)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImGuiPNative.Clear((ImBitVector*)pself);
			}
		}
		public static void Clear(ImDrawDataBuilderPtr self)
		{
			ImGuiPNative.Clear(self);
		}
		public static void Clear(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImGuiPNative.Clear((ImDrawDataBuilder*)pself);
			}
		}
		public static void Clear(ImGuiNavItemDataPtr self)
		{
			ImGuiPNative.Clear(self);
		}
		public static void Clear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ImGuiPNative.Clear((ImGuiNavItemData*)pself);
			}
		}
		public static bool TestBit(ImBitVectorPtr self, int n)
		{
			byte ret = ImGuiPNative.TestBit(self, n);
			return ret != 0;
		}
		public static bool TestBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				byte ret = ImGuiPNative.TestBit((ImBitVector*)pself, n);
				return ret != 0;
			}
		}
		public static void SetBit(ImBitVectorPtr self, int n)
		{
			ImGuiPNative.SetBit(self, n);
		}
		public static void SetBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImGuiPNative.SetBit((ImBitVector*)pself, n);
			}
		}
		public static void ClearBit(ImBitVectorPtr self, int n)
		{
			ImGuiPNative.ClearBit(self, n);
		}
		public static void ClearBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ImGuiPNative.ClearBit((ImBitVector*)pself, n);
			}
		}
		public static ImDrawListSharedDataPtr ImDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImGuiPNative.ImDrawListSharedData();
			return ret;
		}
		public static void SetCircleTessellationMaxError(ImDrawListSharedDataPtr self, float maxError)
		{
			ImGuiPNative.SetCircleTessellationMaxError(self, maxError);
		}
		public static void SetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				ImGuiPNative.SetCircleTessellationMaxError((ImDrawListSharedData*)pself, maxError);
			}
		}
		public static void ClearFreeMemory(ImDrawDataBuilderPtr self)
		{
			ImGuiPNative.ClearFreeMemory(self);
		}
		public static void ClearFreeMemory(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImGuiPNative.ClearFreeMemory((ImDrawDataBuilder*)pself);
			}
		}
		public static void ClearFreeMemory(ImGuiInputTextStatePtr self)
		{
			ImGuiPNative.ClearFreeMemory(self);
		}
		public static void ClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.ClearFreeMemory((ImGuiInputTextState*)pself);
			}
		}
		public static int GetDrawListCount(ImDrawDataBuilderPtr self)
		{
			int ret = ImGuiPNative.GetDrawListCount(self);
			return ret;
		}
		public static int GetDrawListCount(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				int ret = ImGuiPNative.GetDrawListCount((ImDrawDataBuilder*)pself);
				return ret;
			}
		}
		public static void FlattenIntoSingleLayer(ImDrawDataBuilderPtr self)
		{
			ImGuiPNative.FlattenIntoSingleLayer(self);
		}
		public static void FlattenIntoSingleLayer(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ImGuiPNative.FlattenIntoSingleLayer((ImDrawDataBuilder*)pself);
			}
		}
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, int v)
		{
			ImGuiStyleModPtr ret = ImGuiPNative.ImGuiStyleMod(idx, v);
			return ret;
		}
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, float v)
		{
			ImGuiStyleModPtr ret = ImGuiPNative.ImGuiStyleMod(idx, v);
			return ret;
		}
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, Vector2 v)
		{
			ImGuiStyleModPtr ret = ImGuiPNative.ImGuiStyleMod(idx, v);
			return ret;
		}
		public static ImGuiComboPreviewDataPtr ImGuiComboPreviewData()
		{
			ImGuiComboPreviewDataPtr ret = ImGuiPNative.ImGuiComboPreviewData();
			return ret;
		}
		public static ImGuiMenuColumnsPtr ImGuiMenuColumns()
		{
			ImGuiMenuColumnsPtr ret = ImGuiPNative.ImGuiMenuColumns();
			return ret;
		}
		public static void Update(ImGuiMenuColumnsPtr self, float spacing, bool windowReappearing)
		{
			ImGuiPNative.Update(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}
		public static void Update(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiPNative.Update((ImGuiMenuColumns*)pself, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}
		public static float DeclColumns(ImGuiMenuColumnsPtr self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = ImGuiPNative.DeclColumns(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}
		public static float DeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = ImGuiPNative.DeclColumns((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}
		public static void CalcNextTotalWidth(ImGuiMenuColumnsPtr self, bool updateOffsets)
		{
			ImGuiPNative.CalcNextTotalWidth(self, updateOffsets ? (byte)1 : (byte)0);
		}
		public static void CalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				ImGuiPNative.CalcNextTotalWidth((ImGuiMenuColumns*)pself, updateOffsets ? (byte)1 : (byte)0);
			}
		}
		public static ImGuiInputTextStatePtr ImGuiInputTextState()
		{
			ImGuiInputTextStatePtr ret = ImGuiPNative.ImGuiInputTextState();
			return ret;
		}
		public static void ClearText(ImGuiInputTextStatePtr self)
		{
			ImGuiPNative.ClearText(self);
		}
		public static void ClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.ClearText((ImGuiInputTextState*)pself);
			}
		}
		public static int GetUndoAvailCount(ImGuiInputTextStatePtr self)
		{
			int ret = ImGuiPNative.GetUndoAvailCount(self);
			return ret;
		}
		public static int GetUndoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiPNative.GetUndoAvailCount((ImGuiInputTextState*)pself);
				return ret;
			}
		}
		public static int GetRedoAvailCount(ImGuiInputTextStatePtr self)
		{
			int ret = ImGuiPNative.GetRedoAvailCount(self);
			return ret;
		}
		public static int GetRedoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiPNative.GetRedoAvailCount((ImGuiInputTextState*)pself);
				return ret;
			}
		}
		public static void OnKeyPressed(ImGuiInputTextStatePtr self, int key)
		{
			ImGuiPNative.OnKeyPressed(self, key);
		}
		public static void OnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.OnKeyPressed((ImGuiInputTextState*)pself, key);
			}
		}
		public static void CursorAnimReset(ImGuiInputTextStatePtr self)
		{
			ImGuiPNative.CursorAnimReset(self);
		}
		public static void CursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.CursorAnimReset((ImGuiInputTextState*)pself);
			}
		}
		public static void CursorClamp(ImGuiInputTextStatePtr self)
		{
			ImGuiPNative.CursorClamp(self);
		}
		public static void CursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.CursorClamp((ImGuiInputTextState*)pself);
			}
		}
		public static bool HasSelection(ImGuiInputTextStatePtr self)
		{
			byte ret = ImGuiPNative.HasSelection(self);
			return ret != 0;
		}
		public static bool HasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				byte ret = ImGuiPNative.HasSelection((ImGuiInputTextState*)pself);
				return ret != 0;
			}
		}
		public static void ClearSelection(ImGuiInputTextStatePtr self)
		{
			ImGuiPNative.ClearSelection(self);
		}
		public static void ClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.ClearSelection((ImGuiInputTextState*)pself);
			}
		}
		public static int GetCursorPos(ImGuiInputTextStatePtr self)
		{
			int ret = ImGuiPNative.GetCursorPos(self);
			return ret;
		}
		public static int GetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiPNative.GetCursorPos((ImGuiInputTextState*)pself);
				return ret;
			}
		}
		public static int GetSelectionStart(ImGuiInputTextStatePtr self)
		{
			int ret = ImGuiPNative.GetSelectionStart(self);
			return ret;
		}
		public static int GetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiPNative.GetSelectionStart((ImGuiInputTextState*)pself);
				return ret;
			}
		}
		public static int GetSelectionEnd(ImGuiInputTextStatePtr self)
		{
			int ret = ImGuiPNative.GetSelectionEnd(self);
			return ret;
		}
		public static int GetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = ImGuiPNative.GetSelectionEnd((ImGuiInputTextState*)pself);
				return ret;
			}
		}
		public static void SelectAll(ImGuiInputTextStatePtr self)
		{
			ImGuiPNative.SelectAll(self);
		}
		public static void SelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ImGuiPNative.SelectAll((ImGuiInputTextState*)pself);
			}
		}
		public static ImGuiPopupDataPtr ImGuiPopupData()
		{
			ImGuiPopupDataPtr ret = ImGuiPNative.ImGuiPopupData();
			return ret;
		}
		public static ImGuiNextWindowDataPtr ImGuiNextWindowData()
		{
			ImGuiNextWindowDataPtr ret = ImGuiPNative.ImGuiNextWindowData();
			return ret;
		}
		public static void ClearFlags(ImGuiNextWindowDataPtr self)
		{
			ImGuiPNative.ClearFlags(self);
		}
		public static void ClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ImGuiPNative.ClearFlags((ImGuiNextWindowData*)pself);
			}
		}
		public static void ClearFlags(ImGuiNextItemDataPtr self)
		{
			ImGuiPNative.ClearFlags(self);
		}
		public static void ClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ImGuiPNative.ClearFlags((ImGuiNextItemData*)pself);
			}
		}
		public static ImGuiNextItemDataPtr ImGuiNextItemData()
		{
			ImGuiNextItemDataPtr ret = ImGuiPNative.ImGuiNextItemData();
			return ret;
		}
		public static ImGuiLastItemDataPtr ImGuiLastItemData()
		{
			ImGuiLastItemDataPtr ret = ImGuiPNative.ImGuiLastItemData();
			return ret;
		}
		public static ImGuiStackSizesPtr ImGuiStackSizes()
		{
			ImGuiStackSizesPtr ret = ImGuiPNative.ImGuiStackSizes();
			return ret;
		}
		public static void SetToCurrentState(ImGuiStackSizesPtr self)
		{
			ImGuiPNative.SetToCurrentState(self);
		}
		public static void SetToCurrentState(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiPNative.SetToCurrentState((ImGuiStackSizes*)pself);
			}
		}
		public static void CompareWithCurrentState(ImGuiStackSizesPtr self)
		{
			ImGuiPNative.CompareWithCurrentState(self);
		}
		public static void CompareWithCurrentState(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				ImGuiPNative.CompareWithCurrentState((ImGuiStackSizes*)pself);
			}
		}
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(void* ptr)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPNative.ImGuiPtrOrIndex(ptr);
			return ret;
		}
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(int index)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPNative.ImGuiPtrOrIndex(index);
			return ret;
		}
		public static ImGuiInputEventPtr ImGuiInputEvent()
		{
			ImGuiInputEventPtr ret = ImGuiPNative.ImGuiInputEvent();
			return ret;
		}
		public static ImGuiListClipperRange FromIndices(int min, int max)
		{
			ImGuiListClipperRange ret = ImGuiPNative.FromIndices(min, max);
			return ret;
		}
		public static ImGuiListClipperRange FromPositions(float y1, float y2, int offMin, int offMax)
		{
			ImGuiListClipperRange ret = ImGuiPNative.FromPositions(y1, y2, offMin, offMax);
			return ret;
		}
		public static ImGuiListClipperDataPtr ImGuiListClipperData()
		{
			ImGuiListClipperDataPtr ret = ImGuiPNative.ImGuiListClipperData();
			return ret;
		}
		public static void Reset(ImGuiListClipperDataPtr self, ImGuiListClipperPtr clipper)
		{
			ImGuiPNative.Reset(self, clipper);
		}
		public static void Reset(ref ImGuiListClipperData self, ImGuiListClipperPtr clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ImGuiPNative.Reset((ImGuiListClipperData*)pself, clipper);
			}
		}
		public static void Reset(ImGuiListClipperDataPtr self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ImGuiPNative.Reset(self, (ImGuiListClipper*)pclipper);
			}
		}
		public static void Reset(ref ImGuiListClipperData self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ImGuiPNative.Reset((ImGuiListClipperData*)pself, (ImGuiListClipper*)pclipper);
				}
			}
		}
		public static ImGuiNavItemDataPtr ImGuiNavItemData()
		{
			ImGuiNavItemDataPtr ret = ImGuiPNative.ImGuiNavItemData();
			return ret;
		}
		public static ImGuiOldColumnDataPtr ImGuiOldColumnData()
		{
			ImGuiOldColumnDataPtr ret = ImGuiPNative.ImGuiOldColumnData();
			return ret;
		}
		public static ImGuiOldColumnsPtr ImGuiOldColumns()
		{
			ImGuiOldColumnsPtr ret = ImGuiPNative.ImGuiOldColumns();
			return ret;
		}
		public static ImGuiDockNodePtr ImGuiDockNode(uint id)
		{
			ImGuiDockNodePtr ret = ImGuiPNative.ImGuiDockNode(id);
			return ret;
		}
		public static void Destroy(ImGuiDockNodePtr self)
		{
			ImGuiPNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiPNative.Destroy((ImGuiDockNode*)pself);
			}
		}
		public static void Destroy(ImGuiViewportPPtr self)
		{
			ImGuiPNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.Destroy((ImGuiViewportP*)pself);
			}
		}
		public static void Destroy(ImGuiWindowPtr self)
		{
			ImGuiPNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiPNative.Destroy((ImGuiWindow*)pself);
			}
		}
		public static void Destroy(ImGuiTablePtr self)
		{
			ImGuiPNative.Destroy(self);
		}
		public static void Destroy(ref ImGuiTable self)
		{
			fixed (ImGuiTable* pself = &self)
			{
				ImGuiPNative.Destroy((ImGuiTable*)pself);
			}
		}
		public static bool IsRootNode(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsRootNode(self);
			return ret != 0;
		}
		public static bool IsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsRootNode((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsDockSpace(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsDockSpace(self);
			return ret != 0;
		}
		public static bool IsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsDockSpace((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsFloatingNode(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsFloatingNode(self);
			return ret != 0;
		}
		public static bool IsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsFloatingNode((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsCentralNode(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsCentralNode(self);
			return ret != 0;
		}
		public static bool IsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsCentralNode((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsHiddenTabBar(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsHiddenTabBar(self);
			return ret != 0;
		}
		public static bool IsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsHiddenTabBar((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsNoTabBar(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsNoTabBar(self);
			return ret != 0;
		}
		public static bool IsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsNoTabBar((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsSplitNode(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsSplitNode(self);
			return ret != 0;
		}
		public static bool IsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsSplitNode((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsLeafNode(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsLeafNode(self);
			return ret != 0;
		}
		public static bool IsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsLeafNode((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static bool IsEmpty(ImGuiDockNodePtr self)
		{
			byte ret = ImGuiPNative.IsEmpty(self);
			return ret != 0;
		}
		public static bool IsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = ImGuiPNative.IsEmpty((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}
		public static ImRect Rect(ImGuiDockNodePtr self)
		{
			ImRect ret;
			ImGuiPNative.Rect(&ret, self);
			return ret;
		}
		public static void Rect(ImRectPtr pOut, ImGuiDockNodePtr self)
		{
			ImGuiPNative.Rect(pOut, self);
		}
		public static void Rect(ref ImRect pOut, ImGuiDockNodePtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.Rect((ImRect*)ppOut, self);
			}
		}
		public static ImRect Rect(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.Rect(&ret, (ImGuiDockNode*)pself);
				return ret;
			}
		}
		public static void Rect(ImRectPtr pOut, ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiPNative.Rect(pOut, (ImGuiDockNode*)pself);
			}
		}
		public static void Rect(ref ImRect pOut, ref ImGuiDockNode self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					ImGuiPNative.Rect((ImRect*)ppOut, (ImGuiDockNode*)pself);
				}
			}
		}
		public static ImRect Rect(ImGuiWindowPtr self)
		{
			ImRect ret;
			ImGuiPNative.Rect(&ret, self);
			return ret;
		}
		public static void Rect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			ImGuiPNative.Rect(pOut, self);
		}
		public static void Rect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.Rect((ImRect*)ppOut, self);
			}
		}
		public static ImRect Rect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.Rect(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}
		public static void Rect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiPNative.Rect(pOut, (ImGuiWindow*)pself);
			}
		}
		public static void Rect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiPNative.Rect((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}
		public static void SetLocalFlags(ImGuiDockNodePtr self, ImGuiDockNodeFlags flags)
		{
			ImGuiPNative.SetLocalFlags(self, flags);
		}
		public static void SetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiPNative.SetLocalFlags((ImGuiDockNode*)pself, flags);
			}
		}
		public static void UpdateMergedFlags(ImGuiDockNodePtr self)
		{
			ImGuiPNative.UpdateMergedFlags(self);
		}
		public static void UpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImGuiPNative.UpdateMergedFlags((ImGuiDockNode*)pself);
			}
		}
		public static ImGuiDockContextPtr ImGuiDockContext()
		{
			ImGuiDockContextPtr ret = ImGuiPNative.ImGuiDockContext();
			return ret;
		}
		public static ImGuiViewportPPtr ImGuiViewportP()
		{
			ImGuiViewportPPtr ret = ImGuiPNative.ImGuiViewportP();
			return ret;
		}
		public static void ClearRequestFlags(ImGuiViewportPPtr self)
		{
			ImGuiPNative.ClearRequestFlags(self);
		}
		public static void ClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.ClearRequestFlags((ImGuiViewportP*)pself);
			}
		}
		public static Vector2 CalcWorkRectPos(ImGuiViewportPPtr self, Vector2 offMin)
		{
			Vector2 ret;
			ImGuiPNative.CalcWorkRectPos(&ret, self, offMin);
			return ret;
		}
		public static void CalcWorkRectPos(Vector2* pOut, ImGuiViewportPPtr self, Vector2 offMin)
		{
			ImGuiPNative.CalcWorkRectPos(pOut, self, offMin);
		}
		public static void CalcWorkRectPos(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 offMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.CalcWorkRectPos((Vector2*)ppOut, self, offMin);
			}
		}
		public static Vector2 CalcWorkRectPos(ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.CalcWorkRectPos(&ret, (ImGuiViewportP*)pself, offMin);
				return ret;
			}
		}
		public static void CalcWorkRectPos(Vector2* pOut, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.CalcWorkRectPos(pOut, (ImGuiViewportP*)pself, offMin);
			}
		}
		public static void CalcWorkRectPos(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiPNative.CalcWorkRectPos((Vector2*)ppOut, (ImGuiViewportP*)pself, offMin);
				}
			}
		}
		public static Vector2 CalcWorkRectSize(ImGuiViewportPPtr self, Vector2 offMin, Vector2 offMax)
		{
			Vector2 ret;
			ImGuiPNative.CalcWorkRectSize(&ret, self, offMin, offMax);
			return ret;
		}
		public static void CalcWorkRectSize(Vector2* pOut, ImGuiViewportPPtr self, Vector2 offMin, Vector2 offMax)
		{
			ImGuiPNative.CalcWorkRectSize(pOut, self, offMin, offMax);
		}
		public static void CalcWorkRectSize(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.CalcWorkRectSize((Vector2*)ppOut, self, offMin, offMax);
			}
		}
		public static Vector2 CalcWorkRectSize(ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				ImGuiPNative.CalcWorkRectSize(&ret, (ImGuiViewportP*)pself, offMin, offMax);
				return ret;
			}
		}
		public static void CalcWorkRectSize(Vector2* pOut, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.CalcWorkRectSize(pOut, (ImGuiViewportP*)pself, offMin, offMax);
			}
		}
		public static void CalcWorkRectSize(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiPNative.CalcWorkRectSize((Vector2*)ppOut, (ImGuiViewportP*)pself, offMin, offMax);
				}
			}
		}
		public static void UpdateWorkRect(ImGuiViewportPPtr self)
		{
			ImGuiPNative.UpdateWorkRect(self);
		}
		public static void UpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.UpdateWorkRect((ImGuiViewportP*)pself);
			}
		}
		public static ImRect GetMainRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			ImGuiPNative.GetMainRect(&ret, self);
			return ret;
		}
		public static void GetMainRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			ImGuiPNative.GetMainRect(pOut, self);
		}
		public static void GetMainRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.GetMainRect((ImRect*)ppOut, self);
			}
		}
		public static ImRect GetMainRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.GetMainRect(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}
		public static void GetMainRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.GetMainRect(pOut, (ImGuiViewportP*)pself);
			}
		}
		public static void GetMainRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiPNative.GetMainRect((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}
		public static ImRect GetWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			ImGuiPNative.GetWorkRect(&ret, self);
			return ret;
		}
		public static void GetWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			ImGuiPNative.GetWorkRect(pOut, self);
		}
		public static void GetWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.GetWorkRect((ImRect*)ppOut, self);
			}
		}
		public static ImRect GetWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.GetWorkRect(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}
		public static void GetWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.GetWorkRect(pOut, (ImGuiViewportP*)pself);
			}
		}
		public static void GetWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiPNative.GetWorkRect((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}
		public static ImRect GetBuildWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			ImGuiPNative.GetBuildWorkRect(&ret, self);
			return ret;
		}
		public static void GetBuildWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			ImGuiPNative.GetBuildWorkRect(pOut, self);
		}
		public static void GetBuildWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.GetBuildWorkRect((ImRect*)ppOut, self);
			}
		}
		public static ImRect GetBuildWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.GetBuildWorkRect(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}
		public static void GetBuildWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImGuiPNative.GetBuildWorkRect(pOut, (ImGuiViewportP*)pself);
			}
		}
		public static void GetBuildWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					ImGuiPNative.GetBuildWorkRect((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}
		public static ImGuiWindowSettingsPtr ImGuiWindowSettings()
		{
			ImGuiWindowSettingsPtr ret = ImGuiPNative.ImGuiWindowSettings();
			return ret;
		}
		public static byte* GetName(ImGuiWindowSettingsPtr self)
		{
			byte* ret = ImGuiPNative.GetName(self);
			return ret;
		}
		public static byte* GetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = ImGuiPNative.GetName((ImGuiWindowSettings*)pself);
				return ret;
			}
		}
		public static string GetNameS(ImGuiWindowSettingsPtr self)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetName(self));
			return ret;
		}
		public static string GetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetName((ImGuiWindowSettings*)pself));
				return ret;
			}
		}
		public static ImGuiSettingsHandlerPtr ImGuiSettingsHandler()
		{
			ImGuiSettingsHandlerPtr ret = ImGuiPNative.ImGuiSettingsHandler();
			return ret;
		}
		public static ImGuiMetricsConfigPtr ImGuiMetricsConfig()
		{
			ImGuiMetricsConfigPtr ret = ImGuiPNative.ImGuiMetricsConfig();
			return ret;
		}
		public static ImGuiStackLevelInfoPtr ImGuiStackLevelInfo()
		{
			ImGuiStackLevelInfoPtr ret = ImGuiPNative.ImGuiStackLevelInfo();
			return ret;
		}
		public static ImGuiStackToolPtr ImGuiStackTool()
		{
			ImGuiStackToolPtr ret = ImGuiPNative.ImGuiStackTool();
			return ret;
		}
		public static ImGuiContextHookPtr ImGuiContextHook()
		{
			ImGuiContextHookPtr ret = ImGuiPNative.ImGuiContextHook();
			return ret;
		}
		public static ImGuiContextPtr ImGuiContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = ImGuiPNative.ImGuiContext(sharedFontAtlas);
			return ret;
		}
		public static ImGuiContextPtr ImGuiContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = ImGuiPNative.ImGuiContext((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, byte* name)
		{
			ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow(context, name);
			return ret;
		}
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, byte* name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow((ImGuiContext*)pcontext, name);
				return ret;
			}
		}
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow(context, (byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow(context, (byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, ref byte name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = &name)
				{
					ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, ReadOnlySpan<byte> name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = name)
				{
					ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, string name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiWindowPtr ret = ImGuiPNative.ImGuiWindow((ImGuiContext*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static uint GetIDFromRectangle(ImGuiWindowPtr self, ImRect rAbs)
		{
			uint ret = ImGuiPNative.GetIDFromRectangle(self, rAbs);
			return ret;
		}
		public static uint GetIDFromRectangle(ref ImGuiWindow self, ImRect rAbs)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = ImGuiPNative.GetIDFromRectangle((ImGuiWindow*)pself, rAbs);
				return ret;
			}
		}
		public static float CalcFontSize(ImGuiWindowPtr self)
		{
			float ret = ImGuiPNative.CalcFontSize(self);
			return ret;
		}
		public static float CalcFontSize(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiPNative.CalcFontSize((ImGuiWindow*)pself);
				return ret;
			}
		}
		public static float TitleBarHeight(ImGuiWindowPtr self)
		{
			float ret = ImGuiPNative.TitleBarHeight(self);
			return ret;
		}
		public static float TitleBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiPNative.TitleBarHeight((ImGuiWindow*)pself);
				return ret;
			}
		}
		public static ImRect TitleBarRect(ImGuiWindowPtr self)
		{
			ImRect ret;
			ImGuiPNative.TitleBarRect(&ret, self);
			return ret;
		}
		public static void TitleBarRect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			ImGuiPNative.TitleBarRect(pOut, self);
		}
		public static void TitleBarRect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.TitleBarRect((ImRect*)ppOut, self);
			}
		}
		public static ImRect TitleBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.TitleBarRect(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}
		public static void TitleBarRect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiPNative.TitleBarRect(pOut, (ImGuiWindow*)pself);
			}
		}
		public static void TitleBarRect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiPNative.TitleBarRect((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}
		public static float MenuBarHeight(ImGuiWindowPtr self)
		{
			float ret = ImGuiPNative.MenuBarHeight(self);
			return ret;
		}
		public static float MenuBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = ImGuiPNative.MenuBarHeight((ImGuiWindow*)pself);
				return ret;
			}
		}
		public static ImRect MenuBarRect(ImGuiWindowPtr self)
		{
			ImRect ret;
			ImGuiPNative.MenuBarRect(&ret, self);
			return ret;
		}
		public static void MenuBarRect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			ImGuiPNative.MenuBarRect(pOut, self);
		}
		public static void MenuBarRect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.MenuBarRect((ImRect*)ppOut, self);
			}
		}
		public static ImRect MenuBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				ImGuiPNative.MenuBarRect(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}
		public static void MenuBarRect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImGuiPNative.MenuBarRect(pOut, (ImGuiWindow*)pself);
			}
		}
		public static void MenuBarRect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					ImGuiPNative.MenuBarRect((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}
		public static ImGuiTabItemPtr ImGuiTabItem()
		{
			ImGuiTabItemPtr ret = ImGuiPNative.ImGuiTabItem();
			return ret;
		}
		public static ImGuiTabBarPtr ImGuiTabBar()
		{
			ImGuiTabBarPtr ret = ImGuiPNative.ImGuiTabBar();
			return ret;
		}
		public static int GetTabOrder(ImGuiTabBarPtr self, ImGuiTabItemPtr tab)
		{
			int ret = ImGuiPNative.GetTabOrder(self, tab);
			return ret;
		}
		public static int GetTabOrder(ref ImGuiTabBar self, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				int ret = ImGuiPNative.GetTabOrder((ImGuiTabBar*)pself, tab);
				return ret;
			}
		}
		public static int GetTabOrder(ImGuiTabBarPtr self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				int ret = ImGuiPNative.GetTabOrder(self, (ImGuiTabItem*)ptab);
				return ret;
			}
		}
		public static int GetTabOrder(ref ImGuiTabBar self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					int ret = ImGuiPNative.GetTabOrder((ImGuiTabBar*)pself, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}
		public static byte* GetTabName(ImGuiTabBarPtr self, ImGuiTabItemPtr tab)
		{
			byte* ret = ImGuiPNative.GetTabName(self, tab);
			return ret;
		}
		public static byte* GetTabName(ref ImGuiTabBar self, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				byte* ret = ImGuiPNative.GetTabName((ImGuiTabBar*)pself, tab);
				return ret;
			}
		}
		public static byte* GetTabName(ImGuiTabBarPtr self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				byte* ret = ImGuiPNative.GetTabName(self, (ImGuiTabItem*)ptab);
				return ret;
			}
		}
		public static byte* GetTabName(ref ImGuiTabBar self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					byte* ret = ImGuiPNative.GetTabName((ImGuiTabBar*)pself, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}
		public static string GetTabNameS(ImGuiTabBarPtr self, ImGuiTabItemPtr tab)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetTabName(self, tab));
			return ret;
		}
		public static string GetTabNameS(ref ImGuiTabBar self, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetTabName((ImGuiTabBar*)pself, tab));
				return ret;
			}
		}
		public static string GetTabNameS(ImGuiTabBarPtr self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetTabName(self, (ImGuiTabItem*)ptab));
				return ret;
			}
		}
		public static string GetTabNameS(ref ImGuiTabBar self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetTabName((ImGuiTabBar*)pself, (ImGuiTabItem*)ptab));
					return ret;
				}
			}
		}
		public static ImGuiTableColumnPtr ImGuiTableColumn()
		{
			ImGuiTableColumnPtr ret = ImGuiPNative.ImGuiTableColumn();
			return ret;
		}
		public static ImGuiTableInstanceDataPtr ImGuiTableInstanceData()
		{
			ImGuiTableInstanceDataPtr ret = ImGuiPNative.ImGuiTableInstanceData();
			return ret;
		}
		public static ImGuiTablePtr ImGuiTable()
		{
			ImGuiTablePtr ret = ImGuiPNative.ImGuiTable();
			return ret;
		}
		public static ImGuiTableTempDataPtr ImGuiTableTempData()
		{
			ImGuiTableTempDataPtr ret = ImGuiPNative.ImGuiTableTempData();
			return ret;
		}
		public static ImGuiTableColumnSettingsPtr ImGuiTableColumnSettings()
		{
			ImGuiTableColumnSettingsPtr ret = ImGuiPNative.ImGuiTableColumnSettings();
			return ret;
		}
		public static ImGuiTableSettingsPtr ImGuiTableSettings()
		{
			ImGuiTableSettingsPtr ret = ImGuiPNative.ImGuiTableSettings();
			return ret;
		}
		public static ImGuiTableColumnSettingsPtr GetColumnSettings(ImGuiTableSettingsPtr self)
		{
			ImGuiTableColumnSettingsPtr ret = ImGuiPNative.GetColumnSettings(self);
			return ret;
		}
		public static ImGuiTableColumnSettingsPtr GetColumnSettings(ref ImGuiTableSettings self)
		{
			fixed (ImGuiTableSettings* pself = &self)
			{
				ImGuiTableColumnSettingsPtr ret = ImGuiPNative.GetColumnSettings((ImGuiTableSettings*)pself);
				return ret;
			}
		}
		public static ImGuiWindowPtr GetCurrentWindowRead()
		{
			ImGuiWindowPtr ret = ImGuiPNative.GetCurrentWindowRead();
			return ret;
		}
		public static ImGuiWindowPtr GetCurrentWindow()
		{
			ImGuiWindowPtr ret = ImGuiPNative.GetCurrentWindow();
			return ret;
		}
		public static ImGuiWindowPtr FindWindowByID(uint id)
		{
			ImGuiWindowPtr ret = ImGuiPNative.FindWindowByID(id);
			return ret;
		}
		public static ImGuiWindowPtr FindWindowByName(byte* name)
		{
			ImGuiWindowPtr ret = ImGuiPNative.FindWindowByName(name);
			return ret;
		}
		public static ImGuiWindowPtr FindWindowByName(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = ImGuiPNative.FindWindowByName((byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowPtr FindWindowByName(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowPtr ret = ImGuiPNative.FindWindowByName((byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowPtr FindWindowByName(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = ImGuiPNative.FindWindowByName(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void UpdateWindowParentAndRootLinks(ImGuiWindowPtr window, ImGuiWindowFlags flags, ImGuiWindowPtr parentWindow)
		{
			ImGuiPNative.UpdateWindowParentAndRootLinks(window, flags, parentWindow);
		}
		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ImGuiWindowPtr parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.UpdateWindowParentAndRootLinks((ImGuiWindow*)pwindow, flags, parentWindow);
			}
		}
		public static void UpdateWindowParentAndRootLinks(ImGuiWindowPtr window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pparentWindow = &parentWindow)
			{
				ImGuiPNative.UpdateWindowParentAndRootLinks(window, flags, (ImGuiWindow*)pparentWindow);
			}
		}
		public static void UpdateWindowParentAndRootLinks(ref ImGuiWindow window, ImGuiWindowFlags flags, ref ImGuiWindow parentWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* pparentWindow = &parentWindow)
				{
					ImGuiPNative.UpdateWindowParentAndRootLinks((ImGuiWindow*)pwindow, flags, (ImGuiWindow*)pparentWindow);
				}
			}
		}
		public static Vector2 CalcWindowNextAutoFitSize(ImGuiWindowPtr window)
		{
			Vector2 ret;
			ImGuiPNative.CalcWindowNextAutoFitSize(&ret, window);
			return ret;
		}
		public static void CalcWindowNextAutoFitSize(Vector2* pOut, ImGuiWindowPtr window)
		{
			ImGuiPNative.CalcWindowNextAutoFitSize(pOut, window);
		}
		public static void CalcWindowNextAutoFitSize(ref Vector2 pOut, ImGuiWindowPtr window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.CalcWindowNextAutoFitSize((Vector2*)ppOut, window);
			}
		}
		public static Vector2 CalcWindowNextAutoFitSize(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ImGuiPNative.CalcWindowNextAutoFitSize(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}
		public static void CalcWindowNextAutoFitSize(Vector2* pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.CalcWindowNextAutoFitSize(pOut, (ImGuiWindow*)pwindow);
			}
		}
		public static void CalcWindowNextAutoFitSize(ref Vector2 pOut, ref ImGuiWindow window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.CalcWindowNextAutoFitSize((Vector2*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}
		public static bool IsWindowChildOf(ImGuiWindowPtr window, ImGuiWindowPtr potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			byte ret = ImGuiPNative.IsWindowChildOf(window, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool IsWindowChildOf(ref ImGuiWindow window, ImGuiWindowPtr potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = ImGuiPNative.IsWindowChildOf((ImGuiWindow*)pwindow, potentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool IsWindowChildOf(ImGuiWindowPtr window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = ImGuiPNative.IsWindowChildOf(window, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool IsWindowChildOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent, bool popupHierarchy, bool dockHierarchy)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = ImGuiPNative.IsWindowChildOf((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent, popupHierarchy ? (byte)1 : (byte)0, dockHierarchy ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool IsWindowWithinBeginStackOf(ImGuiWindowPtr window, ImGuiWindowPtr potentialParent)
		{
			byte ret = ImGuiPNative.IsWindowWithinBeginStackOf(window, potentialParent);
			return ret != 0;
		}
		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ImGuiWindowPtr potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = ImGuiPNative.IsWindowWithinBeginStackOf((ImGuiWindow*)pwindow, potentialParent);
				return ret != 0;
			}
		}
		public static bool IsWindowWithinBeginStackOf(ImGuiWindowPtr window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* ppotentialParent = &potentialParent)
			{
				byte ret = ImGuiPNative.IsWindowWithinBeginStackOf(window, (ImGuiWindow*)ppotentialParent);
				return ret != 0;
			}
		}
		public static bool IsWindowWithinBeginStackOf(ref ImGuiWindow window, ref ImGuiWindow potentialParent)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* ppotentialParent = &potentialParent)
				{
					byte ret = ImGuiPNative.IsWindowWithinBeginStackOf((ImGuiWindow*)pwindow, (ImGuiWindow*)ppotentialParent);
					return ret != 0;
				}
			}
		}
		public static bool IsWindowAbove(ImGuiWindowPtr potentialAbove, ImGuiWindowPtr potentialBelow)
		{
			byte ret = ImGuiPNative.IsWindowAbove(potentialAbove, potentialBelow);
			return ret != 0;
		}
		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ImGuiWindowPtr potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				byte ret = ImGuiPNative.IsWindowAbove((ImGuiWindow*)ppotentialAbove, potentialBelow);
				return ret != 0;
			}
		}
		public static bool IsWindowAbove(ImGuiWindowPtr potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
			{
				byte ret = ImGuiPNative.IsWindowAbove(potentialAbove, (ImGuiWindow*)ppotentialBelow);
				return ret != 0;
			}
		}
		public static bool IsWindowAbove(ref ImGuiWindow potentialAbove, ref ImGuiWindow potentialBelow)
		{
			fixed (ImGuiWindow* ppotentialAbove = &potentialAbove)
			{
				fixed (ImGuiWindow* ppotentialBelow = &potentialBelow)
				{
					byte ret = ImGuiPNative.IsWindowAbove((ImGuiWindow*)ppotentialAbove, (ImGuiWindow*)ppotentialBelow);
					return ret != 0;
				}
			}
		}
		public static bool IsWindowNavFocusable(ImGuiWindowPtr window)
		{
			byte ret = ImGuiPNative.IsWindowNavFocusable(window);
			return ret != 0;
		}
		public static bool IsWindowNavFocusable(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = ImGuiPNative.IsWindowNavFocusable((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}
		public static void SetWindowPos(ImGuiWindowPtr window, Vector2 pos, ImGuiCond cond)
		{
			ImGuiPNative.SetWindowPos(window, pos, cond);
		}
		public static void SetWindowPos(ImGuiWindowPtr window, Vector2 pos)
		{
			ImGuiPNative.SetWindowPos(window, pos, (ImGuiCond)(0));
		}
		public static void SetWindowPos(ref ImGuiWindow window, Vector2 pos, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowPos((ImGuiWindow*)pwindow, pos, cond);
			}
		}
		public static void SetWindowPos(ref ImGuiWindow window, Vector2 pos)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowPos((ImGuiWindow*)pwindow, pos, (ImGuiCond)(0));
			}
		}
		public static void SetWindowSize(ImGuiWindowPtr window, Vector2 size, ImGuiCond cond)
		{
			ImGuiPNative.SetWindowSize(window, size, cond);
		}
		public static void SetWindowSize(ImGuiWindowPtr window, Vector2 size)
		{
			ImGuiPNative.SetWindowSize(window, size, (ImGuiCond)(0));
		}
		public static void SetWindowSize(ref ImGuiWindow window, Vector2 size, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowSize((ImGuiWindow*)pwindow, size, cond);
			}
		}
		public static void SetWindowSize(ref ImGuiWindow window, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowSize((ImGuiWindow*)pwindow, size, (ImGuiCond)(0));
			}
		}
		public static void SetWindowCollapsed(ImGuiWindowPtr window, bool collapsed, ImGuiCond cond)
		{
			ImGuiPNative.SetWindowCollapsed(window, collapsed ? (byte)1 : (byte)0, cond);
		}
		public static void SetWindowCollapsed(ImGuiWindowPtr window, bool collapsed)
		{
			ImGuiPNative.SetWindowCollapsed(window, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}
		public static void SetWindowCollapsed(ref ImGuiWindow window, bool collapsed, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowCollapsed((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, cond);
			}
		}
		public static void SetWindowCollapsed(ref ImGuiWindow window, bool collapsed)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowCollapsed((ImGuiWindow*)pwindow, collapsed ? (byte)1 : (byte)0, (ImGuiCond)(0));
			}
		}
		public static void SetWindowHitTestHole(ImGuiWindowPtr window, Vector2 pos, Vector2 size)
		{
			ImGuiPNative.SetWindowHitTestHole(window, pos, size);
		}
		public static void SetWindowHitTestHole(ref ImGuiWindow window, Vector2 pos, Vector2 size)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowHitTestHole((ImGuiWindow*)pwindow, pos, size);
			}
		}
		public static ImRect WindowRectAbsToRel(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			ImGuiPNative.WindowRectAbsToRel(&ret, window, r);
			return ret;
		}
		public static void WindowRectAbsToRel(ImRectPtr pOut, ImGuiWindowPtr window, ImRect r)
		{
			ImGuiPNative.WindowRectAbsToRel(pOut, window, r);
		}
		public static void WindowRectAbsToRel(ref ImRect pOut, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.WindowRectAbsToRel((ImRect*)ppOut, window, r);
			}
		}
		public static ImRect WindowRectAbsToRel(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				ImGuiPNative.WindowRectAbsToRel(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}
		public static void WindowRectAbsToRel(ImRectPtr pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.WindowRectAbsToRel(pOut, (ImGuiWindow*)pwindow, r);
			}
		}
		public static void WindowRectAbsToRel(ref ImRect pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.WindowRectAbsToRel((ImRect*)ppOut, (ImGuiWindow*)pwindow, r);
				}
			}
		}
		public static ImRect WindowRectRelToAbs(ImGuiWindowPtr window, ImRect r)
		{
			ImRect ret;
			ImGuiPNative.WindowRectRelToAbs(&ret, window, r);
			return ret;
		}
		public static void WindowRectRelToAbs(ImRectPtr pOut, ImGuiWindowPtr window, ImRect r)
		{
			ImGuiPNative.WindowRectRelToAbs(pOut, window, r);
		}
		public static void WindowRectRelToAbs(ref ImRect pOut, ImGuiWindowPtr window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.WindowRectRelToAbs((ImRect*)ppOut, window, r);
			}
		}
		public static ImRect WindowRectRelToAbs(ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				ImGuiPNative.WindowRectRelToAbs(&ret, (ImGuiWindow*)pwindow, r);
				return ret;
			}
		}
		public static void WindowRectRelToAbs(ImRectPtr pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.WindowRectRelToAbs(pOut, (ImGuiWindow*)pwindow, r);
			}
		}
		public static void WindowRectRelToAbs(ref ImRect pOut, ref ImGuiWindow window, ImRect r)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.WindowRectRelToAbs((ImRect*)ppOut, (ImGuiWindow*)pwindow, r);
				}
			}
		}
		public static void FocusWindow(ImGuiWindowPtr window)
		{
			ImGuiPNative.FocusWindow(window);
		}
		public static void FocusWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.FocusWindow((ImGuiWindow*)pwindow);
			}
		}
		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ImGuiWindowPtr ignoreWindow)
		{
			ImGuiPNative.FocusTopMostWindowUnderOne(underThisWindow, ignoreWindow);
		}
		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ImGuiWindowPtr ignoreWindow)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				ImGuiPNative.FocusTopMostWindowUnderOne((ImGuiWindow*)punderThisWindow, ignoreWindow);
			}
		}
		public static void FocusTopMostWindowUnderOne(ImGuiWindowPtr underThisWindow, ref ImGuiWindow ignoreWindow)
		{
			fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
			{
				ImGuiPNative.FocusTopMostWindowUnderOne(underThisWindow, (ImGuiWindow*)pignoreWindow);
			}
		}
		public static void FocusTopMostWindowUnderOne(ref ImGuiWindow underThisWindow, ref ImGuiWindow ignoreWindow)
		{
			fixed (ImGuiWindow* punderThisWindow = &underThisWindow)
			{
				fixed (ImGuiWindow* pignoreWindow = &ignoreWindow)
				{
					ImGuiPNative.FocusTopMostWindowUnderOne((ImGuiWindow*)punderThisWindow, (ImGuiWindow*)pignoreWindow);
				}
			}
		}
		public static void BringWindowToFocusFront(ImGuiWindowPtr window)
		{
			ImGuiPNative.BringWindowToFocusFront(window);
		}
		public static void BringWindowToFocusFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BringWindowToFocusFront((ImGuiWindow*)pwindow);
			}
		}
		public static void BringWindowToDisplayFront(ImGuiWindowPtr window)
		{
			ImGuiPNative.BringWindowToDisplayFront(window);
		}
		public static void BringWindowToDisplayFront(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BringWindowToDisplayFront((ImGuiWindow*)pwindow);
			}
		}
		public static void BringWindowToDisplayBack(ImGuiWindowPtr window)
		{
			ImGuiPNative.BringWindowToDisplayBack(window);
		}
		public static void BringWindowToDisplayBack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BringWindowToDisplayBack((ImGuiWindow*)pwindow);
			}
		}
		public static void BringWindowToDisplayBehind(ImGuiWindowPtr window, ImGuiWindowPtr aboveWindow)
		{
			ImGuiPNative.BringWindowToDisplayBehind(window, aboveWindow);
		}
		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ImGuiWindowPtr aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BringWindowToDisplayBehind((ImGuiWindow*)pwindow, aboveWindow);
			}
		}
		public static void BringWindowToDisplayBehind(ImGuiWindowPtr window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* paboveWindow = &aboveWindow)
			{
				ImGuiPNative.BringWindowToDisplayBehind(window, (ImGuiWindow*)paboveWindow);
			}
		}
		public static void BringWindowToDisplayBehind(ref ImGuiWindow window, ref ImGuiWindow aboveWindow)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiWindow* paboveWindow = &aboveWindow)
				{
					ImGuiPNative.BringWindowToDisplayBehind((ImGuiWindow*)pwindow, (ImGuiWindow*)paboveWindow);
				}
			}
		}
		public static int FindWindowDisplayIndex(ImGuiWindowPtr window)
		{
			int ret = ImGuiPNative.FindWindowDisplayIndex(window);
			return ret;
		}
		public static int FindWindowDisplayIndex(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				int ret = ImGuiPNative.FindWindowDisplayIndex((ImGuiWindow*)pwindow);
				return ret;
			}
		}
		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindowPtr window)
		{
			ImGuiWindowPtr ret = ImGuiPNative.FindBottomMostVisibleWindowWithinBeginStack(window);
			return ret;
		}
		public static ImGuiWindowPtr FindBottomMostVisibleWindowWithinBeginStack(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiWindowPtr ret = ImGuiPNative.FindBottomMostVisibleWindowWithinBeginStack((ImGuiWindow*)pwindow);
				return ret;
			}
		}
		public static void SetCurrentFont(ImFontPtr font)
		{
			ImGuiPNative.SetCurrentFont(font);
		}
		public static void SetCurrentFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGuiPNative.SetCurrentFont((ImFont*)pfont);
			}
		}
		public static ImFontPtr GetDefaultFont()
		{
			ImFontPtr ret = ImGuiPNative.GetDefaultFont();
			return ret;
		}
		public static ImDrawListPtr GetForegroundDrawList(ImGuiWindowPtr window)
		{
			ImDrawListPtr ret = ImGuiPNative.GetForegroundDrawList(window);
			return ret;
		}
		public static ImDrawListPtr GetForegroundDrawList(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImDrawListPtr ret = ImGuiPNative.GetForegroundDrawList((ImGuiWindow*)pwindow);
				return ret;
			}
		}
		public static void Initialize()
		{
			ImGuiPNative.Initialize();
		}
		public static void Shutdown()
		{
			ImGuiPNative.Shutdown();
		}
		public static void UpdateInputEvents(bool trickleFastInputs)
		{
			ImGuiPNative.UpdateInputEvents(trickleFastInputs ? (byte)1 : (byte)0);
		}
		public static void UpdateHoveredWindowAndCaptureFlags()
		{
			ImGuiPNative.UpdateHoveredWindowAndCaptureFlags();
		}
		public static void StartMouseMovingWindow(ImGuiWindowPtr window)
		{
			ImGuiPNative.StartMouseMovingWindow(window);
		}
		public static void StartMouseMovingWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.StartMouseMovingWindow((ImGuiWindow*)pwindow);
			}
		}
		public static void StartMouseMovingWindowOrNode(ImGuiWindowPtr window, ImGuiDockNodePtr node, bool undockFloatingNode)
		{
			ImGuiPNative.StartMouseMovingWindowOrNode(window, node, undockFloatingNode ? (byte)1 : (byte)0);
		}
		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ImGuiDockNodePtr node, bool undockFloatingNode)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.StartMouseMovingWindowOrNode((ImGuiWindow*)pwindow, node, undockFloatingNode ? (byte)1 : (byte)0);
			}
		}
		public static void StartMouseMovingWindowOrNode(ImGuiWindowPtr window, ref ImGuiDockNode node, bool undockFloatingNode)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiPNative.StartMouseMovingWindowOrNode(window, (ImGuiDockNode*)pnode, undockFloatingNode ? (byte)1 : (byte)0);
			}
		}
		public static void StartMouseMovingWindowOrNode(ref ImGuiWindow window, ref ImGuiDockNode node, bool undockFloatingNode)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					ImGuiPNative.StartMouseMovingWindowOrNode((ImGuiWindow*)pwindow, (ImGuiDockNode*)pnode, undockFloatingNode ? (byte)1 : (byte)0);
				}
			}
		}
		public static void UpdateMouseMovingWindowNewFrame()
		{
			ImGuiPNative.UpdateMouseMovingWindowNewFrame();
		}
		public static void UpdateMouseMovingWindowEndFrame()
		{
			ImGuiPNative.UpdateMouseMovingWindowEndFrame();
		}
		public static uint AddContextHook(ImGuiContextPtr context, ImGuiContextHookPtr hook)
		{
			uint ret = ImGuiPNative.AddContextHook(context, hook);
			return ret;
		}
		public static uint AddContextHook(ref ImGuiContext context, ImGuiContextHookPtr hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				uint ret = ImGuiPNative.AddContextHook((ImGuiContext*)pcontext, hook);
				return ret;
			}
		}
		public static uint AddContextHook(ImGuiContextPtr context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContextHook* phook = &hook)
			{
				uint ret = ImGuiPNative.AddContextHook(context, (ImGuiContextHook*)phook);
				return ret;
			}
		}
		public static uint AddContextHook(ref ImGuiContext context, ref ImGuiContextHook hook)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (ImGuiContextHook* phook = &hook)
				{
					uint ret = ImGuiPNative.AddContextHook((ImGuiContext*)pcontext, (ImGuiContextHook*)phook);
					return ret;
				}
			}
		}
		public static void RemoveContextHook(ImGuiContextPtr context, uint hookToRemove)
		{
			ImGuiPNative.RemoveContextHook(context, hookToRemove);
		}
		public static void RemoveContextHook(ref ImGuiContext context, uint hookToRemove)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiPNative.RemoveContextHook((ImGuiContext*)pcontext, hookToRemove);
			}
		}
		public static void CallContextHooks(ImGuiContextPtr context, ImGuiContextHookType type)
		{
			ImGuiPNative.CallContextHooks(context, type);
		}
		public static void CallContextHooks(ref ImGuiContext context, ImGuiContextHookType type)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiPNative.CallContextHooks((ImGuiContext*)pcontext, type);
			}
		}
		public static void TranslateWindowsInViewport(ImGuiViewportPPtr viewport, Vector2 oldPos, Vector2 newPos)
		{
			ImGuiPNative.TranslateWindowsInViewport(viewport, oldPos, newPos);
		}
		public static void TranslateWindowsInViewport(ref ImGuiViewportP viewport, Vector2 oldPos, Vector2 newPos)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.TranslateWindowsInViewport((ImGuiViewportP*)pviewport, oldPos, newPos);
			}
		}
		public static void ScaleWindowsInViewport(ImGuiViewportPPtr viewport, float scale)
		{
			ImGuiPNative.ScaleWindowsInViewport(viewport, scale);
		}
		public static void ScaleWindowsInViewport(ref ImGuiViewportP viewport, float scale)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.ScaleWindowsInViewport((ImGuiViewportP*)pviewport, scale);
			}
		}
		public static void DestroyPlatformWindow(ImGuiViewportPPtr viewport)
		{
			ImGuiPNative.DestroyPlatformWindow(viewport);
		}
		public static void DestroyPlatformWindow(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.DestroyPlatformWindow((ImGuiViewportP*)pviewport);
			}
		}
		public static void SetWindowViewport(ImGuiWindowPtr window, ImGuiViewportPPtr viewport)
		{
			ImGuiPNative.SetWindowViewport(window, viewport);
		}
		public static void SetWindowViewport(ref ImGuiWindow window, ImGuiViewportPPtr viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowViewport((ImGuiWindow*)pwindow, viewport);
			}
		}
		public static void SetWindowViewport(ImGuiWindowPtr window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.SetWindowViewport(window, (ImGuiViewportP*)pviewport);
			}
		}
		public static void SetWindowViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					ImGuiPNative.SetWindowViewport((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}
		public static void SetCurrentViewport(ImGuiWindowPtr window, ImGuiViewportPPtr viewport)
		{
			ImGuiPNative.SetCurrentViewport(window, viewport);
		}
		public static void SetCurrentViewport(ref ImGuiWindow window, ImGuiViewportPPtr viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetCurrentViewport((ImGuiWindow*)pwindow, viewport);
			}
		}
		public static void SetCurrentViewport(ImGuiWindowPtr window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.SetCurrentViewport(window, (ImGuiViewportP*)pviewport);
			}
		}
		public static void SetCurrentViewport(ref ImGuiWindow window, ref ImGuiViewportP viewport)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					ImGuiPNative.SetCurrentViewport((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport);
				}
			}
		}
		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ImGuiViewportPtr viewport)
		{
			ImGuiPlatformMonitorPtr ret = ImGuiPNative.GetViewportPlatformMonitor(viewport);
			return ret;
		}
		public static ImGuiPlatformMonitorPtr GetViewportPlatformMonitor(ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImGuiPlatformMonitorPtr ret = ImGuiPNative.GetViewportPlatformMonitor((ImGuiViewport*)pviewport);
				return ret;
			}
		}
		public static ImGuiViewportPPtr FindHoveredViewportFromPlatformWindowStack(Vector2 mousePlatformPos)
		{
			ImGuiViewportPPtr ret = ImGuiPNative.FindHoveredViewportFromPlatformWindowStack(mousePlatformPos);
			return ret;
		}
		public static void MarkIniSettingsDirty()
		{
			ImGuiPNative.MarkIniSettingsDirty();
		}
		public static void MarkIniSettingsDirty(ImGuiWindowPtr window)
		{
			ImGuiPNative.MarkIniSettingsDirty(window);
		}
		public static void MarkIniSettingsDirty(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.MarkIniSettingsDirty((ImGuiWindow*)pwindow);
			}
		}
		public static void ClearIniSettings()
		{
			ImGuiPNative.ClearIniSettings();
		}
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(byte* name)
		{
			ImGuiWindowSettingsPtr ret = ImGuiPNative.CreateNewWindowSettings(name);
			return ret;
		}
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowSettingsPtr ret = ImGuiPNative.CreateNewWindowSettings((byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowSettingsPtr ret = ImGuiPNative.CreateNewWindowSettings((byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowSettingsPtr CreateNewWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowSettingsPtr ret = ImGuiPNative.CreateNewWindowSettings(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiWindowSettingsPtr FindWindowSettings(uint id)
		{
			ImGuiWindowSettingsPtr ret = ImGuiPNative.FindWindowSettings(id);
			return ret;
		}
		public static ImGuiWindowSettingsPtr FindOrCreateWindowSettings(byte* name)
		{
			ImGuiWindowSettingsPtr ret = ImGuiPNative.FindOrCreateWindowSettings(name);
			return ret;
		}
		public static ImGuiWindowSettingsPtr FindOrCreateWindowSettings(ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowSettingsPtr ret = ImGuiPNative.FindOrCreateWindowSettings((byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowSettingsPtr FindOrCreateWindowSettings(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowSettingsPtr ret = ImGuiPNative.FindOrCreateWindowSettings((byte*)pname);
				return ret;
			}
		}
		public static ImGuiWindowSettingsPtr FindOrCreateWindowSettings(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowSettingsPtr ret = ImGuiPNative.FindOrCreateWindowSettings(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void AddSettingsHandler(ImGuiSettingsHandlerPtr handler)
		{
			ImGuiPNative.AddSettingsHandler(handler);
		}
		public static void AddSettingsHandler(ref ImGuiSettingsHandler handler)
		{
			fixed (ImGuiSettingsHandler* phandler = &handler)
			{
				ImGuiPNative.AddSettingsHandler((ImGuiSettingsHandler*)phandler);
			}
		}
		public static void RemoveSettingsHandler(byte* typeName)
		{
			ImGuiPNative.RemoveSettingsHandler(typeName);
		}
		public static void RemoveSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				ImGuiPNative.RemoveSettingsHandler((byte*)ptypeName);
			}
		}
		public static void RemoveSettingsHandler(ReadOnlySpan<byte> typeName)
		{
			fixed (byte* ptypeName = typeName)
			{
				ImGuiPNative.RemoveSettingsHandler((byte*)ptypeName);
			}
		}
		public static void RemoveSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.RemoveSettingsHandler(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(byte* typeName)
		{
			ImGuiSettingsHandlerPtr ret = ImGuiPNative.FindSettingsHandler(typeName);
			return ret;
		}
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(ref byte typeName)
		{
			fixed (byte* ptypeName = &typeName)
			{
				ImGuiSettingsHandlerPtr ret = ImGuiPNative.FindSettingsHandler((byte*)ptypeName);
				return ret;
			}
		}
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(ReadOnlySpan<byte> typeName)
		{
			fixed (byte* ptypeName = typeName)
			{
				ImGuiSettingsHandlerPtr ret = ImGuiPNative.FindSettingsHandler((byte*)ptypeName);
				return ret;
			}
		}
		public static ImGuiSettingsHandlerPtr FindSettingsHandler(string typeName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (typeName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(typeName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(typeName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiSettingsHandlerPtr ret = ImGuiPNative.FindSettingsHandler(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void SetNextWindowScroll(Vector2 scroll)
		{
			ImGuiPNative.SetNextWindowScroll(scroll);
		}
		public static void SetScrollX(ImGuiWindowPtr window, float scrollX)
		{
			ImGuiPNative.SetScrollX(window, scrollX);
		}
		public static void SetScrollX(ref ImGuiWindow window, float scrollX)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetScrollX((ImGuiWindow*)pwindow, scrollX);
			}
		}
		public static void SetScrollY(ImGuiWindowPtr window, float scrollY)
		{
			ImGuiPNative.SetScrollY(window, scrollY);
		}
		public static void SetScrollY(ref ImGuiWindow window, float scrollY)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetScrollY((ImGuiWindow*)pwindow, scrollY);
			}
		}
		public static void SetScrollFromPosX(ImGuiWindowPtr window, float localX, float centerXRatio)
		{
			ImGuiPNative.SetScrollFromPosX(window, localX, centerXRatio);
		}
		public static void SetScrollFromPosX(ref ImGuiWindow window, float localX, float centerXRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetScrollFromPosX((ImGuiWindow*)pwindow, localX, centerXRatio);
			}
		}
		public static void SetScrollFromPosY(ImGuiWindowPtr window, float localY, float centerYRatio)
		{
			ImGuiPNative.SetScrollFromPosY(window, localY, centerYRatio);
		}
		public static void SetScrollFromPosY(ref ImGuiWindow window, float localY, float centerYRatio)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetScrollFromPosY((ImGuiWindow*)pwindow, localY, centerYRatio);
			}
		}
		public static void ScrollToItem(ImGuiScrollFlags flags)
		{
			ImGuiPNative.ScrollToItem(flags);
		}
		public static void ScrollToItem()
		{
			ImGuiPNative.ScrollToItem((ImGuiScrollFlags)(0));
		}
		public static void ScrollToRect(ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			ImGuiPNative.ScrollToRect(window, rect, flags);
		}
		public static void ScrollToRect(ImGuiWindowPtr window, ImRect rect)
		{
			ImGuiPNative.ScrollToRect(window, rect, (ImGuiScrollFlags)(0));
		}
		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.ScrollToRect((ImGuiWindow*)pwindow, rect, flags);
			}
		}
		public static void ScrollToRect(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.ScrollToRect((ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
			}
		}
		public static Vector2 ScrollToRectEx(ImGuiWindowPtr window, ImRect rect)
		{
			Vector2 ret;
			ImGuiPNative.ScrollToRectEx(&ret, window, rect, (ImGuiScrollFlags)(0));
			return ret;
		}
		public static Vector2 ScrollToRectEx(ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			Vector2 ret;
			ImGuiPNative.ScrollToRectEx(&ret, window, rect, flags);
			return ret;
		}
		public static void ScrollToRectEx(Vector2* pOut, ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			ImGuiPNative.ScrollToRectEx(pOut, window, rect, flags);
		}
		public static void ScrollToRectEx(Vector2* pOut, ImGuiWindowPtr window, ImRect rect)
		{
			ImGuiPNative.ScrollToRectEx(pOut, window, rect, (ImGuiScrollFlags)(0));
		}
		public static void ScrollToRectEx(ref Vector2 pOut, ImGuiWindowPtr window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ScrollToRectEx((Vector2*)ppOut, window, rect, flags);
			}
		}
		public static void ScrollToRectEx(ref Vector2 pOut, ImGuiWindowPtr window, ImRect rect)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.ScrollToRectEx((Vector2*)ppOut, window, rect, (ImGuiScrollFlags)(0));
			}
		}
		public static Vector2 ScrollToRectEx(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ImGuiPNative.ScrollToRectEx(&ret, (ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
				return ret;
			}
		}
		public static Vector2 ScrollToRectEx(ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ImGuiPNative.ScrollToRectEx(&ret, (ImGuiWindow*)pwindow, rect, flags);
				return ret;
			}
		}
		public static void ScrollToRectEx(Vector2* pOut, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.ScrollToRectEx(pOut, (ImGuiWindow*)pwindow, rect, flags);
			}
		}
		public static void ScrollToRectEx(Vector2* pOut, ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.ScrollToRectEx(pOut, (ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
			}
		}
		public static void ScrollToRectEx(ref Vector2 pOut, ref ImGuiWindow window, ImRect rect, ImGuiScrollFlags flags)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.ScrollToRectEx((Vector2*)ppOut, (ImGuiWindow*)pwindow, rect, flags);
				}
			}
		}
		public static void ScrollToRectEx(ref Vector2 pOut, ref ImGuiWindow window, ImRect rect)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.ScrollToRectEx((Vector2*)ppOut, (ImGuiWindow*)pwindow, rect, (ImGuiScrollFlags)(0));
				}
			}
		}
		public static void ScrollToBringRectIntoView(ImGuiWindowPtr window, ImRect rect)
		{
			ImGuiPNative.ScrollToBringRectIntoView(window, rect);
		}
		public static void ScrollToBringRectIntoView(ref ImGuiWindow window, ImRect rect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.ScrollToBringRectIntoView((ImGuiWindow*)pwindow, rect);
			}
		}
		public static uint GetItemID()
		{
			uint ret = ImGuiPNative.GetItemID();
			return ret;
		}
		public static ImGuiItemStatusFlags GetItemStatusFlags()
		{
			ImGuiItemStatusFlags ret = ImGuiPNative.GetItemStatusFlags();
			return ret;
		}
		public static ImGuiItemFlags GetItemFlags()
		{
			ImGuiItemFlags ret = ImGuiPNative.GetItemFlags();
			return ret;
		}
		public static uint GetActiveID()
		{
			uint ret = ImGuiPNative.GetActiveID();
			return ret;
		}
		public static uint GetFocusID()
		{
			uint ret = ImGuiPNative.GetFocusID();
			return ret;
		}
		public static void SetActiveID(uint id, ImGuiWindowPtr window)
		{
			ImGuiPNative.SetActiveID(id, window);
		}
		public static void SetActiveID(uint id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetActiveID(id, (ImGuiWindow*)pwindow);
			}
		}
		public static void SetFocusID(uint id, ImGuiWindowPtr window)
		{
			ImGuiPNative.SetFocusID(id, window);
		}
		public static void SetFocusID(uint id, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetFocusID(id, (ImGuiWindow*)pwindow);
			}
		}
		public static void ClearActiveID()
		{
			ImGuiPNative.ClearActiveID();
		}
		public static uint GetHoveredID()
		{
			uint ret = ImGuiPNative.GetHoveredID();
			return ret;
		}
		public static void SetHoveredID(uint id)
		{
			ImGuiPNative.SetHoveredID(id);
		}
		public static void KeepAliveID(uint id)
		{
			ImGuiPNative.KeepAliveID(id);
		}
		public static void MarkItemEdited(uint id)
		{
			ImGuiPNative.MarkItemEdited(id);
		}
		public static void PushOverrideID(uint id)
		{
			ImGuiPNative.PushOverrideID(id);
		}
		public static void ItemSize(Vector2 size, float textBaselineY)
		{
			ImGuiPNative.ItemSize(size, textBaselineY);
		}
		public static void ItemSize(Vector2 size)
		{
			ImGuiPNative.ItemSize(size, (float)(-1.0f));
		}
		public static void ItemSize(ImRect bb, float textBaselineY)
		{
			ImGuiPNative.ItemSize(bb, textBaselineY);
		}
		public static void ItemSize(ImRect bb)
		{
			ImGuiPNative.ItemSize(bb, (float)(-1.0f));
		}
		public static bool ItemAdd(ImRect bb, uint id, ImRectPtr navBb, ImGuiItemFlags extraFlags)
		{
			byte ret = ImGuiPNative.ItemAdd(bb, id, navBb, extraFlags);
			return ret != 0;
		}
		public static bool ItemAdd(ImRect bb, uint id, ImRectPtr navBb)
		{
			byte ret = ImGuiPNative.ItemAdd(bb, id, navBb, (ImGuiItemFlags)(0));
			return ret != 0;
		}
		public static bool ItemAdd(ImRect bb, uint id)
		{
			byte ret = ImGuiPNative.ItemAdd(bb, id, (ImRect*)(default), (ImGuiItemFlags)(0));
			return ret != 0;
		}
		public static bool ItemAdd(ImRect bb, uint id, ImGuiItemFlags extraFlags)
		{
			byte ret = ImGuiPNative.ItemAdd(bb, id, (ImRect*)(default), extraFlags);
			return ret != 0;
		}
		public static bool ItemAdd(ImRect bb, uint id, ref ImRect navBb, ImGuiItemFlags extraFlags)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ImGuiPNative.ItemAdd(bb, id, (ImRect*)pnavBb, extraFlags);
				return ret != 0;
			}
		}
		public static bool ItemAdd(ImRect bb, uint id, ref ImRect navBb)
		{
			fixed (ImRect* pnavBb = &navBb)
			{
				byte ret = ImGuiPNative.ItemAdd(bb, id, (ImRect*)pnavBb, (ImGuiItemFlags)(0));
				return ret != 0;
			}
		}
		public static bool ItemHoverable(ImRect bb, uint id)
		{
			byte ret = ImGuiPNative.ItemHoverable(bb, id);
			return ret != 0;
		}
		public static bool IsClippedEx(ImRect bb, uint id)
		{
			byte ret = ImGuiPNative.IsClippedEx(bb, id);
			return ret != 0;
		}
		public static void SetLastItemData(uint itemId, ImGuiItemFlags inFlags, ImGuiItemStatusFlags statusFlags, ImRect itemRect)
		{
			ImGuiPNative.SetLastItemData(itemId, inFlags, statusFlags, itemRect);
		}
		public static Vector2 CalcItemSize(Vector2 size, float defaultW, float defaultH)
		{
			Vector2 ret;
			ImGuiPNative.CalcItemSize(&ret, size, defaultW, defaultH);
			return ret;
		}
		public static void CalcItemSize(Vector2* pOut, Vector2 size, float defaultW, float defaultH)
		{
			ImGuiPNative.CalcItemSize(pOut, size, defaultW, defaultH);
		}
		public static void CalcItemSize(ref Vector2 pOut, Vector2 size, float defaultW, float defaultH)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.CalcItemSize((Vector2*)ppOut, size, defaultW, defaultH);
			}
		}
		public static float CalcWrapWidthForPos(Vector2 pos, float wrapPosX)
		{
			float ret = ImGuiPNative.CalcWrapWidthForPos(pos, wrapPosX);
			return ret;
		}
		public static void PushMultiItemsWidths(int components, float widthFull)
		{
			ImGuiPNative.PushMultiItemsWidths(components, widthFull);
		}
		public static bool IsItemToggledSelection()
		{
			byte ret = ImGuiPNative.IsItemToggledSelection();
			return ret != 0;
		}
		public static Vector2 GetContentRegionMaxAbs()
		{
			Vector2 ret;
			ImGuiPNative.GetContentRegionMaxAbs(&ret);
			return ret;
		}
		public static void GetContentRegionMaxAbs(Vector2* pOut)
		{
			ImGuiPNative.GetContentRegionMaxAbs(pOut);
		}
		public static void GetContentRegionMaxAbs(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetContentRegionMaxAbs((Vector2*)ppOut);
			}
		}
		public static void ShrinkWidths(ImGuiShrinkWidthItemPtr items, int count, float widthExcess)
		{
			ImGuiPNative.ShrinkWidths(items, count, widthExcess);
		}
		public static void ShrinkWidths(ref ImGuiShrinkWidthItem items, int count, float widthExcess)
		{
			fixed (ImGuiShrinkWidthItem* pitems = &items)
			{
				ImGuiPNative.ShrinkWidths((ImGuiShrinkWidthItem*)pitems, count, widthExcess);
			}
		}
		public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
		{
			ImGuiPNative.PushItemFlag(option, enabled ? (byte)1 : (byte)0);
		}
		public static void PopItemFlag()
		{
			ImGuiPNative.PopItemFlag();
		}
		public static void LogBegin(ImGuiLogType type, int autoOpenDepth)
		{
			ImGuiPNative.LogBegin(type, autoOpenDepth);
		}
		public static void LogToBuffer(int autoOpenDepth)
		{
			ImGuiPNative.LogToBuffer(autoOpenDepth);
		}
		public static void LogToBuffer()
		{
			ImGuiPNative.LogToBuffer((int)(-1));
		}
		public static void LogSetNextTextDecoration(byte* prefix, byte* suffix)
		{
			ImGuiPNative.LogSetNextTextDecoration(prefix, suffix);
		}
		public static void LogSetNextTextDecoration(ref byte prefix, byte* suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, suffix);
			}
		}
		public static void LogSetNextTextDecoration(ReadOnlySpan<byte> prefix, byte* suffix)
		{
			fixed (byte* pprefix = prefix)
			{
				ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, suffix);
			}
		}
		public static void LogSetNextTextDecoration(string prefix, byte* suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.LogSetNextTextDecoration(pStr0, suffix);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LogSetNextTextDecoration(byte* prefix, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				ImGuiPNative.LogSetNextTextDecoration(prefix, (byte*)psuffix);
			}
		}
		public static void LogSetNextTextDecoration(byte* prefix, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* psuffix = suffix)
			{
				ImGuiPNative.LogSetNextTextDecoration(prefix, (byte*)psuffix);
			}
		}
		public static void LogSetNextTextDecoration(byte* prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.LogSetNextTextDecoration(prefix, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LogSetNextTextDecoration(ref byte prefix, ref byte suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* psuffix = &suffix)
				{
					ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, (byte*)psuffix);
				}
			}
		}
		public static void LogSetNextTextDecoration(ReadOnlySpan<byte> prefix, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* pprefix = prefix)
			{
				fixed (byte* psuffix = suffix)
				{
					ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, (byte*)psuffix);
				}
			}
		}
		public static void LogSetNextTextDecoration(string prefix, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (suffix != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(suffix, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiPNative.LogSetNextTextDecoration(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void LogSetNextTextDecoration(ref byte prefix, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				fixed (byte* psuffix = suffix)
				{
					ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, (byte*)psuffix);
				}
			}
		}
		public static void LogSetNextTextDecoration(ref byte prefix, string suffix)
		{
			fixed (byte* pprefix = &prefix)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (suffix != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(suffix);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void LogSetNextTextDecoration(ReadOnlySpan<byte> prefix, ref byte suffix)
		{
			fixed (byte* pprefix = prefix)
			{
				fixed (byte* psuffix = &suffix)
				{
					ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, (byte*)psuffix);
				}
			}
		}
		public static void LogSetNextTextDecoration(ReadOnlySpan<byte> prefix, string suffix)
		{
			fixed (byte* pprefix = prefix)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (suffix != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(suffix);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.LogSetNextTextDecoration((byte*)pprefix, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void LogSetNextTextDecoration(string prefix, ref byte suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* psuffix = &suffix)
			{
				ImGuiPNative.LogSetNextTextDecoration(pStr0, (byte*)psuffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void LogSetNextTextDecoration(string prefix, ReadOnlySpan<byte> suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (prefix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(prefix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(prefix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* psuffix = suffix)
			{
				ImGuiPNative.LogSetNextTextDecoration(pStr0, (byte*)psuffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static bool BeginChildEx(byte* name, uint id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			byte ret = ImGuiPNative.BeginChildEx(name, id, sizeArg, border ? (byte)1 : (byte)0, flags);
			return ret != 0;
		}
		public static bool BeginChildEx(ref byte name, uint id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginChildEx((byte*)pname, id, sizeArg, border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}
		public static bool BeginChildEx(ReadOnlySpan<byte> name, uint id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginChildEx((byte*)pname, id, sizeArg, border ? (byte)1 : (byte)0, flags);
				return ret != 0;
			}
		}
		public static bool BeginChildEx(string name, uint id, Vector2 sizeArg, bool border, ImGuiWindowFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginChildEx(pStr0, id, sizeArg, border ? (byte)1 : (byte)0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void OpenPopupEx(uint id, ImGuiPopupFlags popupFlags)
		{
			ImGuiPNative.OpenPopupEx(id, popupFlags);
		}
		public static void OpenPopupEx(uint id)
		{
			ImGuiPNative.OpenPopupEx(id, (ImGuiPopupFlags)(ImGuiPopupFlags.None));
		}
		public static void ClosePopupToLevel(int remaining, bool restoreFocusToWindowUnderPopup)
		{
			ImGuiPNative.ClosePopupToLevel(remaining, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}
		public static void ClosePopupsOverWindow(ImGuiWindowPtr refWindow, bool restoreFocusToWindowUnderPopup)
		{
			ImGuiPNative.ClosePopupsOverWindow(refWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
		}
		public static void ClosePopupsOverWindow(ref ImGuiWindow refWindow, bool restoreFocusToWindowUnderPopup)
		{
			fixed (ImGuiWindow* prefWindow = &refWindow)
			{
				ImGuiPNative.ClosePopupsOverWindow((ImGuiWindow*)prefWindow, restoreFocusToWindowUnderPopup ? (byte)1 : (byte)0);
			}
		}
		public static void ClosePopupsExceptModals()
		{
			ImGuiPNative.ClosePopupsExceptModals();
		}
		public static bool IsPopupOpen(uint id, ImGuiPopupFlags popupFlags)
		{
			byte ret = ImGuiPNative.IsPopupOpen(id, popupFlags);
			return ret != 0;
		}
		public static bool BeginPopupEx(uint id, ImGuiWindowFlags extraFlags)
		{
			byte ret = ImGuiPNative.BeginPopupEx(id, extraFlags);
			return ret != 0;
		}
		public static void BeginTooltipEx(ImGuiTooltipFlags tooltipFlags, ImGuiWindowFlags extraWindowFlags)
		{
			ImGuiPNative.BeginTooltipEx(tooltipFlags, extraWindowFlags);
		}
		public static ImRect GetPopupAllowedExtentRect(ImGuiWindowPtr window)
		{
			ImRect ret;
			ImGuiPNative.GetPopupAllowedExtentRect(&ret, window);
			return ret;
		}
		public static void GetPopupAllowedExtentRect(ImRectPtr pOut, ImGuiWindowPtr window)
		{
			ImGuiPNative.GetPopupAllowedExtentRect(pOut, window);
		}
		public static void GetPopupAllowedExtentRect(ref ImRect pOut, ImGuiWindowPtr window)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.GetPopupAllowedExtentRect((ImRect*)ppOut, window);
			}
		}
		public static ImRect GetPopupAllowedExtentRect(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				ImGuiPNative.GetPopupAllowedExtentRect(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}
		public static void GetPopupAllowedExtentRect(ImRectPtr pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.GetPopupAllowedExtentRect(pOut, (ImGuiWindow*)pwindow);
			}
		}
		public static void GetPopupAllowedExtentRect(ref ImRect pOut, ref ImGuiWindow window)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.GetPopupAllowedExtentRect((ImRect*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}
		public static ImGuiWindowPtr GetTopMostPopupModal()
		{
			ImGuiWindowPtr ret = ImGuiPNative.GetTopMostPopupModal();
			return ret;
		}
		public static ImGuiWindowPtr GetTopMostAndVisiblePopupModal()
		{
			ImGuiWindowPtr ret = ImGuiPNative.GetTopMostAndVisiblePopupModal();
			return ret;
		}
		public static Vector2 FindBestWindowPosForPopup(ImGuiWindowPtr window)
		{
			Vector2 ret;
			ImGuiPNative.FindBestWindowPosForPopup(&ret, window);
			return ret;
		}
		public static void FindBestWindowPosForPopup(Vector2* pOut, ImGuiWindowPtr window)
		{
			ImGuiPNative.FindBestWindowPosForPopup(pOut, window);
		}
		public static void FindBestWindowPosForPopup(ref Vector2 pOut, ImGuiWindowPtr window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.FindBestWindowPosForPopup((Vector2*)ppOut, window);
			}
		}
		public static Vector2 FindBestWindowPosForPopup(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				Vector2 ret;
				ImGuiPNative.FindBestWindowPosForPopup(&ret, (ImGuiWindow*)pwindow);
				return ret;
			}
		}
		public static void FindBestWindowPosForPopup(Vector2* pOut, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.FindBestWindowPosForPopup(pOut, (ImGuiWindow*)pwindow);
			}
		}
		public static void FindBestWindowPosForPopup(ref Vector2 pOut, ref ImGuiWindow window)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.FindBestWindowPosForPopup((Vector2*)ppOut, (ImGuiWindow*)pwindow);
				}
			}
		}
		public static Vector2 FindBestWindowPosForPopupEx(Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			Vector2 ret;
			ImGuiPNative.FindBestWindowPosForPopupEx(&ret, refPos, size, lastDir, rOuter, rAvoid, policy);
			return ret;
		}
		public static void FindBestWindowPosForPopupEx(Vector2* pOut, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			ImGuiPNative.FindBestWindowPosForPopupEx(pOut, refPos, size, lastDir, rOuter, rAvoid, policy);
		}
		public static void FindBestWindowPosForPopupEx(ref Vector2 pOut, Vector2 refPos, Vector2 size, ImGuiDir* lastDir, ImRect rOuter, ImRect rAvoid, ImGuiPopupPositionPolicy policy)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.FindBestWindowPosForPopupEx((Vector2*)ppOut, refPos, size, lastDir, rOuter, rAvoid, policy);
			}
		}
		public static bool BeginViewportSideBar(byte* name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte ret = ImGuiPNative.BeginViewportSideBar(name, viewport, dir, size, windowFlags);
			return ret != 0;
		}
		public static bool BeginViewportSideBar(ref byte name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginViewportSideBar((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}
		public static bool BeginViewportSideBar(ReadOnlySpan<byte> name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginViewportSideBar((byte*)pname, viewport, dir, size, windowFlags);
				return ret != 0;
			}
		}
		public static bool BeginViewportSideBar(string name, ImGuiViewportPtr viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginViewportSideBar(pStr0, viewport, dir, size, windowFlags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginViewportSideBar(byte* name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = ImGuiPNative.BeginViewportSideBar(name, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				return ret != 0;
			}
		}
		public static bool BeginViewportSideBar(ref byte name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = &name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = ImGuiPNative.BeginViewportSideBar((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}
		public static bool BeginViewportSideBar(ReadOnlySpan<byte> name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			fixed (byte* pname = name)
			{
				fixed (ImGuiViewport* pviewport = &viewport)
				{
					byte ret = ImGuiPNative.BeginViewportSideBar((byte*)pname, (ImGuiViewport*)pviewport, dir, size, windowFlags);
					return ret != 0;
				}
			}
		}
		public static bool BeginViewportSideBar(string name, ref ImGuiViewport viewport, ImGuiDir dir, float size, ImGuiWindowFlags windowFlags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				byte ret = ImGuiPNative.BeginViewportSideBar(pStr0, (ImGuiViewport*)pviewport, dir, size, windowFlags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(byte* label, byte* icon, bool enabled)
		{
			byte ret = ImGuiPNative.BeginMenuEx(label, icon, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool BeginMenuEx(byte* label, byte* icon)
		{
			byte ret = ImGuiPNative.BeginMenuEx(label, icon, (byte)(1));
			return ret != 0;
		}
		public static bool BeginMenuEx(ref byte label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(ref byte label, byte* icon)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, icon, (byte)(1));
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, byte* icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, icon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, byte* icon)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, icon, (byte)(1));
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(string label, byte* icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginMenuEx(pStr0, icon, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenuEx(string label, byte* icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginMenuEx(pStr0, icon, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenuEx(byte* label, ref byte icon, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(byte* label, ref byte icon)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(label, (byte*)picon, (byte)(1));
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(byte* label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(label, (byte*)picon, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(byte* label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(label, (byte*)picon, (byte)(1));
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(byte* label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginMenuEx(label, pStr0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenuEx(byte* label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginMenuEx(label, pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenuEx(ref byte label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ref byte label, ref byte icon)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(string label, string icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.BeginMenuEx(pStr0, pStr1, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenuEx(string label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.BeginMenuEx(pStr0, pStr1, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginMenuEx(ref byte label, ReadOnlySpan<byte> icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ref byte label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ref byte label, string icon, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, pStr0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(ref byte label, string icon)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, pStr0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ref byte icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, ref byte icon)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, (byte*)picon, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, string icon, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, pStr0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(ReadOnlySpan<byte> label, string icon)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.BeginMenuEx((byte*)plabel, pStr0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(string label, ref byte icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(pStr0, (byte*)picon, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(string label, ref byte icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(pStr0, (byte*)picon, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(string label, ReadOnlySpan<byte> icon, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(pStr0, (byte*)picon, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginMenuEx(string label, ReadOnlySpan<byte> icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.BeginMenuEx(pStr0, (byte*)picon, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte ret = ImGuiPNative.MenuItemEx(label, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut, bool selected)
		{
			byte ret = ImGuiPNative.MenuItemEx(label, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut)
		{
			byte ret = ImGuiPNative.MenuItemEx(label, icon, shortcut, (byte)(0), (byte)(1));
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon)
		{
			byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)(default), (byte)(0), (byte)(1));
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon, bool selected)
		{
			byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon, bool selected, bool enabled)
		{
			byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, shortcut, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, byte* shortcut)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, byte* shortcut)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, shortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, bool selected)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, shortcut, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, shortcut, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)(default), (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, byte* shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, shortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)(default), (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, shortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, byte* shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, byte* shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, byte* shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, shortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)(default), (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, shortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, byte* shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, byte* shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, shortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)(default), (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut, bool selected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, ref byte shortcut)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, icon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, byte* icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, icon, pStr0, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, byte* icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, pStr1, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(ref byte label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, byte* icon, string shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, pStr0, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, ref byte shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, byte* icon, string shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, icon, pStr0, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, ref byte shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, ref byte shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, ref byte shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, byte* icon, ReadOnlySpan<byte> shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, icon, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, ref byte shortcut)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, string icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (shortcut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(label, pStr0, pStr1, (byte)(0), (byte)(1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(byte* label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = &icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, string shortcut, bool selected)
		{
			fixed (byte* picon = &icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ref byte icon, string shortcut)
		{
			fixed (byte* picon = &icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, pStr0, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, ref byte shortcut)
		{
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* picon = icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, string shortcut, bool selected)
		{
			fixed (byte* picon = icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, ReadOnlySpan<byte> icon, string shortcut)
		{
			fixed (byte* picon = icon)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (shortcut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(label, (byte*)picon, pStr0, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, ref byte shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, ref byte shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, ref byte shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(byte* label, string icon, ReadOnlySpan<byte> shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (icon != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(icon);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(label, pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, pStr2, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(string label, string icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (shortcut != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(shortcut, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, pStr2, (byte)(0), (byte)(1));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ref byte icon, string shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = &icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, ReadOnlySpan<byte> icon, string shortcut)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* picon = icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, ref byte shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ref byte label, string icon, string shortcut)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, pStr1, (byte)(0), (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, ref byte shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					fixed (byte* pshortcut = shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ref byte icon, string shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = &icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, ref byte shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					fixed (byte* pshortcut = &shortcut)
					{
						byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
						return ret != 0;
					}
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, ReadOnlySpan<byte> icon, string shortcut)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* picon = icon)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (shortcut != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(shortcut);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, (byte*)picon, pStr0, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, ref byte shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, ref byte shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, ref byte shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, ReadOnlySpan<byte> shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, string shortcut, bool selected, bool enabled)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, string shortcut, bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(ReadOnlySpan<byte> label, string icon, string shortcut)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (icon != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(icon);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(icon, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx((byte*)plabel, pStr0, pStr1, (byte)(0), (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, ref byte shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, ref byte shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, ref byte shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, ReadOnlySpan<byte> shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ref byte icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = &icon)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, pStr1, (byte)(0), (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, ref byte shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, ref byte shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = &shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, ReadOnlySpan<byte> shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				fixed (byte* pshortcut = shortcut)
				{
					byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, (byte*)pshortcut, (byte)(0), (byte)(1));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, string shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, pStr1, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, string shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, pStr1, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, ReadOnlySpan<byte> icon, string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* picon = icon)
			{
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (shortcut != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(shortcut);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(shortcut, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGuiPNative.MenuItemEx(pStr0, (byte*)picon, pStr1, (byte)(0), (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, string icon, ref byte shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, string icon, ref byte shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, string icon, ref byte shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, string icon, ReadOnlySpan<byte> shortcut, bool selected, bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, string icon, ReadOnlySpan<byte> shortcut, bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool MenuItemEx(string label, string icon, ReadOnlySpan<byte> shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (icon != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(icon);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(icon, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte* pshortcut = shortcut)
			{
				byte ret = ImGuiPNative.MenuItemEx(pStr0, pStr1, (byte*)pshortcut, (byte)(0), (byte)(1));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool BeginComboPopup(uint popupId, ImRect bb, ImGuiComboFlags flags)
		{
			byte ret = ImGuiPNative.BeginComboPopup(popupId, bb, flags);
			return ret != 0;
		}
		public static bool BeginComboPreview()
		{
			byte ret = ImGuiPNative.BeginComboPreview();
			return ret != 0;
		}
		public static void EndComboPreview()
		{
			ImGuiPNative.EndComboPreview();
		}
		public static void NavInitWindow(ImGuiWindowPtr window, bool forceReinit)
		{
			ImGuiPNative.NavInitWindow(window, forceReinit ? (byte)1 : (byte)0);
		}
		public static void NavInitWindow(ref ImGuiWindow window, bool forceReinit)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.NavInitWindow((ImGuiWindow*)pwindow, forceReinit ? (byte)1 : (byte)0);
			}
		}
		public static void NavInitRequestApplyResult()
		{
			ImGuiPNative.NavInitRequestApplyResult();
		}
		public static bool NavMoveRequestButNoResultYet()
		{
			byte ret = ImGuiPNative.NavMoveRequestButNoResultYet();
			return ret != 0;
		}
		public static void NavMoveRequestSubmit(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			ImGuiPNative.NavMoveRequestSubmit(moveDir, clipDir, moveFlags, scrollFlags);
		}
		public static void NavMoveRequestForward(ImGuiDir moveDir, ImGuiDir clipDir, ImGuiNavMoveFlags moveFlags, ImGuiScrollFlags scrollFlags)
		{
			ImGuiPNative.NavMoveRequestForward(moveDir, clipDir, moveFlags, scrollFlags);
		}
		public static void NavMoveRequestResolveWithLastItem(ImGuiNavItemDataPtr result)
		{
			ImGuiPNative.NavMoveRequestResolveWithLastItem(result);
		}
		public static void NavMoveRequestResolveWithLastItem(ref ImGuiNavItemData result)
		{
			fixed (ImGuiNavItemData* presult = &result)
			{
				ImGuiPNative.NavMoveRequestResolveWithLastItem((ImGuiNavItemData*)presult);
			}
		}
		public static void NavMoveRequestCancel()
		{
			ImGuiPNative.NavMoveRequestCancel();
		}
		public static void NavMoveRequestApplyResult()
		{
			ImGuiPNative.NavMoveRequestApplyResult();
		}
		public static void NavMoveRequestTryWrapping(ImGuiWindowPtr window, ImGuiNavMoveFlags moveFlags)
		{
			ImGuiPNative.NavMoveRequestTryWrapping(window, moveFlags);
		}
		public static void NavMoveRequestTryWrapping(ref ImGuiWindow window, ImGuiNavMoveFlags moveFlags)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.NavMoveRequestTryWrapping((ImGuiWindow*)pwindow, moveFlags);
			}
		}
		public static byte* GetNavInputName(ImGuiNavInput n)
		{
			byte* ret = ImGuiPNative.GetNavInputName(n);
			return ret;
		}
		public static string GetNavInputNameS(ImGuiNavInput n)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.GetNavInputName(n));
			return ret;
		}
		public static float GetNavInputAmount(ImGuiNavInput n, ImGuiNavReadMode mode)
		{
			float ret = ImGuiPNative.GetNavInputAmount(n, mode);
			return ret;
		}
		public static Vector2 GetNavInputAmount2d(ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode)
		{
			Vector2 ret;
			ImGuiPNative.GetNavInputAmount2d(&ret, dirSources, mode, (float)(0.0f), (float)(0.0f));
			return ret;
		}
		public static Vector2 GetNavInputAmount2d(ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode, float slowFactor)
		{
			Vector2 ret;
			ImGuiPNative.GetNavInputAmount2d(&ret, dirSources, mode, slowFactor, (float)(0.0f));
			return ret;
		}
		public static void GetNavInputAmount2d(Vector2* pOut, ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode)
		{
			ImGuiPNative.GetNavInputAmount2d(pOut, dirSources, mode, (float)(0.0f), (float)(0.0f));
		}
		public static Vector2 GetNavInputAmount2d(ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode, float slowFactor, float fastFactor)
		{
			Vector2 ret;
			ImGuiPNative.GetNavInputAmount2d(&ret, dirSources, mode, slowFactor, fastFactor);
			return ret;
		}
		public static void GetNavInputAmount2d(Vector2* pOut, ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode, float slowFactor, float fastFactor)
		{
			ImGuiPNative.GetNavInputAmount2d(pOut, dirSources, mode, slowFactor, fastFactor);
		}
		public static void GetNavInputAmount2d(Vector2* pOut, ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode, float slowFactor)
		{
			ImGuiPNative.GetNavInputAmount2d(pOut, dirSources, mode, slowFactor, (float)(0.0f));
		}
		public static void GetNavInputAmount2d(ref Vector2 pOut, ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode, float slowFactor, float fastFactor)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetNavInputAmount2d((Vector2*)ppOut, dirSources, mode, slowFactor, fastFactor);
			}
		}
		public static void GetNavInputAmount2d(ref Vector2 pOut, ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode, float slowFactor)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetNavInputAmount2d((Vector2*)ppOut, dirSources, mode, slowFactor, (float)(0.0f));
			}
		}
		public static void GetNavInputAmount2d(ref Vector2 pOut, ImGuiNavDirSourceFlags dirSources, ImGuiNavReadMode mode)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.GetNavInputAmount2d((Vector2*)ppOut, dirSources, mode, (float)(0.0f), (float)(0.0f));
			}
		}
		public static int CalcTypematicRepeatAmount(float t0, float t1, float repeatDelay, float repeatRate)
		{
			int ret = ImGuiPNative.CalcTypematicRepeatAmount(t0, t1, repeatDelay, repeatRate);
			return ret;
		}
		public static void ActivateItem(uint id)
		{
			ImGuiPNative.ActivateItem(id);
		}
		public static void SetNavWindow(ImGuiWindowPtr window)
		{
			ImGuiPNative.SetNavWindow(window);
		}
		public static void SetNavWindow(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetNavWindow((ImGuiWindow*)pwindow);
			}
		}
		public static void SetNavID(uint id, ImGuiNavLayer navLayer, uint focusScopeId, ImRect rectRel)
		{
			ImGuiPNative.SetNavID(id, navLayer, focusScopeId, rectRel);
		}
		public static void PushFocusScope(uint id)
		{
			ImGuiPNative.PushFocusScope(id);
		}
		public static void PopFocusScope()
		{
			ImGuiPNative.PopFocusScope();
		}
		public static uint GetFocusedFocusScope()
		{
			uint ret = ImGuiPNative.GetFocusedFocusScope();
			return ret;
		}
		public static uint GetFocusScope()
		{
			uint ret = ImGuiPNative.GetFocusScope();
			return ret;
		}
		public static bool IsNamedKey(ImGuiKey key)
		{
			byte ret = ImGuiPNative.IsNamedKey(key);
			return ret != 0;
		}
		public static bool IsLegacyKey(ImGuiKey key)
		{
			byte ret = ImGuiPNative.IsLegacyKey(key);
			return ret != 0;
		}
		public static bool IsGamepadKey(ImGuiKey key)
		{
			byte ret = ImGuiPNative.IsGamepadKey(key);
			return ret != 0;
		}
		public static ImGuiKeyDataPtr GetKeyData(ImGuiKey key)
		{
			ImGuiKeyDataPtr ret = ImGuiPNative.GetKeyData(key);
			return ret;
		}
		public static void SetItemUsingMouseWheel()
		{
			ImGuiPNative.SetItemUsingMouseWheel();
		}
		public static void SetActiveIdUsingNavAndKeys()
		{
			ImGuiPNative.SetActiveIdUsingNavAndKeys();
		}
		public static bool IsActiveIdUsingNavDir(ImGuiDir dir)
		{
			byte ret = ImGuiPNative.IsActiveIdUsingNavDir(dir);
			return ret != 0;
		}
		public static bool IsActiveIdUsingNavInput(ImGuiNavInput input)
		{
			byte ret = ImGuiPNative.IsActiveIdUsingNavInput(input);
			return ret != 0;
		}
		public static bool IsActiveIdUsingKey(ImGuiKey key)
		{
			byte ret = ImGuiPNative.IsActiveIdUsingKey(key);
			return ret != 0;
		}
		public static void SetActiveIdUsingKey(ImGuiKey key)
		{
			ImGuiPNative.SetActiveIdUsingKey(key);
		}
		public static bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = ImGuiPNative.IsMouseDragPastThreshold(button, lockThreshold);
			return ret != 0;
		}
		public static bool IsMouseDragPastThreshold(ImGuiMouseButton button)
		{
			byte ret = ImGuiPNative.IsMouseDragPastThreshold(button, (float)(-1.0f));
			return ret != 0;
		}
		public static bool IsNavInputDown(ImGuiNavInput n)
		{
			byte ret = ImGuiPNative.IsNavInputDown(n);
			return ret != 0;
		}
		public static bool IsNavInputTest(ImGuiNavInput n, ImGuiNavReadMode rm)
		{
			byte ret = ImGuiPNative.IsNavInputTest(n, rm);
			return ret != 0;
		}
		public static ImGuiModFlags GetMergedModFlags()
		{
			ImGuiModFlags ret = ImGuiPNative.GetMergedModFlags();
			return ret;
		}
		public static bool IsKeyPressedMap(ImGuiKey key, bool repeat)
		{
			byte ret = ImGuiPNative.IsKeyPressedMap(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}
		public static bool IsKeyPressedMap(ImGuiKey key)
		{
			byte ret = ImGuiPNative.IsKeyPressedMap(key, (byte)(1));
			return ret != 0;
		}
		public static void DockContextInitialize(ImGuiContextPtr ctx)
		{
			ImGuiPNative.DockContextInitialize(ctx);
		}
		public static void DockContextInitialize(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextInitialize((ImGuiContext*)pctx);
			}
		}
		public static void DockContextShutdown(ImGuiContextPtr ctx)
		{
			ImGuiPNative.DockContextShutdown(ctx);
		}
		public static void DockContextShutdown(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextShutdown((ImGuiContext*)pctx);
			}
		}
		public static void DockContextClearNodes(ImGuiContextPtr ctx, uint rootId, bool clearSettingsRefs)
		{
			ImGuiPNative.DockContextClearNodes(ctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
		}
		public static void DockContextClearNodes(ref ImGuiContext ctx, uint rootId, bool clearSettingsRefs)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextClearNodes((ImGuiContext*)pctx, rootId, clearSettingsRefs ? (byte)1 : (byte)0);
			}
		}
		public static void DockContextRebuildNodes(ImGuiContextPtr ctx)
		{
			ImGuiPNative.DockContextRebuildNodes(ctx);
		}
		public static void DockContextRebuildNodes(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextRebuildNodes((ImGuiContext*)pctx);
			}
		}
		public static void DockContextNewFrameUpdateUndocking(ImGuiContextPtr ctx)
		{
			ImGuiPNative.DockContextNewFrameUpdateUndocking(ctx);
		}
		public static void DockContextNewFrameUpdateUndocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextNewFrameUpdateUndocking((ImGuiContext*)pctx);
			}
		}
		public static void DockContextNewFrameUpdateDocking(ImGuiContextPtr ctx)
		{
			ImGuiPNative.DockContextNewFrameUpdateDocking(ctx);
		}
		public static void DockContextNewFrameUpdateDocking(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextNewFrameUpdateDocking((ImGuiContext*)pctx);
			}
		}
		public static void DockContextEndFrame(ImGuiContextPtr ctx)
		{
			ImGuiPNative.DockContextEndFrame(ctx);
		}
		public static void DockContextEndFrame(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextEndFrame((ImGuiContext*)pctx);
			}
		}
		public static uint DockContextGenNodeID(ImGuiContextPtr ctx)
		{
			uint ret = ImGuiPNative.DockContextGenNodeID(ctx);
			return ret;
		}
		public static uint DockContextGenNodeID(ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				uint ret = ImGuiPNative.DockContextGenNodeID((ImGuiContext*)pctx);
				return ret;
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			ImGuiPNative.DockContextQueueDock(ctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, target, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				ImGuiPNative.DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				ImGuiPNative.DockContextQueueDock(ctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					ImGuiPNative.DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				ImGuiPNative.DockContextQueueDock(ctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					ImGuiPNative.DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					ImGuiPNative.DockContextQueueDock(ctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}
		public static void DockContextQueueDock(ImGuiContextPtr ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						ImGuiPNative.DockContextQueueDock(ctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
					}
				}
			}
		}
		public static void DockContextQueueDock(ref ImGuiContext ctx, ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, float splitRatio, bool splitOuter)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* ptarget = &target)
				{
					fixed (ImGuiDockNode* ptargetNode = &targetNode)
					{
						fixed (ImGuiWindow* ppayload = &payload)
						{
							ImGuiPNative.DockContextQueueDock((ImGuiContext*)pctx, (ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitRatio, splitOuter ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}
		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ImGuiWindowPtr window)
		{
			ImGuiPNative.DockContextQueueUndockWindow(ctx, window);
		}
		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ImGuiWindowPtr window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextQueueUndockWindow((ImGuiContext*)pctx, window);
			}
		}
		public static void DockContextQueueUndockWindow(ImGuiContextPtr ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.DockContextQueueUndockWindow(ctx, (ImGuiWindow*)pwindow);
			}
		}
		public static void DockContextQueueUndockWindow(ref ImGuiContext ctx, ref ImGuiWindow window)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.DockContextQueueUndockWindow((ImGuiContext*)pctx, (ImGuiWindow*)pwindow);
				}
			}
		}
		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ImGuiDockNodePtr node)
		{
			ImGuiPNative.DockContextQueueUndockNode(ctx, node);
		}
		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ImGuiDockNodePtr node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiPNative.DockContextQueueUndockNode((ImGuiContext*)pctx, node);
			}
		}
		public static void DockContextQueueUndockNode(ImGuiContextPtr ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiPNative.DockContextQueueUndockNode(ctx, (ImGuiDockNode*)pnode);
			}
		}
		public static void DockContextQueueUndockNode(ref ImGuiContext ctx, ref ImGuiDockNode node)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				fixed (ImGuiDockNode* pnode = &node)
				{
					ImGuiPNative.DockContextQueueUndockNode((ImGuiContext*)pctx, (ImGuiDockNode*)pnode);
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, targetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
			return ret != 0;
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
				return ret != 0;
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
					return ret != 0;
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, Vector2* outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, outPos);
						return ret != 0;
					}
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (Vector2* poutPos = &outPos)
			{
				byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, targetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
				return ret != 0;
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ImGuiWindowPtr payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, payload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ppayload = &payload)
			{
				fixed (Vector2* poutPos = &outPos)
				{
					byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, targetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
					return ret != 0;
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ImGuiDockNodePtr targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, targetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ImGuiWindowPtr target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiDockNode* ptargetNode = &targetNode)
			{
				fixed (ImGuiWindow* ppayload = &payload)
				{
					fixed (Vector2* poutPos = &outPos)
					{
						byte ret = ImGuiPNative.DockContextCalcDropPosForDocking(target, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
						return ret != 0;
					}
				}
			}
		}
		public static bool DockContextCalcDropPosForDocking(ref ImGuiWindow target, ref ImGuiDockNode targetNode, ref ImGuiWindow payload, ImGuiDir splitDir, bool splitOuter, ref Vector2 outPos)
		{
			fixed (ImGuiWindow* ptarget = &target)
			{
				fixed (ImGuiDockNode* ptargetNode = &targetNode)
				{
					fixed (ImGuiWindow* ppayload = &payload)
					{
						fixed (Vector2* poutPos = &outPos)
						{
							byte ret = ImGuiPNative.DockContextCalcDropPosForDocking((ImGuiWindow*)ptarget, (ImGuiDockNode*)ptargetNode, (ImGuiWindow*)ppayload, splitDir, splitOuter ? (byte)1 : (byte)0, (Vector2*)poutPos);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool DockNodeBeginAmendTabBar(ImGuiDockNodePtr node)
		{
			byte ret = ImGuiPNative.DockNodeBeginAmendTabBar(node);
			return ret != 0;
		}
		public static bool DockNodeBeginAmendTabBar(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = ImGuiPNative.DockNodeBeginAmendTabBar((ImGuiDockNode*)pnode);
				return ret != 0;
			}
		}
		public static void DockNodeEndAmendTabBar()
		{
			ImGuiPNative.DockNodeEndAmendTabBar();
		}
		public static ImGuiDockNodePtr DockNodeGetRootNode(ImGuiDockNodePtr node)
		{
			ImGuiDockNodePtr ret = ImGuiPNative.DockNodeGetRootNode(node);
			return ret;
		}
		public static ImGuiDockNodePtr DockNodeGetRootNode(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiDockNodePtr ret = ImGuiPNative.DockNodeGetRootNode((ImGuiDockNode*)pnode);
				return ret;
			}
		}
		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ImGuiDockNodePtr parent)
		{
			byte ret = ImGuiPNative.DockNodeIsInHierarchyOf(node, parent);
			return ret != 0;
		}
		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ImGuiDockNodePtr parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte ret = ImGuiPNative.DockNodeIsInHierarchyOf((ImGuiDockNode*)pnode, parent);
				return ret != 0;
			}
		}
		public static bool DockNodeIsInHierarchyOf(ImGuiDockNodePtr node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pparent = &parent)
			{
				byte ret = ImGuiPNative.DockNodeIsInHierarchyOf(node, (ImGuiDockNode*)pparent);
				return ret != 0;
			}
		}
		public static bool DockNodeIsInHierarchyOf(ref ImGuiDockNode node, ref ImGuiDockNode parent)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (ImGuiDockNode* pparent = &parent)
				{
					byte ret = ImGuiPNative.DockNodeIsInHierarchyOf((ImGuiDockNode*)pnode, (ImGuiDockNode*)pparent);
					return ret != 0;
				}
			}
		}
		public static int DockNodeGetDepth(ImGuiDockNodePtr node)
		{
			int ret = ImGuiPNative.DockNodeGetDepth(node);
			return ret;
		}
		public static int DockNodeGetDepth(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				int ret = ImGuiPNative.DockNodeGetDepth((ImGuiDockNode*)pnode);
				return ret;
			}
		}
		public static uint DockNodeGetWindowMenuButtonId(ImGuiDockNodePtr node)
		{
			uint ret = ImGuiPNative.DockNodeGetWindowMenuButtonId(node);
			return ret;
		}
		public static uint DockNodeGetWindowMenuButtonId(ref ImGuiDockNode node)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				uint ret = ImGuiPNative.DockNodeGetWindowMenuButtonId((ImGuiDockNode*)pnode);
				return ret;
			}
		}
		public static ImGuiDockNodePtr GetWindowDockNode()
		{
			ImGuiDockNodePtr ret = ImGuiPNative.GetWindowDockNode();
			return ret;
		}
		public static bool GetWindowAlwaysWantOwnTabBar(ImGuiWindowPtr window)
		{
			byte ret = ImGuiPNative.GetWindowAlwaysWantOwnTabBar(window);
			return ret != 0;
		}
		public static bool GetWindowAlwaysWantOwnTabBar(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte ret = ImGuiPNative.GetWindowAlwaysWantOwnTabBar((ImGuiWindow*)pwindow);
				return ret != 0;
			}
		}
		public static void BeginDocked(ImGuiWindowPtr window, bool* pOpen)
		{
			ImGuiPNative.BeginDocked(window, pOpen);
		}
		public static void BeginDocked(ref ImGuiWindow window, bool* pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BeginDocked((ImGuiWindow*)pwindow, pOpen);
			}
		}
		public static void BeginDocked(ImGuiWindowPtr window, ref bool pOpen)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				ImGuiPNative.BeginDocked(window, (bool*)ppOpen);
			}
		}
		public static void BeginDocked(ref ImGuiWindow window, ref bool pOpen)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					ImGuiPNative.BeginDocked((ImGuiWindow*)pwindow, (bool*)ppOpen);
				}
			}
		}
		public static void BeginDockableDragDropSource(ImGuiWindowPtr window)
		{
			ImGuiPNative.BeginDockableDragDropSource(window);
		}
		public static void BeginDockableDragDropSource(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BeginDockableDragDropSource((ImGuiWindow*)pwindow);
			}
		}
		public static void BeginDockableDragDropTarget(ImGuiWindowPtr window)
		{
			ImGuiPNative.BeginDockableDragDropTarget(window);
		}
		public static void BeginDockableDragDropTarget(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.BeginDockableDragDropTarget((ImGuiWindow*)pwindow);
			}
		}
		public static void SetWindowDock(ImGuiWindowPtr window, uint dockId, ImGuiCond cond)
		{
			ImGuiPNative.SetWindowDock(window, dockId, cond);
		}
		public static void SetWindowDock(ref ImGuiWindow window, uint dockId, ImGuiCond cond)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowDock((ImGuiWindow*)pwindow, dockId, cond);
			}
		}
		public static void DockBuilderDockWindow(byte* windowName, uint nodeId)
		{
			ImGuiPNative.DockBuilderDockWindow(windowName, nodeId);
		}
		public static void DockBuilderDockWindow(ref byte windowName, uint nodeId)
		{
			fixed (byte* pwindowName = &windowName)
			{
				ImGuiPNative.DockBuilderDockWindow((byte*)pwindowName, nodeId);
			}
		}
		public static void DockBuilderDockWindow(ReadOnlySpan<byte> windowName, uint nodeId)
		{
			fixed (byte* pwindowName = windowName)
			{
				ImGuiPNative.DockBuilderDockWindow((byte*)pwindowName, nodeId);
			}
		}
		public static void DockBuilderDockWindow(string windowName, uint nodeId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (windowName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(windowName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(windowName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DockBuilderDockWindow(pStr0, nodeId);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static ImGuiDockNodePtr DockBuilderGetNode(uint nodeId)
		{
			ImGuiDockNodePtr ret = ImGuiPNative.DockBuilderGetNode(nodeId);
			return ret;
		}
		public static ImGuiDockNodePtr DockBuilderGetCentralNode(uint nodeId)
		{
			ImGuiDockNodePtr ret = ImGuiPNative.DockBuilderGetCentralNode(nodeId);
			return ret;
		}
		public static uint DockBuilderAddNode(uint nodeId, ImGuiDockNodeFlags flags)
		{
			uint ret = ImGuiPNative.DockBuilderAddNode(nodeId, flags);
			return ret;
		}
		public static uint DockBuilderAddNode(uint nodeId)
		{
			uint ret = ImGuiPNative.DockBuilderAddNode(nodeId, (ImGuiDockNodeFlags)(0));
			return ret;
		}
		public static uint DockBuilderAddNode()
		{
			uint ret = ImGuiPNative.DockBuilderAddNode((uint)(0), (ImGuiDockNodeFlags)(0));
			return ret;
		}
		public static uint DockBuilderAddNode(ImGuiDockNodeFlags flags)
		{
			uint ret = ImGuiPNative.DockBuilderAddNode((uint)(0), flags);
			return ret;
		}
		public static void DockBuilderRemoveNode(uint nodeId)
		{
			ImGuiPNative.DockBuilderRemoveNode(nodeId);
		}
		public static void DockBuilderRemoveNodeDockedWindows(uint nodeId, bool clearSettingsRefs)
		{
			ImGuiPNative.DockBuilderRemoveNodeDockedWindows(nodeId, clearSettingsRefs ? (byte)1 : (byte)0);
		}
		public static void DockBuilderRemoveNodeDockedWindows(uint nodeId)
		{
			ImGuiPNative.DockBuilderRemoveNodeDockedWindows(nodeId, (byte)(1));
		}
		public static void DockBuilderRemoveNodeChildNodes(uint nodeId)
		{
			ImGuiPNative.DockBuilderRemoveNodeChildNodes(nodeId);
		}
		public static void DockBuilderSetNodePos(uint nodeId, Vector2 pos)
		{
			ImGuiPNative.DockBuilderSetNodePos(nodeId, pos);
		}
		public static void DockBuilderSetNodeSize(uint nodeId, Vector2 size)
		{
			ImGuiPNative.DockBuilderSetNodeSize(nodeId, size);
		}
		public static uint DockBuilderSplitNode(uint nodeId, ImGuiDir splitDir, float sizeRatioForNodeAtDir, uint* outIdAtDir, uint* outIdAtOppositeDir)
		{
			uint ret = ImGuiPNative.DockBuilderSplitNode(nodeId, splitDir, sizeRatioForNodeAtDir, outIdAtDir, outIdAtOppositeDir);
			return ret;
		}
		public static void DockBuilderCopyDockSpace(uint srcDockspaceId, uint dstDockspaceId, ImVector<ConstPointer<byte>>* inWindowRemapPairs)
		{
			ImGuiPNative.DockBuilderCopyDockSpace(srcDockspaceId, dstDockspaceId, inWindowRemapPairs);
		}
		public static void DockBuilderCopyDockSpace(uint srcDockspaceId, uint dstDockspaceId, ref ImVector<ConstPointer<byte>> inWindowRemapPairs)
		{
			fixed (ImVector<ConstPointer<byte>>* pinWindowRemapPairs = &inWindowRemapPairs)
			{
				ImGuiPNative.DockBuilderCopyDockSpace(srcDockspaceId, dstDockspaceId, (ImVector<ConstPointer<byte>>*)pinWindowRemapPairs);
			}
		}
		public static void DockBuilderCopyNode(uint srcNodeId, uint dstNodeId, ImVector<uint>* outNodeRemapPairs)
		{
			ImGuiPNative.DockBuilderCopyNode(srcNodeId, dstNodeId, outNodeRemapPairs);
		}
		public static void DockBuilderCopyNode(uint srcNodeId, uint dstNodeId, ref ImVector<uint> outNodeRemapPairs)
		{
			fixed (ImVector<uint>* poutNodeRemapPairs = &outNodeRemapPairs)
			{
				ImGuiPNative.DockBuilderCopyNode(srcNodeId, dstNodeId, (ImVector<uint>*)poutNodeRemapPairs);
			}
		}
		public static void DockBuilderCopyWindowSettings(byte* srcName, byte* dstName)
		{
			ImGuiPNative.DockBuilderCopyWindowSettings(srcName, dstName);
		}
		public static void DockBuilderCopyWindowSettings(ref byte srcName, byte* dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, dstName);
			}
		}
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, byte* dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, dstName);
			}
		}
		public static void DockBuilderCopyWindowSettings(string srcName, byte* dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DockBuilderCopyWindowSettings(pStr0, dstName);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DockBuilderCopyWindowSettings(byte* srcName, ref byte dstName)
		{
			fixed (byte* pdstName = &dstName)
			{
				ImGuiPNative.DockBuilderCopyWindowSettings(srcName, (byte*)pdstName);
			}
		}
		public static void DockBuilderCopyWindowSettings(byte* srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* pdstName = dstName)
			{
				ImGuiPNative.DockBuilderCopyWindowSettings(srcName, (byte*)pdstName);
			}
		}
		public static void DockBuilderCopyWindowSettings(byte* srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dstName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DockBuilderCopyWindowSettings(srcName, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DockBuilderCopyWindowSettings(ref byte srcName, ref byte dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, (byte*)pdstName);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				fixed (byte* pdstName = dstName)
				{
					ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, (byte*)pdstName);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(string srcName, string dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (dstName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(dstName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(dstName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGuiPNative.DockBuilderCopyWindowSettings(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DockBuilderCopyWindowSettings(ref byte srcName, ReadOnlySpan<byte> dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				fixed (byte* pdstName = dstName)
				{
					ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, (byte*)pdstName);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(ref byte srcName, string dstName)
		{
			fixed (byte* psrcName = &srcName)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (dstName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(dstName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, ref byte dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				fixed (byte* pdstName = &dstName)
				{
					ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, (byte*)pdstName);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(ReadOnlySpan<byte> srcName, string dstName)
		{
			fixed (byte* psrcName = srcName)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (dstName != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(dstName);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(dstName, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DockBuilderCopyWindowSettings((byte*)psrcName, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(string srcName, ref byte dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pdstName = &dstName)
			{
				ImGuiPNative.DockBuilderCopyWindowSettings(pStr0, (byte*)pdstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DockBuilderCopyWindowSettings(string srcName, ReadOnlySpan<byte> dstName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (srcName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(srcName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(srcName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pdstName = dstName)
			{
				ImGuiPNative.DockBuilderCopyWindowSettings(pStr0, (byte*)pdstName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DockBuilderFinish(uint nodeId)
		{
			ImGuiPNative.DockBuilderFinish(nodeId);
		}
		public static bool IsDragDropActive()
		{
			byte ret = ImGuiPNative.IsDragDropActive();
			return ret != 0;
		}
		public static bool BeginDragDropTargetCustom(ImRect bb, uint id)
		{
			byte ret = ImGuiPNative.BeginDragDropTargetCustom(bb, id);
			return ret != 0;
		}
		public static void ClearDragDrop()
		{
			ImGuiPNative.ClearDragDrop();
		}
		public static bool IsDragDropPayloadBeingAccepted()
		{
			byte ret = ImGuiPNative.IsDragDropPayloadBeingAccepted();
			return ret != 0;
		}
		public static void SetWindowClipRectBeforeSetChannel(ImGuiWindowPtr window, ImRect clipRect)
		{
			ImGuiPNative.SetWindowClipRectBeforeSetChannel(window, clipRect);
		}
		public static void SetWindowClipRectBeforeSetChannel(ref ImGuiWindow window, ImRect clipRect)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.SetWindowClipRectBeforeSetChannel((ImGuiWindow*)pwindow, clipRect);
			}
		}
		public static void BeginColumns(byte* strId, int count, ImGuiOldColumnFlags flags)
		{
			ImGuiPNative.BeginColumns(strId, count, flags);
		}
		public static void BeginColumns(byte* strId, int count)
		{
			ImGuiPNative.BeginColumns(strId, count, (ImGuiOldColumnFlags)(0));
		}
		public static void BeginColumns(ref byte strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiPNative.BeginColumns((byte*)pstrId, count, flags);
			}
		}
		public static void BeginColumns(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				ImGuiPNative.BeginColumns((byte*)pstrId, count, (ImGuiOldColumnFlags)(0));
			}
		}
		public static void BeginColumns(ReadOnlySpan<byte> strId, int count, ImGuiOldColumnFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiPNative.BeginColumns((byte*)pstrId, count, flags);
			}
		}
		public static void BeginColumns(ReadOnlySpan<byte> strId, int count)
		{
			fixed (byte* pstrId = strId)
			{
				ImGuiPNative.BeginColumns((byte*)pstrId, count, (ImGuiOldColumnFlags)(0));
			}
		}
		public static void BeginColumns(string strId, int count, ImGuiOldColumnFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.BeginColumns(pStr0, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void BeginColumns(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.BeginColumns(pStr0, count, (ImGuiOldColumnFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void EndColumns()
		{
			ImGuiPNative.EndColumns();
		}
		public static void PushColumnClipRect(int columnIndex)
		{
			ImGuiPNative.PushColumnClipRect(columnIndex);
		}
		public static void PushColumnsBackground()
		{
			ImGuiPNative.PushColumnsBackground();
		}
		public static void PopColumnsBackground()
		{
			ImGuiPNative.PopColumnsBackground();
		}
		public static uint GetColumnsID(byte* strId, int count)
		{
			uint ret = ImGuiPNative.GetColumnsID(strId, count);
			return ret;
		}
		public static uint GetColumnsID(ref byte strId, int count)
		{
			fixed (byte* pstrId = &strId)
			{
				uint ret = ImGuiPNative.GetColumnsID((byte*)pstrId, count);
				return ret;
			}
		}
		public static uint GetColumnsID(ReadOnlySpan<byte> strId, int count)
		{
			fixed (byte* pstrId = strId)
			{
				uint ret = ImGuiPNative.GetColumnsID((byte*)pstrId, count);
				return ret;
			}
		}
		public static uint GetColumnsID(string strId, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = ImGuiPNative.GetColumnsID(pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static ImGuiOldColumnsPtr FindOrCreateColumns(ImGuiWindowPtr window, uint id)
		{
			ImGuiOldColumnsPtr ret = ImGuiPNative.FindOrCreateColumns(window, id);
			return ret;
		}
		public static ImGuiOldColumnsPtr FindOrCreateColumns(ref ImGuiWindow window, uint id)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiOldColumnsPtr ret = ImGuiPNative.FindOrCreateColumns((ImGuiWindow*)pwindow, id);
				return ret;
			}
		}
		public static float GetColumnOffsetFromNorm(ImGuiOldColumnsPtr columns, float offsetNorm)
		{
			float ret = ImGuiPNative.GetColumnOffsetFromNorm(columns, offsetNorm);
			return ret;
		}
		public static float GetColumnOffsetFromNorm(ref ImGuiOldColumns columns, float offsetNorm)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = ImGuiPNative.GetColumnOffsetFromNorm((ImGuiOldColumns*)pcolumns, offsetNorm);
				return ret;
			}
		}
		public static float GetColumnNormFromOffset(ImGuiOldColumnsPtr columns, float offset)
		{
			float ret = ImGuiPNative.GetColumnNormFromOffset(columns, offset);
			return ret;
		}
		public static float GetColumnNormFromOffset(ref ImGuiOldColumns columns, float offset)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				float ret = ImGuiPNative.GetColumnNormFromOffset((ImGuiOldColumns*)pcolumns, offset);
				return ret;
			}
		}
		public static void TableOpenContextMenu(int columnN)
		{
			ImGuiPNative.TableOpenContextMenu(columnN);
		}
		public static void TableOpenContextMenu()
		{
			ImGuiPNative.TableOpenContextMenu((int)(-1));
		}
		public static void TableSetColumnWidth(int columnN, float width)
		{
			ImGuiPNative.TableSetColumnWidth(columnN, width);
		}
		public static void TableSetColumnSortDirection(int columnN, ImGuiSortDirection sortDirection, bool appendToSortSpecs)
		{
			ImGuiPNative.TableSetColumnSortDirection(columnN, sortDirection, appendToSortSpecs ? (byte)1 : (byte)0);
		}
		public static int TableGetHoveredColumn()
		{
			int ret = ImGuiPNative.TableGetHoveredColumn();
			return ret;
		}
		public static float TableGetHeaderRowHeight()
		{
			float ret = ImGuiPNative.TableGetHeaderRowHeight();
			return ret;
		}
		public static void TablePushBackgroundChannel()
		{
			ImGuiPNative.TablePushBackgroundChannel();
		}
		public static void TablePopBackgroundChannel()
		{
			ImGuiPNative.TablePopBackgroundChannel();
		}
		public static ImGuiTablePtr GetCurrentTable()
		{
			ImGuiTablePtr ret = ImGuiPNative.GetCurrentTable();
			return ret;
		}
		public static ImGuiTablePtr TableFindByID(uint id)
		{
			ImGuiTablePtr ret = ImGuiPNative.TableFindByID(id);
			return ret;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, flags, outerSize, innerWidth);
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, flags, outerSize, (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, Vector2 outerSize)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, float innerWidth)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
			return ret != 0;
		}
		public static bool BeginTableEx(byte* name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			byte ret = ImGuiPNative.BeginTableEx(name, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
			return ret != 0;
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, Vector2 outerSize)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ref byte name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = &name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, Vector2 outerSize)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(ReadOnlySpan<byte> name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			fixed (byte* pname = name)
			{
				byte ret = ImGuiPNative.BeginTableEx((byte*)pname, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
				return ret != 0;
			}
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, flags, outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, flags, outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, Vector2 outerSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, (ImGuiTableFlags)(0), outerSize, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, ImGuiTableFlags flags, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, flags, (Vector2)(new Vector2(0,0)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, (ImGuiTableFlags)(0), (Vector2)(new Vector2(0,0)), innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool BeginTableEx(string name, uint id, int columnsCount, Vector2 outerSize, float innerWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.BeginTableEx(pStr0, id, columnsCount, (ImGuiTableFlags)(0), outerSize, innerWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void TableBeginInitMemory(ImGuiTablePtr table, int columnsCount)
		{
			ImGuiPNative.TableBeginInitMemory(table, columnsCount);
		}
		public static void TableBeginInitMemory(ref ImGuiTable table, int columnsCount)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableBeginInitMemory((ImGuiTable*)ptable, columnsCount);
			}
		}
		public static void TableBeginApplyRequests(ImGuiTablePtr table)
		{
			ImGuiPNative.TableBeginApplyRequests(table);
		}
		public static void TableBeginApplyRequests(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableBeginApplyRequests((ImGuiTable*)ptable);
			}
		}
		public static void TableSetupDrawChannels(ImGuiTablePtr table)
		{
			ImGuiPNative.TableSetupDrawChannels(table);
		}
		public static void TableSetupDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableSetupDrawChannels((ImGuiTable*)ptable);
			}
		}
		public static void TableUpdateLayout(ImGuiTablePtr table)
		{
			ImGuiPNative.TableUpdateLayout(table);
		}
		public static void TableUpdateLayout(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableUpdateLayout((ImGuiTable*)ptable);
			}
		}
		public static void TableUpdateBorders(ImGuiTablePtr table)
		{
			ImGuiPNative.TableUpdateBorders(table);
		}
		public static void TableUpdateBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableUpdateBorders((ImGuiTable*)ptable);
			}
		}
		public static void TableUpdateColumnsWeightFromWidth(ImGuiTablePtr table)
		{
			ImGuiPNative.TableUpdateColumnsWeightFromWidth(table);
		}
		public static void TableUpdateColumnsWeightFromWidth(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableUpdateColumnsWeightFromWidth((ImGuiTable*)ptable);
			}
		}
		public static void TableDrawBorders(ImGuiTablePtr table)
		{
			ImGuiPNative.TableDrawBorders(table);
		}
		public static void TableDrawBorders(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableDrawBorders((ImGuiTable*)ptable);
			}
		}
		public static void TableDrawContextMenu(ImGuiTablePtr table)
		{
			ImGuiPNative.TableDrawContextMenu(table);
		}
		public static void TableDrawContextMenu(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableDrawContextMenu((ImGuiTable*)ptable);
			}
		}
		public static void TableMergeDrawChannels(ImGuiTablePtr table)
		{
			ImGuiPNative.TableMergeDrawChannels(table);
		}
		public static void TableMergeDrawChannels(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableMergeDrawChannels((ImGuiTable*)ptable);
			}
		}
		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ImGuiTablePtr table, int instanceNo)
		{
			ImGuiTableInstanceDataPtr ret = ImGuiPNative.TableGetInstanceData(table, instanceNo);
			return ret;
		}
		public static ImGuiTableInstanceDataPtr TableGetInstanceData(ref ImGuiTable table, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableInstanceDataPtr ret = ImGuiPNative.TableGetInstanceData((ImGuiTable*)ptable, instanceNo);
				return ret;
			}
		}
		public static void TableSortSpecsSanitize(ImGuiTablePtr table)
		{
			ImGuiPNative.TableSortSpecsSanitize(table);
		}
		public static void TableSortSpecsSanitize(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableSortSpecsSanitize((ImGuiTable*)ptable);
			}
		}
		public static void TableSortSpecsBuild(ImGuiTablePtr table)
		{
			ImGuiPNative.TableSortSpecsBuild(table);
		}
		public static void TableSortSpecsBuild(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableSortSpecsBuild((ImGuiTable*)ptable);
			}
		}
		public static ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumnPtr column)
		{
			ImGuiSortDirection ret = ImGuiPNative.TableGetColumnNextSortDirection(column);
			return ret;
		}
		public static ImGuiSortDirection TableGetColumnNextSortDirection(ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiSortDirection ret = ImGuiPNative.TableGetColumnNextSortDirection((ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}
		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			ImGuiPNative.TableFixColumnSortDirection(table, column);
		}
		public static void TableFixColumnSortDirection(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableFixColumnSortDirection((ImGuiTable*)ptable, column);
			}
		}
		public static void TableFixColumnSortDirection(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				ImGuiPNative.TableFixColumnSortDirection(table, (ImGuiTableColumn*)pcolumn);
			}
		}
		public static void TableFixColumnSortDirection(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					ImGuiPNative.TableFixColumnSortDirection((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
				}
			}
		}
		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ImGuiTableColumnPtr column)
		{
			float ret = ImGuiPNative.TableGetColumnWidthAuto(table, column);
			return ret;
		}
		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ImGuiTableColumnPtr column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = ImGuiPNative.TableGetColumnWidthAuto((ImGuiTable*)ptable, column);
				return ret;
			}
		}
		public static float TableGetColumnWidthAuto(ImGuiTablePtr table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTableColumn* pcolumn = &column)
			{
				float ret = ImGuiPNative.TableGetColumnWidthAuto(table, (ImGuiTableColumn*)pcolumn);
				return ret;
			}
		}
		public static float TableGetColumnWidthAuto(ref ImGuiTable table, ref ImGuiTableColumn column)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				fixed (ImGuiTableColumn* pcolumn = &column)
				{
					float ret = ImGuiPNative.TableGetColumnWidthAuto((ImGuiTable*)ptable, (ImGuiTableColumn*)pcolumn);
					return ret;
				}
			}
		}
		public static void TableBeginRow(ImGuiTablePtr table)
		{
			ImGuiPNative.TableBeginRow(table);
		}
		public static void TableBeginRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableBeginRow((ImGuiTable*)ptable);
			}
		}
		public static void TableEndRow(ImGuiTablePtr table)
		{
			ImGuiPNative.TableEndRow(table);
		}
		public static void TableEndRow(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableEndRow((ImGuiTable*)ptable);
			}
		}
		public static void TableBeginCell(ImGuiTablePtr table, int columnN)
		{
			ImGuiPNative.TableBeginCell(table, columnN);
		}
		public static void TableBeginCell(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableBeginCell((ImGuiTable*)ptable, columnN);
			}
		}
		public static void TableEndCell(ImGuiTablePtr table)
		{
			ImGuiPNative.TableEndCell(table);
		}
		public static void TableEndCell(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableEndCell((ImGuiTable*)ptable);
			}
		}
		public static ImRect TableGetCellBgRect(ImGuiTablePtr table, int columnN)
		{
			ImRect ret;
			ImGuiPNative.TableGetCellBgRect(&ret, table, columnN);
			return ret;
		}
		public static void TableGetCellBgRect(ImRectPtr pOut, ImGuiTablePtr table, int columnN)
		{
			ImGuiPNative.TableGetCellBgRect(pOut, table, columnN);
		}
		public static void TableGetCellBgRect(ref ImRect pOut, ImGuiTablePtr table, int columnN)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.TableGetCellBgRect((ImRect*)ppOut, table, columnN);
			}
		}
		public static ImRect TableGetCellBgRect(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImRect ret;
				ImGuiPNative.TableGetCellBgRect(&ret, (ImGuiTable*)ptable, columnN);
				return ret;
			}
		}
		public static void TableGetCellBgRect(ImRectPtr pOut, ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableGetCellBgRect(pOut, (ImGuiTable*)ptable, columnN);
			}
		}
		public static void TableGetCellBgRect(ref ImRect pOut, ref ImGuiTable table, int columnN)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiTable* ptable = &table)
				{
					ImGuiPNative.TableGetCellBgRect((ImRect*)ppOut, (ImGuiTable*)ptable, columnN);
				}
			}
		}
		public static byte* TableGetColumnName(ImGuiTablePtr table, int columnN)
		{
			byte* ret = ImGuiPNative.TableGetColumnName(table, columnN);
			return ret;
		}
		public static byte* TableGetColumnName(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				byte* ret = ImGuiPNative.TableGetColumnName((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}
		public static string TableGetColumnNameS(ImGuiTablePtr table, int columnN)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiPNative.TableGetColumnName(table, columnN));
			return ret;
		}
		public static string TableGetColumnNameS(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiPNative.TableGetColumnName((ImGuiTable*)ptable, columnN));
				return ret;
			}
		}
		public static uint TableGetColumnResizeID(ImGuiTablePtr table, int columnN, int instanceNo)
		{
			uint ret = ImGuiPNative.TableGetColumnResizeID(table, columnN, instanceNo);
			return ret;
		}
		public static uint TableGetColumnResizeID(ImGuiTablePtr table, int columnN)
		{
			uint ret = ImGuiPNative.TableGetColumnResizeID(table, columnN, (int)(0));
			return ret;
		}
		public static uint TableGetColumnResizeID(ref ImGuiTable table, int columnN, int instanceNo)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				uint ret = ImGuiPNative.TableGetColumnResizeID((ImGuiTable*)ptable, columnN, instanceNo);
				return ret;
			}
		}
		public static uint TableGetColumnResizeID(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				uint ret = ImGuiPNative.TableGetColumnResizeID((ImGuiTable*)ptable, columnN, (int)(0));
				return ret;
			}
		}
		public static float TableGetMaxColumnWidth(ImGuiTablePtr table, int columnN)
		{
			float ret = ImGuiPNative.TableGetMaxColumnWidth(table, columnN);
			return ret;
		}
		public static float TableGetMaxColumnWidth(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				float ret = ImGuiPNative.TableGetMaxColumnWidth((ImGuiTable*)ptable, columnN);
				return ret;
			}
		}
		public static void TableSetColumnWidthAutoSingle(ImGuiTablePtr table, int columnN)
		{
			ImGuiPNative.TableSetColumnWidthAutoSingle(table, columnN);
		}
		public static void TableSetColumnWidthAutoSingle(ref ImGuiTable table, int columnN)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableSetColumnWidthAutoSingle((ImGuiTable*)ptable, columnN);
			}
		}
		public static void TableSetColumnWidthAutoAll(ImGuiTablePtr table)
		{
			ImGuiPNative.TableSetColumnWidthAutoAll(table);
		}
		public static void TableSetColumnWidthAutoAll(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableSetColumnWidthAutoAll((ImGuiTable*)ptable);
			}
		}
		public static void TableRemove(ImGuiTablePtr table)
		{
			ImGuiPNative.TableRemove(table);
		}
		public static void TableRemove(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableRemove((ImGuiTable*)ptable);
			}
		}
		public static void TableGcCompactTransientBuffers(ImGuiTablePtr table)
		{
			ImGuiPNative.TableGcCompactTransientBuffers(table);
		}
		public static void TableGcCompactTransientBuffers(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableGcCompactTransientBuffers((ImGuiTable*)ptable);
			}
		}
		public static void TableGcCompactTransientBuffers(ImGuiTableTempDataPtr table)
		{
			ImGuiPNative.TableGcCompactTransientBuffers(table);
		}
		public static void TableGcCompactTransientBuffers(ref ImGuiTableTempData table)
		{
			fixed (ImGuiTableTempData* ptable = &table)
			{
				ImGuiPNative.TableGcCompactTransientBuffers((ImGuiTableTempData*)ptable);
			}
		}
		public static void TableGcCompactSettings()
		{
			ImGuiPNative.TableGcCompactSettings();
		}
		public static void TableLoadSettings(ImGuiTablePtr table)
		{
			ImGuiPNative.TableLoadSettings(table);
		}
		public static void TableLoadSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableLoadSettings((ImGuiTable*)ptable);
			}
		}
		public static void TableSaveSettings(ImGuiTablePtr table)
		{
			ImGuiPNative.TableSaveSettings(table);
		}
		public static void TableSaveSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableSaveSettings((ImGuiTable*)ptable);
			}
		}
		public static void TableResetSettings(ImGuiTablePtr table)
		{
			ImGuiPNative.TableResetSettings(table);
		}
		public static void TableResetSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.TableResetSettings((ImGuiTable*)ptable);
			}
		}
		public static ImGuiTableSettingsPtr TableGetBoundSettings(ImGuiTablePtr table)
		{
			ImGuiTableSettingsPtr ret = ImGuiPNative.TableGetBoundSettings(table);
			return ret;
		}
		public static ImGuiTableSettingsPtr TableGetBoundSettings(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiTableSettingsPtr ret = ImGuiPNative.TableGetBoundSettings((ImGuiTable*)ptable);
				return ret;
			}
		}
		public static void TableSettingsAddSettingsHandler()
		{
			ImGuiPNative.TableSettingsAddSettingsHandler();
		}
		public static ImGuiTableSettingsPtr TableSettingsCreate(uint id, int columnsCount)
		{
			ImGuiTableSettingsPtr ret = ImGuiPNative.TableSettingsCreate(id, columnsCount);
			return ret;
		}
		public static ImGuiTableSettingsPtr TableSettingsFindByID(uint id)
		{
			ImGuiTableSettingsPtr ret = ImGuiPNative.TableSettingsFindByID(id);
			return ret;
		}
		public static bool BeginTabBarEx(ImGuiTabBarPtr tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNodePtr dockNode)
		{
			byte ret = ImGuiPNative.BeginTabBarEx(tabBar, bb, flags, dockNode);
			return ret != 0;
		}
		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNodePtr dockNode)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = ImGuiPNative.BeginTabBarEx((ImGuiTabBar*)ptabBar, bb, flags, dockNode);
				return ret != 0;
			}
		}
		public static bool BeginTabBarEx(ImGuiTabBarPtr tabBar, ImRect bb, ImGuiTabBarFlags flags, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiDockNode* pdockNode = &dockNode)
			{
				byte ret = ImGuiPNative.BeginTabBarEx(tabBar, bb, flags, (ImGuiDockNode*)pdockNode);
				return ret != 0;
			}
		}
		public static bool BeginTabBarEx(ref ImGuiTabBar tabBar, ImRect bb, ImGuiTabBarFlags flags, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiDockNode* pdockNode = &dockNode)
				{
					byte ret = ImGuiPNative.BeginTabBarEx((ImGuiTabBar*)ptabBar, bb, flags, (ImGuiDockNode*)pdockNode);
					return ret != 0;
				}
			}
		}
		public static ImGuiTabItemPtr TabBarFindTabByID(ImGuiTabBarPtr tabBar, uint tabId)
		{
			ImGuiTabItemPtr ret = ImGuiPNative.TabBarFindTabByID(tabBar, tabId);
			return ret;
		}
		public static ImGuiTabItemPtr TabBarFindTabByID(ref ImGuiTabBar tabBar, uint tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = ImGuiPNative.TabBarFindTabByID((ImGuiTabBar*)ptabBar, tabId);
				return ret;
			}
		}
		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBarPtr tabBar)
		{
			ImGuiTabItemPtr ret = ImGuiPNative.TabBarFindMostRecentlySelectedTabForActiveWindow(tabBar);
			return ret;
		}
		public static ImGuiTabItemPtr TabBarFindMostRecentlySelectedTabForActiveWindow(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiTabItemPtr ret = ImGuiPNative.TabBarFindMostRecentlySelectedTabForActiveWindow((ImGuiTabBar*)ptabBar);
				return ret;
			}
		}
		public static void TabBarAddTab(ImGuiTabBarPtr tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindowPtr window)
		{
			ImGuiPNative.TabBarAddTab(tabBar, tabFlags, window);
		}
		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ImGuiWindowPtr window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiPNative.TabBarAddTab((ImGuiTabBar*)ptabBar, tabFlags, window);
			}
		}
		public static void TabBarAddTab(ImGuiTabBarPtr tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.TabBarAddTab(tabBar, tabFlags, (ImGuiWindow*)pwindow);
			}
		}
		public static void TabBarAddTab(ref ImGuiTabBar tabBar, ImGuiTabItemFlags tabFlags, ref ImGuiWindow window)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.TabBarAddTab((ImGuiTabBar*)ptabBar, tabFlags, (ImGuiWindow*)pwindow);
				}
			}
		}
		public static void TabBarRemoveTab(ImGuiTabBarPtr tabBar, uint tabId)
		{
			ImGuiPNative.TabBarRemoveTab(tabBar, tabId);
		}
		public static void TabBarRemoveTab(ref ImGuiTabBar tabBar, uint tabId)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiPNative.TabBarRemoveTab((ImGuiTabBar*)ptabBar, tabId);
			}
		}
		public static void TabBarCloseTab(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab)
		{
			ImGuiPNative.TabBarCloseTab(tabBar, tab);
		}
		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiPNative.TabBarCloseTab((ImGuiTabBar*)ptabBar, tab);
			}
		}
		public static void TabBarCloseTab(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				ImGuiPNative.TabBarCloseTab(tabBar, (ImGuiTabItem*)ptab);
			}
		}
		public static void TabBarCloseTab(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					ImGuiPNative.TabBarCloseTab((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab);
				}
			}
		}
		public static void TabBarQueueReorder(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab, int offset)
		{
			ImGuiPNative.TabBarQueueReorder(tabBar, tab, offset);
		}
		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiPNative.TabBarQueueReorder((ImGuiTabBar*)ptabBar, tab, offset);
			}
		}
		public static void TabBarQueueReorder(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				ImGuiPNative.TabBarQueueReorder(tabBar, (ImGuiTabItem*)ptab, offset);
			}
		}
		public static void TabBarQueueReorder(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, int offset)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					ImGuiPNative.TabBarQueueReorder((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, offset);
				}
			}
		}
		public static void TabBarQueueReorderFromMousePos(ImGuiTabBarPtr tabBar, ImGuiTabItemPtr tab, Vector2 mousePos)
		{
			ImGuiPNative.TabBarQueueReorderFromMousePos(tabBar, tab, mousePos);
		}
		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ImGuiTabItemPtr tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiPNative.TabBarQueueReorderFromMousePos((ImGuiTabBar*)ptabBar, tab, mousePos);
			}
		}
		public static void TabBarQueueReorderFromMousePos(ImGuiTabBarPtr tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				ImGuiPNative.TabBarQueueReorderFromMousePos(tabBar, (ImGuiTabItem*)ptab, mousePos);
			}
		}
		public static void TabBarQueueReorderFromMousePos(ref ImGuiTabBar tabBar, ref ImGuiTabItem tab, Vector2 mousePos)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					ImGuiPNative.TabBarQueueReorderFromMousePos((ImGuiTabBar*)ptabBar, (ImGuiTabItem*)ptab, mousePos);
				}
			}
		}
		public static bool TabBarProcessReorder(ImGuiTabBarPtr tabBar)
		{
			byte ret = ImGuiPNative.TabBarProcessReorder(tabBar);
			return ret != 0;
		}
		public static bool TabBarProcessReorder(ref ImGuiTabBar tabBar)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = ImGuiPNative.TabBarProcessReorder((ImGuiTabBar*)ptabBar);
				return ret != 0;
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte ret = ImGuiPNative.TabItemEx(tabBar, label, pOpen, flags, dockedWindow);
			return ret != 0;
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, label, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, pOpen, flags, dockedWindow);
				return ret != 0;
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TabItemEx(tabBar, pStr0, pOpen, flags, dockedWindow);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiPNative.TabItemEx(tabBar, label, (bool*)ppOpen, flags, dockedWindow);
				return ret != 0;
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				byte ret = ImGuiPNative.TabItemEx(tabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, dockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ImGuiWindowPtr dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, dockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = ImGuiPNative.TabItemEx(tabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				return ret != 0;
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, label, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
			{
				byte ret = ImGuiPNative.TabItemEx(tabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, pOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, bool* pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, pStr0, pOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = ImGuiPNative.TabItemEx(tabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, byte* label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, label, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = ImGuiPNative.TabItemEx(tabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						return ret != 0;
					}
				}
			}
		}
		public static bool TabItemEx(ImGuiTabBarPtr tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppOpen = &pOpen)
			{
				fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
				{
					byte ret = ImGuiPNative.TabItemEx(tabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ref byte label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* ppOpen = &pOpen)
					{
						fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
						{
							byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, (byte*)plabel, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
							return ret != 0;
						}
					}
				}
			}
		}
		public static bool TabItemEx(ref ImGuiTabBar tabBar, string label, ref bool pOpen, ImGuiTabItemFlags flags, ref ImGuiWindow dockedWindow)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* ppOpen = &pOpen)
				{
					fixed (ImGuiWindow* pdockedWindow = &dockedWindow)
					{
						byte ret = ImGuiPNative.TabItemEx((ImGuiTabBar*)ptabBar, pStr0, (bool*)ppOpen, flags, (ImGuiWindow*)pdockedWindow);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}
		public static Vector2 TabItemCalcSize(byte* label, bool hasCloseButton)
		{
			Vector2 ret;
			ImGuiPNative.TabItemCalcSize(&ret, label, hasCloseButton ? (byte)1 : (byte)0);
			return ret;
		}
		public static void TabItemCalcSize(Vector2* pOut, byte* label, bool hasCloseButton)
		{
			ImGuiPNative.TabItemCalcSize(pOut, label, hasCloseButton ? (byte)1 : (byte)0);
		}
		public static void TabItemCalcSize(ref Vector2 pOut, byte* label, bool hasCloseButton)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ImGuiPNative.TabItemCalcSize((Vector2*)ppOut, label, hasCloseButton ? (byte)1 : (byte)0);
			}
		}
		public static Vector2 TabItemCalcSize(ref byte label, bool hasCloseButton)
		{
			fixed (byte* plabel = &label)
			{
				Vector2 ret;
				ImGuiPNative.TabItemCalcSize(&ret, (byte*)plabel, hasCloseButton ? (byte)1 : (byte)0);
				return ret;
			}
		}
		public static Vector2 TabItemCalcSize(ReadOnlySpan<byte> label, bool hasCloseButton)
		{
			fixed (byte* plabel = label)
			{
				Vector2 ret;
				ImGuiPNative.TabItemCalcSize(&ret, (byte*)plabel, hasCloseButton ? (byte)1 : (byte)0);
				return ret;
			}
		}
		public static Vector2 TabItemCalcSize(string label, bool hasCloseButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			ImGuiPNative.TabItemCalcSize(&ret, pStr0, hasCloseButton ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static void TabItemCalcSize(ref Vector2 pOut, ref byte label, bool hasCloseButton)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.TabItemCalcSize((Vector2*)ppOut, (byte*)plabel, hasCloseButton ? (byte)1 : (byte)0);
				}
			}
		}
		public static void TabItemCalcSize(ref Vector2 pOut, ReadOnlySpan<byte> label, bool hasCloseButton)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.TabItemCalcSize((Vector2*)ppOut, (byte*)plabel, hasCloseButton ? (byte)1 : (byte)0);
				}
			}
		}
		public static void TabItemCalcSize(ref Vector2 pOut, string label, bool hasCloseButton)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.TabItemCalcSize((Vector2*)ppOut, pStr0, hasCloseButton ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void TabItemCalcSize(Vector2* pOut, ref byte label, bool hasCloseButton)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.TabItemCalcSize(pOut, (byte*)plabel, hasCloseButton ? (byte)1 : (byte)0);
			}
		}
		public static void TabItemCalcSize(Vector2* pOut, ReadOnlySpan<byte> label, bool hasCloseButton)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.TabItemCalcSize(pOut, (byte*)plabel, hasCloseButton ? (byte)1 : (byte)0);
			}
		}
		public static void TabItemCalcSize(Vector2* pOut, string label, bool hasCloseButton)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.TabItemCalcSize(pOut, pStr0, hasCloseButton ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TabItemBackground(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			ImGuiPNative.TabItemBackground(drawList, bb, flags, col);
		}
		public static void TabItemBackground(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.TabItemBackground((ImDrawList*)pdrawList, bb, flags, col);
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, bool* outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, outTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutTextClipped = &outTextClipped)
			{
				ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, bool* outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, outJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, byte* label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, label, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ImDrawListPtr drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* poutJustClosed = &outJustClosed)
			{
				fixed (bool* poutTextClipped = &outTextClipped)
				{
					ImGuiPNative.TabItemLabelAndCloseButton(drawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ref byte label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, ReadOnlySpan<byte> label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					fixed (bool* poutJustClosed = &outJustClosed)
					{
						fixed (bool* poutTextClipped = &outTextClipped)
						{
							ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, (byte*)plabel, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						}
					}
				}
			}
		}
		public static void TabItemLabelAndCloseButton(ref ImDrawList drawList, ImRect bb, ImGuiTabItemFlags flags, Vector2 framePadding, string label, uint tabId, uint closeButtonId, bool isContentsVisible, ref bool outJustClosed, ref bool outTextClipped)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (bool* poutJustClosed = &outJustClosed)
				{
					fixed (bool* poutTextClipped = &outTextClipped)
					{
						ImGuiPNative.TabItemLabelAndCloseButton((ImDrawList*)pdrawList, bb, flags, framePadding, pStr0, tabId, closeButtonId, isContentsVisible ? (byte)1 : (byte)0, (bool*)poutJustClosed, (bool*)poutTextClipped);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}
		public static void RenderFrame(Vector2 pMin, Vector2 pMax, uint fillCol, bool border, float rounding)
		{
			ImGuiPNative.RenderFrame(pMin, pMax, fillCol, border ? (byte)1 : (byte)0, rounding);
		}
		public static void RenderFrame(Vector2 pMin, Vector2 pMax, uint fillCol, bool border)
		{
			ImGuiPNative.RenderFrame(pMin, pMax, fillCol, border ? (byte)1 : (byte)0, (float)(0.0f));
		}
		public static void RenderFrame(Vector2 pMin, Vector2 pMax, uint fillCol)
		{
			ImGuiPNative.RenderFrame(pMin, pMax, fillCol, (byte)(1), (float)(0.0f));
		}
		public static void RenderFrame(Vector2 pMin, Vector2 pMax, uint fillCol, float rounding)
		{
			ImGuiPNative.RenderFrame(pMin, pMax, fillCol, (byte)(1), rounding);
		}
		public static void RenderFrameBorder(Vector2 pMin, Vector2 pMax, float rounding)
		{
			ImGuiPNative.RenderFrameBorder(pMin, pMax, rounding);
		}
		public static void RenderFrameBorder(Vector2 pMin, Vector2 pMax)
		{
			ImGuiPNative.RenderFrameBorder(pMin, pMax, (float)(0.0f));
		}
		public static void RenderColorRectWithAlphaCheckerboard(ImDrawListPtr drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags)
		{
			ImGuiPNative.RenderColorRectWithAlphaCheckerboard(drawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, flags);
		}
		public static void RenderColorRectWithAlphaCheckerboard(ImDrawListPtr drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding)
		{
			ImGuiPNative.RenderColorRectWithAlphaCheckerboard(drawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, (ImDrawFlags)(0));
		}
		public static void RenderColorRectWithAlphaCheckerboard(ImDrawListPtr drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff)
		{
			ImGuiPNative.RenderColorRectWithAlphaCheckerboard(drawList, pMin, pMax, fillCol, gridStep, gridOff, (float)(0.0f), (ImDrawFlags)(0));
		}
		public static void RenderColorRectWithAlphaCheckerboard(ImDrawListPtr drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, ImDrawFlags flags)
		{
			ImGuiPNative.RenderColorRectWithAlphaCheckerboard(drawList, pMin, pMax, fillCol, gridStep, gridOff, (float)(0.0f), flags);
		}
		public static void RenderColorRectWithAlphaCheckerboard(ref ImDrawList drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderColorRectWithAlphaCheckerboard((ImDrawList*)pdrawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, flags);
			}
		}
		public static void RenderColorRectWithAlphaCheckerboard(ref ImDrawList drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderColorRectWithAlphaCheckerboard((ImDrawList*)pdrawList, pMin, pMax, fillCol, gridStep, gridOff, rounding, (ImDrawFlags)(0));
			}
		}
		public static void RenderColorRectWithAlphaCheckerboard(ref ImDrawList drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderColorRectWithAlphaCheckerboard((ImDrawList*)pdrawList, pMin, pMax, fillCol, gridStep, gridOff, (float)(0.0f), (ImDrawFlags)(0));
			}
		}
		public static void RenderColorRectWithAlphaCheckerboard(ref ImDrawList drawList, Vector2 pMin, Vector2 pMax, uint fillCol, float gridStep, Vector2 gridOff, ImDrawFlags flags)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderColorRectWithAlphaCheckerboard((ImDrawList*)pdrawList, pMin, pMax, fillCol, gridStep, gridOff, (float)(0.0f), flags);
			}
		}
		public static void RenderNavHighlight(ImRect bb, uint id, ImGuiNavHighlightFlags flags)
		{
			ImGuiPNative.RenderNavHighlight(bb, id, flags);
		}
		public static void RenderNavHighlight(ImRect bb, uint id)
		{
			ImGuiPNative.RenderNavHighlight(bb, id, (ImGuiNavHighlightFlags)(ImGuiNavHighlightFlags.TypeDefault));
		}
		public static void RenderMouseCursor(Vector2 pos, float scale, ImGuiMouseCursor mouseCursor, uint colFill, uint colBorder, uint colShadow)
		{
			ImGuiPNative.RenderMouseCursor(pos, scale, mouseCursor, colFill, colBorder, colShadow);
		}
		public static void RenderArrow(ImDrawListPtr drawList, Vector2 pos, uint col, ImGuiDir dir, float scale)
		{
			ImGuiPNative.RenderArrow(drawList, pos, col, dir, scale);
		}
		public static void RenderArrow(ImDrawListPtr drawList, Vector2 pos, uint col, ImGuiDir dir)
		{
			ImGuiPNative.RenderArrow(drawList, pos, col, dir, (float)(1.0f));
		}
		public static void RenderArrow(ref ImDrawList drawList, Vector2 pos, uint col, ImGuiDir dir, float scale)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderArrow((ImDrawList*)pdrawList, pos, col, dir, scale);
			}
		}
		public static void RenderArrow(ref ImDrawList drawList, Vector2 pos, uint col, ImGuiDir dir)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderArrow((ImDrawList*)pdrawList, pos, col, dir, (float)(1.0f));
			}
		}
		public static void RenderBullet(ImDrawListPtr drawList, Vector2 pos, uint col)
		{
			ImGuiPNative.RenderBullet(drawList, pos, col);
		}
		public static void RenderBullet(ref ImDrawList drawList, Vector2 pos, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderBullet((ImDrawList*)pdrawList, pos, col);
			}
		}
		public static void RenderCheckMark(ImDrawListPtr drawList, Vector2 pos, uint col, float sz)
		{
			ImGuiPNative.RenderCheckMark(drawList, pos, col, sz);
		}
		public static void RenderCheckMark(ref ImDrawList drawList, Vector2 pos, uint col, float sz)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderCheckMark((ImDrawList*)pdrawList, pos, col, sz);
			}
		}
		public static void RenderArrowPointingAt(ImDrawListPtr drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col)
		{
			ImGuiPNative.RenderArrowPointingAt(drawList, pos, halfSz, direction, col);
		}
		public static void RenderArrowPointingAt(ref ImDrawList drawList, Vector2 pos, Vector2 halfSz, ImGuiDir direction, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderArrowPointingAt((ImDrawList*)pdrawList, pos, halfSz, direction, col);
			}
		}
		public static void RenderArrowDockMenu(ImDrawListPtr drawList, Vector2 pMin, float sz, uint col)
		{
			ImGuiPNative.RenderArrowDockMenu(drawList, pMin, sz, col);
		}
		public static void RenderArrowDockMenu(ref ImDrawList drawList, Vector2 pMin, float sz, uint col)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderArrowDockMenu((ImDrawList*)pdrawList, pMin, sz, col);
			}
		}
		public static void RenderRectFilledRangeH(ImDrawListPtr drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding)
		{
			ImGuiPNative.RenderRectFilledRangeH(drawList, rect, col, xStartNorm, xEndNorm, rounding);
		}
		public static void RenderRectFilledRangeH(ref ImDrawList drawList, ImRect rect, uint col, float xStartNorm, float xEndNorm, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderRectFilledRangeH((ImDrawList*)pdrawList, rect, col, xStartNorm, xEndNorm, rounding);
			}
		}
		public static void RenderRectFilledWithHole(ImDrawListPtr drawList, ImRect outer, ImRect inner, uint col, float rounding)
		{
			ImGuiPNative.RenderRectFilledWithHole(drawList, outer, inner, col, rounding);
		}
		public static void RenderRectFilledWithHole(ref ImDrawList drawList, ImRect outer, ImRect inner, uint col, float rounding)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.RenderRectFilledWithHole((ImDrawList*)pdrawList, outer, inner, col, rounding);
			}
		}
		public static ImDrawFlags CalcRoundingFlagsForRectInRect(ImRect rIn, ImRect rOuter, float threshold)
		{
			ImDrawFlags ret = ImGuiPNative.CalcRoundingFlagsForRectInRect(rIn, rOuter, threshold);
			return ret;
		}
		public static bool ButtonEx(byte* label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte ret = ImGuiPNative.ButtonEx(label, sizeArg, flags);
			return ret != 0;
		}
		public static bool ButtonEx(byte* label, Vector2 sizeArg)
		{
			byte ret = ImGuiPNative.ButtonEx(label, sizeArg, (ImGuiButtonFlags)(0));
			return ret != 0;
		}
		public static bool ButtonEx(byte* label)
		{
			byte ret = ImGuiPNative.ButtonEx(label, (Vector2)(new Vector2(0,0)), (ImGuiButtonFlags)(0));
			return ret != 0;
		}
		public static bool ButtonEx(byte* label, ImGuiButtonFlags flags)
		{
			byte ret = ImGuiPNative.ButtonEx(label, (Vector2)(new Vector2(0,0)), flags);
			return ret != 0;
		}
		public static bool ButtonEx(ref byte label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, sizeArg, flags);
				return ret != 0;
			}
		}
		public static bool ButtonEx(ref byte label, Vector2 sizeArg)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, sizeArg, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ButtonEx(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, (Vector2)(new Vector2(0,0)), (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ButtonEx(ref byte label, ImGuiButtonFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, (Vector2)(new Vector2(0,0)), flags);
				return ret != 0;
			}
		}
		public static bool ButtonEx(ReadOnlySpan<byte> label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, sizeArg, flags);
				return ret != 0;
			}
		}
		public static bool ButtonEx(ReadOnlySpan<byte> label, Vector2 sizeArg)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, sizeArg, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ButtonEx(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, (Vector2)(new Vector2(0,0)), (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ButtonEx(ReadOnlySpan<byte> label, ImGuiButtonFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.ButtonEx((byte*)plabel, (Vector2)(new Vector2(0,0)), flags);
				return ret != 0;
			}
		}
		public static bool ButtonEx(string label, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.ButtonEx(pStr0, sizeArg, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ButtonEx(string label, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.ButtonEx(pStr0, sizeArg, (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ButtonEx(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.ButtonEx(pStr0, (Vector2)(new Vector2(0,0)), (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ButtonEx(string label, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.ButtonEx(pStr0, (Vector2)(new Vector2(0,0)), flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CloseButton(uint id, Vector2 pos)
		{
			byte ret = ImGuiPNative.CloseButton(id, pos);
			return ret != 0;
		}
		public static bool CollapseButton(uint id, Vector2 pos, ImGuiDockNodePtr dockNode)
		{
			byte ret = ImGuiPNative.CollapseButton(id, pos, dockNode);
			return ret != 0;
		}
		public static bool CollapseButton(uint id, Vector2 pos, ref ImGuiDockNode dockNode)
		{
			fixed (ImGuiDockNode* pdockNode = &dockNode)
			{
				byte ret = ImGuiPNative.CollapseButton(id, pos, (ImGuiDockNode*)pdockNode);
				return ret != 0;
			}
		}
		public static bool ArrowButtonEx(byte* strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte ret = ImGuiPNative.ArrowButtonEx(strId, dir, sizeArg, flags);
			return ret != 0;
		}
		public static bool ArrowButtonEx(byte* strId, ImGuiDir dir, Vector2 sizeArg)
		{
			byte ret = ImGuiPNative.ArrowButtonEx(strId, dir, sizeArg, (ImGuiButtonFlags)(0));
			return ret != 0;
		}
		public static bool ArrowButtonEx(ref byte strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiPNative.ArrowButtonEx((byte*)pstrId, dir, sizeArg, flags);
				return ret != 0;
			}
		}
		public static bool ArrowButtonEx(ref byte strId, ImGuiDir dir, Vector2 sizeArg)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = ImGuiPNative.ArrowButtonEx((byte*)pstrId, dir, sizeArg, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ArrowButtonEx(ReadOnlySpan<byte> strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiPNative.ArrowButtonEx((byte*)pstrId, dir, sizeArg, flags);
				return ret != 0;
			}
		}
		public static bool ArrowButtonEx(ReadOnlySpan<byte> strId, ImGuiDir dir, Vector2 sizeArg)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = ImGuiPNative.ArrowButtonEx((byte*)pstrId, dir, sizeArg, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ArrowButtonEx(string strId, ImGuiDir dir, Vector2 sizeArg, ImGuiButtonFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.ArrowButtonEx(pStr0, dir, sizeArg, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ArrowButtonEx(string strId, ImGuiDir dir, Vector2 sizeArg)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.ArrowButtonEx(pStr0, dir, sizeArg, (ImGuiButtonFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static void Scrollbar(ImGuiAxis axis)
		{
			ImGuiPNative.Scrollbar(axis);
		}
		public static bool ScrollbarEx(ImRect bb, uint id, ImGuiAxis axis, long* pScrollV, long availV, long contentsV, ImDrawFlags flags)
		{
			byte ret = ImGuiPNative.ScrollbarEx(bb, id, axis, pScrollV, availV, contentsV, flags);
			return ret != 0;
		}
		public static bool ImageButtonEx(uint id, ImTextureID textureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector2 padding, Vector4 bgCol, Vector4 tintCol)
		{
			byte ret = ImGuiPNative.ImageButtonEx(id, textureId, size, uv0, uv1, padding, bgCol, tintCol);
			return ret != 0;
		}
		public static ImRect GetWindowScrollbarRect(ImGuiWindowPtr window, ImGuiAxis axis)
		{
			ImRect ret;
			ImGuiPNative.GetWindowScrollbarRect(&ret, window, axis);
			return ret;
		}
		public static void GetWindowScrollbarRect(ImRectPtr pOut, ImGuiWindowPtr window, ImGuiAxis axis)
		{
			ImGuiPNative.GetWindowScrollbarRect(pOut, window, axis);
		}
		public static void GetWindowScrollbarRect(ref ImRect pOut, ImGuiWindowPtr window, ImGuiAxis axis)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				ImGuiPNative.GetWindowScrollbarRect((ImRect*)ppOut, window, axis);
			}
		}
		public static ImRect GetWindowScrollbarRect(ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImRect ret;
				ImGuiPNative.GetWindowScrollbarRect(&ret, (ImGuiWindow*)pwindow, axis);
				return ret;
			}
		}
		public static void GetWindowScrollbarRect(ImRectPtr pOut, ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.GetWindowScrollbarRect(pOut, (ImGuiWindow*)pwindow, axis);
			}
		}
		public static void GetWindowScrollbarRect(ref ImRect pOut, ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pwindow = &window)
				{
					ImGuiPNative.GetWindowScrollbarRect((ImRect*)ppOut, (ImGuiWindow*)pwindow, axis);
				}
			}
		}
		public static uint GetWindowScrollbarID(ImGuiWindowPtr window, ImGuiAxis axis)
		{
			uint ret = ImGuiPNative.GetWindowScrollbarID(window, axis);
			return ret;
		}
		public static uint GetWindowScrollbarID(ref ImGuiWindow window, ImGuiAxis axis)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				uint ret = ImGuiPNative.GetWindowScrollbarID((ImGuiWindow*)pwindow, axis);
				return ret;
			}
		}
		public static uint GetWindowResizeCornerID(ImGuiWindowPtr window, int n)
		{
			uint ret = ImGuiPNative.GetWindowResizeCornerID(window, n);
			return ret;
		}
		public static uint GetWindowResizeCornerID(ref ImGuiWindow window, int n)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				uint ret = ImGuiPNative.GetWindowResizeCornerID((ImGuiWindow*)pwindow, n);
				return ret;
			}
		}
		public static uint GetWindowResizeBorderID(ImGuiWindowPtr window, ImGuiDir dir)
		{
			uint ret = ImGuiPNative.GetWindowResizeBorderID(window, dir);
			return ret;
		}
		public static uint GetWindowResizeBorderID(ref ImGuiWindow window, ImGuiDir dir)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				uint ret = ImGuiPNative.GetWindowResizeBorderID((ImGuiWindow*)pwindow, dir);
				return ret;
			}
		}
		public static void SeparatorEx(ImGuiSeparatorFlags flags)
		{
			ImGuiPNative.SeparatorEx(flags);
		}
		public static bool CheckboxFlags(byte* label, long* flags, long flagsValue)
		{
			byte ret = ImGuiPNative.CheckboxFlags(label, flags, flagsValue);
			return ret != 0;
		}
		public static bool CheckboxFlags(ref byte label, long* flags, long flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(ReadOnlySpan<byte> label, long* flags, long flagsValue)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(string label, long* flags, long flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.CheckboxFlags(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool CheckboxFlags(byte* label, ulong* flags, ulong flagsValue)
		{
			byte ret = ImGuiPNative.CheckboxFlags(label, flags, flagsValue);
			return ret != 0;
		}
		public static bool CheckboxFlags(ref byte label, ulong* flags, ulong flagsValue)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(ReadOnlySpan<byte> label, ulong* flags, ulong flagsValue)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.CheckboxFlags((byte*)plabel, flags, flagsValue);
				return ret != 0;
			}
		}
		public static bool CheckboxFlags(string label, ulong* flags, ulong flagsValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.CheckboxFlags(pStr0, flags, flagsValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool ButtonBehavior(ImRect bb, uint id, bool* outHovered, bool* outHeld, ImGuiButtonFlags flags)
		{
			byte ret = ImGuiPNative.ButtonBehavior(bb, id, outHovered, outHeld, flags);
			return ret != 0;
		}
		public static bool ButtonBehavior(ImRect bb, uint id, bool* outHovered, bool* outHeld)
		{
			byte ret = ImGuiPNative.ButtonBehavior(bb, id, outHovered, outHeld, (ImGuiButtonFlags)(0));
			return ret != 0;
		}
		public static bool ButtonBehavior(ImRect bb, uint id, ref bool outHovered, bool* outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				byte ret = ImGuiPNative.ButtonBehavior(bb, id, (bool*)poutHovered, outHeld, flags);
				return ret != 0;
			}
		}
		public static bool ButtonBehavior(ImRect bb, uint id, ref bool outHovered, bool* outHeld)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				byte ret = ImGuiPNative.ButtonBehavior(bb, id, (bool*)poutHovered, outHeld, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ButtonBehavior(ImRect bb, uint id, bool* outHovered, ref bool outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHeld = &outHeld)
			{
				byte ret = ImGuiPNative.ButtonBehavior(bb, id, outHovered, (bool*)poutHeld, flags);
				return ret != 0;
			}
		}
		public static bool ButtonBehavior(ImRect bb, uint id, bool* outHovered, ref bool outHeld)
		{
			fixed (bool* poutHeld = &outHeld)
			{
				byte ret = ImGuiPNative.ButtonBehavior(bb, id, outHovered, (bool*)poutHeld, (ImGuiButtonFlags)(0));
				return ret != 0;
			}
		}
		public static bool ButtonBehavior(ImRect bb, uint id, ref bool outHovered, ref bool outHeld, ImGuiButtonFlags flags)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				fixed (bool* poutHeld = &outHeld)
				{
					byte ret = ImGuiPNative.ButtonBehavior(bb, id, (bool*)poutHovered, (bool*)poutHeld, flags);
					return ret != 0;
				}
			}
		}
		public static bool ButtonBehavior(ImRect bb, uint id, ref bool outHovered, ref bool outHeld)
		{
			fixed (bool* poutHovered = &outHovered)
			{
				fixed (bool* poutHeld = &outHeld)
				{
					byte ret = ImGuiPNative.ButtonBehavior(bb, id, (bool*)poutHovered, (bool*)poutHeld, (ImGuiButtonFlags)(0));
					return ret != 0;
				}
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, size2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, bgCol);
			return ret != 0;
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay)
		{
			byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, size2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, (uint)(0));
			return ret != 0;
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float minsize1, float minsize2, float hoverExtend)
		{
			byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, size2, minsize1, minsize2, hoverExtend, (float)(0.0f), (uint)(0));
			return ret != 0;
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float minsize1, float minsize2)
		{
			byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, size2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), (uint)(0));
			return ret != 0;
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float minsize1, float minsize2, float hoverExtend, uint bgCol)
		{
			byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, size2, minsize1, minsize2, hoverExtend, (float)(0.0f), bgCol);
			return ret != 0;
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float minsize1, float minsize2, uint bgCol)
		{
			byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, size2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), bgCol);
			return ret != 0;
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, float* size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, size2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, bgCol);
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, float* size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, size2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, (uint)(0));
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, float* size2, float minsize1, float minsize2, float hoverExtend)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, size2, minsize1, minsize2, hoverExtend, (float)(0.0f), (uint)(0));
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, float* size2, float minsize1, float minsize2)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, size2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), (uint)(0));
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, float* size2, float minsize1, float minsize2, float hoverExtend, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, size2, minsize1, minsize2, hoverExtend, (float)(0.0f), bgCol);
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, float* size2, float minsize1, float minsize2, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, size2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), bgCol);
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, ref float size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, (float*)psize2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, bgCol);
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, ref float size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, (float*)psize2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, (uint)(0));
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, ref float size2, float minsize1, float minsize2, float hoverExtend)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, (float*)psize2, minsize1, minsize2, hoverExtend, (float)(0.0f), (uint)(0));
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, ref float size2, float minsize1, float minsize2)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, (float*)psize2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), (uint)(0));
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, ref float size2, float minsize1, float minsize2, float hoverExtend, uint bgCol)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, (float*)psize2, minsize1, minsize2, hoverExtend, (float)(0.0f), bgCol);
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, float* size1, ref float size2, float minsize1, float minsize2, uint bgCol)
		{
			fixed (float* psize2 = &size2)
			{
				byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, size1, (float*)psize2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), bgCol);
				return ret != 0;
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, ref float size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, bgCol);
					return ret != 0;
				}
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, ref float size2, float minsize1, float minsize2, float hoverExtend, float hoverVisibilityDelay)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minsize1, minsize2, hoverExtend, hoverVisibilityDelay, (uint)(0));
					return ret != 0;
				}
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, ref float size2, float minsize1, float minsize2, float hoverExtend)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minsize1, minsize2, hoverExtend, (float)(0.0f), (uint)(0));
					return ret != 0;
				}
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, ref float size2, float minsize1, float minsize2)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), (uint)(0));
					return ret != 0;
				}
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, ref float size2, float minsize1, float minsize2, float hoverExtend, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minsize1, minsize2, hoverExtend, (float)(0.0f), bgCol);
					return ret != 0;
				}
			}
		}
		public static bool SplitterBehavior(ImRect bb, uint id, ImGuiAxis axis, ref float size1, ref float size2, float minsize1, float minsize2, uint bgCol)
		{
			fixed (float* psize1 = &size1)
			{
				fixed (float* psize2 = &size2)
				{
					byte ret = ImGuiPNative.SplitterBehavior(bb, id, axis, (float*)psize1, (float*)psize2, minsize1, minsize2, (float)(0.0f), (float)(0.0f), bgCol);
					return ret != 0;
				}
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, byte* label, byte* labelEnd)
		{
			byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, label, labelEnd);
			return ret != 0;
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, byte* label)
		{
			byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, label, (byte*)(default));
			return ret != 0;
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ref byte label, byte* labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, labelEnd);
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)(default));
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ReadOnlySpan<byte> label, byte* labelEnd)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, labelEnd);
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)(default));
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, string label, byte* labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, pStr0, labelEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, byte* label, ref byte labelEnd)
		{
			fixed (byte* plabelEnd = &labelEnd)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, label, (byte*)plabelEnd);
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, byte* label, ReadOnlySpan<byte> labelEnd)
		{
			fixed (byte* plabelEnd = labelEnd)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, label, (byte*)plabelEnd);
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, byte* label, string labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ref byte label, ref byte labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* plabelEnd = &labelEnd)
				{
					byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)plabelEnd);
					return ret != 0;
				}
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ReadOnlySpan<byte> label, ReadOnlySpan<byte> labelEnd)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* plabelEnd = labelEnd)
				{
					byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)plabelEnd);
					return ret != 0;
				}
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, string label, string labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (labelEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(labelEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(labelEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ref byte label, ReadOnlySpan<byte> labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* plabelEnd = labelEnd)
				{
					byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)plabelEnd);
					return ret != 0;
				}
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ref byte label, string labelEnd)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (labelEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ReadOnlySpan<byte> label, ref byte labelEnd)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* plabelEnd = &labelEnd)
				{
					byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, (byte*)plabelEnd);
					return ret != 0;
				}
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, ReadOnlySpan<byte> label, string labelEnd)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (labelEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(labelEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(labelEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, (byte*)plabel, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, string label, ref byte labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* plabelEnd = &labelEnd)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, pStr0, (byte*)plabelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, string label, ReadOnlySpan<byte> labelEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* plabelEnd = labelEnd)
			{
				byte ret = ImGuiPNative.TreeNodeBehavior(id, flags, pStr0, (byte*)plabelEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TreeNodeBehaviorIsOpen(uint id, ImGuiTreeNodeFlags flags)
		{
			byte ret = ImGuiPNative.TreeNodeBehaviorIsOpen(id, flags);
			return ret != 0;
		}
		public static bool TreeNodeBehaviorIsOpen(uint id)
		{
			byte ret = ImGuiPNative.TreeNodeBehaviorIsOpen(id, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}
		public static void TreePushOverrideID(uint id)
		{
			ImGuiPNative.TreePushOverrideID(id);
		}
		public static ImGuiDataTypeInfoPtr DataTypeGetInfo(ImGuiDataType dataType)
		{
			ImGuiDataTypeInfoPtr ret = ImGuiPNative.DataTypeGetInfo(dataType);
			return ret;
		}
		public static void DataTypeApplyOp(ImGuiDataType dataType, int op, void* output, void* arg1, void* arg2)
		{
			ImGuiPNative.DataTypeApplyOp(dataType, op, output, arg1, arg2);
		}
		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte ret = ImGuiPNative.DataTypeApplyFromText(buf, dataType, pData, format);
			return ret != 0;
		}
		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* pbuf = &buf)
			{
				byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, format);
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(ReadOnlySpan<byte> buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* pbuf = buf)
			{
				byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, format);
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.DataTypeApplyFromText(pStr0, dataType, pData, format);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.DataTypeApplyFromText(buf, dataType, pData, (byte*)pformat);
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.DataTypeApplyFromText(buf, dataType, pData, (byte*)pformat);
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.DataTypeApplyFromText(buf, dataType, pData, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, (byte*)pformat);
					return ret != 0;
				}
			}
		}
		public static bool DataTypeApplyFromText(ReadOnlySpan<byte> buf, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			fixed (byte* pbuf = buf)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, (byte*)pformat);
					return ret != 0;
				}
			}
		}
		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.DataTypeApplyFromText(pStr0, dataType, pData, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			fixed (byte* pbuf = &buf)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, (byte*)pformat);
					return ret != 0;
				}
			}
		}
		public static bool DataTypeApplyFromText(ref byte buf, ImGuiDataType dataType, void* pData, string format)
		{
			fixed (byte* pbuf = &buf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(ReadOnlySpan<byte> buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pbuf = buf)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, (byte*)pformat);
					return ret != 0;
				}
			}
		}
		public static bool DataTypeApplyFromText(ReadOnlySpan<byte> buf, ImGuiDataType dataType, void* pData, string format)
		{
			fixed (byte* pbuf = buf)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.DataTypeApplyFromText((byte*)pbuf, dataType, pData, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, ref byte format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.DataTypeApplyFromText(pStr0, dataType, pData, (byte*)pformat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool DataTypeApplyFromText(string buf, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.DataTypeApplyFromText(pStr0, dataType, pData, (byte*)pformat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static int DataTypeCompare(ImGuiDataType dataType, void* arg1, void* arg2)
		{
			int ret = ImGuiPNative.DataTypeCompare(dataType, arg1, arg2);
			return ret;
		}
		public static bool DataTypeClamp(ImGuiDataType dataType, void* pData, void* pMin, void* pMax)
		{
			byte ret = ImGuiPNative.DataTypeClamp(dataType, pData, pMin, pMax);
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, format, pClampMin, pClampMax);
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin)
		{
			byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, format, pClampMin, (void*)(default));
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, format, (void*)(default), (void*)(default));
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, pClampMin, pClampMax);
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, pClampMin, (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, (void*)(default), (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, pClampMin, pClampMax);
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, pClampMin, (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, byte* format)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, format, (void*)(default), (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, format, pClampMin, pClampMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, byte* format, void* pClampMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, format, pClampMin, (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, byte* format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, format, (void*)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin)
		{
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, pStr0, pClampMin, pClampMax);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, string format, void* pClampMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, pStr0, pClampMin, (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, byte* label, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, label, dataType, pData, pStr0, (void*)(default), (void*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, pStr1, pClampMin, pClampMax);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, string format, void* pClampMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, pStr1, pClampMin, (void*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (format != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(format);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(format, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, pStr1, (void*)(default), (void*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* pformat = format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, pStr0, pClampMin, pClampMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, string format, void* pClampMin)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, pStr0, pClampMin, (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ref byte label, ImGuiDataType dataType, void* pData, string format)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, pStr0, (void*)(default), (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, ref byte format)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
					return ret != 0;
				}
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, string format, void* pClampMin, void* pClampMax)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, pStr0, pClampMin, pClampMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, string format, void* pClampMin)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, pStr0, pClampMin, (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, ReadOnlySpan<byte> label, ImGuiDataType dataType, void* pData, string format)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGuiPNative.TempInputScalar(bb, id, (byte*)plabel, dataType, pData, pStr0, (void*)(default), (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, ref byte format, void* pClampMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, ref byte format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = &format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin, void* pClampMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, (byte*)pformat, pClampMin, pClampMax);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format, void* pClampMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, (byte*)pformat, pClampMin, (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputScalar(ImRect bb, uint id, string label, ImGuiDataType dataType, void* pData, ReadOnlySpan<byte> format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pformat = format)
			{
				byte ret = ImGuiPNative.TempInputScalar(bb, id, pStr0, dataType, pData, (byte*)pformat, (void*)(default), (void*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}
		public static bool TempInputIsActive(uint id)
		{
			byte ret = ImGuiPNative.TempInputIsActive(id);
			return ret != 0;
		}
		public static ImGuiInputTextStatePtr GetInputTextState(uint id)
		{
			ImGuiInputTextStatePtr ret = ImGuiPNative.GetInputTextState(id);
			return ret;
		}
		public static void Custom_StbTextMakeUndoReplace(ImGuiInputTextStatePtr str, int where, int oldLength, int newLength)
		{
			ImGuiPNative.Custom_StbTextMakeUndoReplace(str, where, oldLength, newLength);
		}
		public static void Custom_StbTextMakeUndoReplace(ref ImGuiInputTextState str, int where, int oldLength, int newLength)
		{
			fixed (ImGuiInputTextState* pstr = &str)
			{
				ImGuiPNative.Custom_StbTextMakeUndoReplace((ImGuiInputTextState*)pstr, where, oldLength, newLength);
			}
		}
		public static void Custom_StbTextUndo(ImGuiInputTextStatePtr str)
		{
			ImGuiPNative.Custom_StbTextUndo(str);
		}
		public static void Custom_StbTextUndo(ref ImGuiInputTextState str)
		{
			fixed (ImGuiInputTextState* pstr = &str)
			{
				ImGuiPNative.Custom_StbTextUndo((ImGuiInputTextState*)pstr);
			}
		}
		public static void ColorTooltip(byte* text, float* col, ImGuiColorEditFlags flags)
		{
			ImGuiPNative.ColorTooltip(text, col, flags);
		}
		public static void ColorTooltip(ref byte text, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				ImGuiPNative.ColorTooltip((byte*)ptext, col, flags);
			}
		}
		public static void ColorTooltip(ReadOnlySpan<byte> text, float* col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = text)
			{
				ImGuiPNative.ColorTooltip((byte*)ptext, col, flags);
			}
		}
		public static void ColorTooltip(string text, float* col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.ColorTooltip(pStr0, col, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ColorTooltip(byte* text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				ImGuiPNative.ColorTooltip(text, (float*)pcol, flags);
			}
		}
		public static void ColorTooltip(ref byte text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = &text)
			{
				fixed (float* pcol = &col)
				{
					ImGuiPNative.ColorTooltip((byte*)ptext, (float*)pcol, flags);
				}
			}
		}
		public static void ColorTooltip(ReadOnlySpan<byte> text, ref float col, ImGuiColorEditFlags flags)
		{
			fixed (byte* ptext = text)
			{
				fixed (float* pcol = &col)
				{
					ImGuiPNative.ColorTooltip((byte*)ptext, (float*)pcol, flags);
				}
			}
		}
		public static void ColorTooltip(string text, ref float col, ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* pcol = &col)
			{
				ImGuiPNative.ColorTooltip(pStr0, (float*)pcol, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			int ret = ImGuiPNative.PlotEx(plotType, label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, frameSize);
			return ret;
		}
		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = &label)
			{
				int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, frameSize);
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, ReadOnlySpan<byte> label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = label)
			{
				int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, frameSize);
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.PlotEx(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, frameSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				int ret = ImGuiPNative.PlotEx(plotType, label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ReadOnlySpan<byte> overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* poverlayText = overlayText)
			{
				int ret = ImGuiPNative.PlotEx(plotType, label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, byte* label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImGuiPNative.PlotEx(plotType, label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, frameSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
					return ret;
				}
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, ReadOnlySpan<byte> label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ReadOnlySpan<byte> overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* poverlayText = overlayText)
				{
					int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
					return ret;
				}
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (overlayText != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(overlayText, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImGuiPNative.PlotEx(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, pStr1, scaleMin, scaleMax, frameSize);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ReadOnlySpan<byte> overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = &label)
			{
				fixed (byte* poverlayText = overlayText)
				{
					int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
					return ret;
				}
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, ref byte label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = &label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, frameSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, ReadOnlySpan<byte> label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = label)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
					return ret;
				}
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, ReadOnlySpan<byte> label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, string overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			fixed (byte* plabel = label)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImGuiPNative.PlotEx(plotType, (byte*)plabel, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, frameSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ref byte overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* poverlayText = &overlayText)
			{
				int ret = ImGuiPNative.PlotEx(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static int PlotEx(ImGuiPlotType plotType, string label, delegate*<ImGuiPlotType, byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, ReadOnlySpan<byte> overlayText, float scaleMin, float scaleMax, Vector2 frameSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* poverlayText = overlayText)
			{
				int ret = ImGuiPNative.PlotEx(plotType, pStr0, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, frameSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
		public static void ShadeVertsLinearColorGradientKeepAlpha(ImDrawListPtr drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientp0, Vector2 gradientp1, uint col0, uint col1)
		{
			ImGuiPNative.ShadeVertsLinearColorGradientKeepAlpha(drawList, vertStartIdx, vertEndIdx, gradientp0, gradientp1, col0, col1);
		}
		public static void ShadeVertsLinearColorGradientKeepAlpha(ref ImDrawList drawList, int vertStartIdx, int vertEndIdx, Vector2 gradientp0, Vector2 gradientp1, uint col0, uint col1)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.ShadeVertsLinearColorGradientKeepAlpha((ImDrawList*)pdrawList, vertStartIdx, vertEndIdx, gradientp0, gradientp1, col0, col1);
			}
		}
		public static void ShadeVertsLinearUV(ImDrawListPtr drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, bool clamp)
		{
			ImGuiPNative.ShadeVertsLinearUV(drawList, vertStartIdx, vertEndIdx, a, b, uvA, uvB, clamp ? (byte)1 : (byte)0);
		}
		public static void ShadeVertsLinearUV(ref ImDrawList drawList, int vertStartIdx, int vertEndIdx, Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, bool clamp)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.ShadeVertsLinearUV((ImDrawList*)pdrawList, vertStartIdx, vertEndIdx, a, b, uvA, uvB, clamp ? (byte)1 : (byte)0);
			}
		}
		public static void GcCompactTransientMiscBuffers()
		{
			ImGuiPNative.GcCompactTransientMiscBuffers();
		}
		public static void GcCompactTransientWindowBuffers(ImGuiWindowPtr window)
		{
			ImGuiPNative.GcCompactTransientWindowBuffers(window);
		}
		public static void GcCompactTransientWindowBuffers(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.GcCompactTransientWindowBuffers((ImGuiWindow*)pwindow);
			}
		}
		public static void GcAwakeTransientWindowBuffers(ImGuiWindowPtr window)
		{
			ImGuiPNative.GcAwakeTransientWindowBuffers(window);
		}
		public static void GcAwakeTransientWindowBuffers(ref ImGuiWindow window)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.GcAwakeTransientWindowBuffers((ImGuiWindow*)pwindow);
			}
		}
		public static void ErrorCheckEndFrameRecover(ImGuiErrorLogCallback logCallback, void* userData)
		{
			ImGuiPNative.ErrorCheckEndFrameRecover(logCallback, userData);
		}
		public static void ErrorCheckEndFrameRecover(ImGuiErrorLogCallback logCallback)
		{
			ImGuiPNative.ErrorCheckEndFrameRecover(logCallback, (void*)(default));
		}
		public static void ErrorCheckEndWindowRecover(ImGuiErrorLogCallback logCallback, void* userData)
		{
			ImGuiPNative.ErrorCheckEndWindowRecover(logCallback, userData);
		}
		public static void ErrorCheckEndWindowRecover(ImGuiErrorLogCallback logCallback)
		{
			ImGuiPNative.ErrorCheckEndWindowRecover(logCallback, (void*)(default));
		}
		public static void DebugDrawItemRect(uint col)
		{
			ImGuiPNative.DebugDrawItemRect(col);
		}
		public static void DebugDrawItemRect()
		{
			ImGuiPNative.DebugDrawItemRect((uint)(4278190335));
		}
		public static void DebugStartItemPicker()
		{
			ImGuiPNative.DebugStartItemPicker();
		}
		public static void ShowFontAtlas(ImFontAtlasPtr atlas)
		{
			ImGuiPNative.ShowFontAtlas(atlas);
		}
		public static void ShowFontAtlas(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImGuiPNative.ShowFontAtlas((ImFontAtlas*)patlas);
			}
		}
		public static void DebugHookIdInfo(uint id, ImGuiDataType dataType, void* dataId, void* dataIdEnd)
		{
			ImGuiPNative.DebugHookIdInfo(id, dataType, dataId, dataIdEnd);
		}
		public static void DebugNodeColumns(ImGuiOldColumnsPtr columns)
		{
			ImGuiPNative.DebugNodeColumns(columns);
		}
		public static void DebugNodeColumns(ref ImGuiOldColumns columns)
		{
			fixed (ImGuiOldColumns* pcolumns = &columns)
			{
				ImGuiPNative.DebugNodeColumns((ImGuiOldColumns*)pcolumns);
			}
		}
		public static void DebugNodeDockNode(ImGuiDockNodePtr node, byte* label)
		{
			ImGuiPNative.DebugNodeDockNode(node, label);
		}
		public static void DebugNodeDockNode(ref ImGuiDockNode node, byte* label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				ImGuiPNative.DebugNodeDockNode((ImGuiDockNode*)pnode, label);
			}
		}
		public static void DebugNodeDockNode(ImGuiDockNodePtr node, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.DebugNodeDockNode(node, (byte*)plabel);
			}
		}
		public static void DebugNodeDockNode(ImGuiDockNodePtr node, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.DebugNodeDockNode(node, (byte*)plabel);
			}
		}
		public static void DebugNodeDockNode(ImGuiDockNodePtr node, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DebugNodeDockNode(node, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DebugNodeDockNode(ref ImGuiDockNode node, ref byte label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeDockNode((ImGuiDockNode*)pnode, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDockNode(ref ImGuiDockNode node, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeDockNode((ImGuiDockNode*)pnode, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDockNode(ref ImGuiDockNode node, string label)
		{
			fixed (ImGuiDockNode* pnode = &node)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeDockNode((ImGuiDockNode*)pnode, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, byte* label)
		{
			ImGuiPNative.DebugNodeDrawList(window, viewport, drawList, label);
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, label);
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, byte* label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, label);
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, label);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, label);
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, label);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, label);
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, label);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.DebugNodeDrawList(window, viewport, drawList, (byte*)plabel);
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.DebugNodeDrawList(window, viewport, drawList, (byte*)plabel);
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DebugNodeDrawList(window, viewport, drawList, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ImDrawListPtr drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, drawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, ref byte label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, string label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, drawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (byte* plabel = &label)
					{
						ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (byte* plabel = label)
					{
						ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, (byte*)plabel);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ImDrawListPtr drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, drawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeDrawList(window, viewport, (ImDrawList*)pdrawList, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = &label)
					{
						ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = label)
					{
						ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ImGuiViewportPPtr viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, viewport, (ImDrawList*)pdrawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = &label)
					{
						ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* plabel = label)
					{
						ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ImGuiWindowPtr window, ref ImGuiViewportP viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (label != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(label);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGuiPNative.DebugNodeDrawList(window, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						fixed (byte* plabel = &label)
						{
							ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
						}
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						fixed (byte* plabel = label)
						{
							ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, (byte*)plabel);
						}
					}
				}
			}
		}
		public static void DebugNodeDrawList(ref ImGuiWindow window, ref ImGuiViewportP viewport, ref ImDrawList drawList, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					fixed (ImDrawList* pdrawList = &drawList)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (label != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(label);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGuiPNative.DebugNodeDrawList((ImGuiWindow*)pwindow, (ImGuiViewportP*)pviewport, (ImDrawList*)pdrawList, pStr0);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawListPtr outDrawList, ImDrawListPtr drawList, ImDrawCmdPtr drawCmd, bool showMesh, bool showAabb)
		{
			ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, drawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ImDrawListPtr drawList, ImDrawCmdPtr drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, drawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawListPtr outDrawList, ref ImDrawList drawList, ImDrawCmdPtr drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, (ImDrawList*)pdrawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ref ImDrawList drawList, ImDrawCmdPtr drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, (ImDrawList*)pdrawList, drawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawListPtr outDrawList, ImDrawListPtr drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawCmd* pdrawCmd = &drawCmd)
			{
				ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, drawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ImDrawListPtr drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawCmd* pdrawCmd = &drawCmd)
				{
					ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, drawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawListPtr outDrawList, ref ImDrawList drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImDrawCmd* pdrawCmd = &drawCmd)
				{
					ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox(outDrawList, (ImDrawList*)pdrawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
				}
			}
		}
		public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ref ImDrawList outDrawList, ref ImDrawList drawList, ref ImDrawCmd drawCmd, bool showMesh, bool showAabb)
		{
			fixed (ImDrawList* poutDrawList = &outDrawList)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (ImDrawCmd* pdrawCmd = &drawCmd)
					{
						ImGuiPNative.DebugNodeDrawCmdShowMeshAndBoundingBox((ImDrawList*)poutDrawList, (ImDrawList*)pdrawList, (ImDrawCmd*)pdrawCmd, showMesh ? (byte)1 : (byte)0, showAabb ? (byte)1 : (byte)0);
					}
				}
			}
		}
		public static void DebugNodeFont(ImFontPtr font)
		{
			ImGuiPNative.DebugNodeFont(font);
		}
		public static void DebugNodeFont(ref ImFont font)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGuiPNative.DebugNodeFont((ImFont*)pfont);
			}
		}
		public static void DebugNodeFontGlyph(ImFontPtr font, ImFontGlyphPtr glyph)
		{
			ImGuiPNative.DebugNodeFontGlyph(font, glyph);
		}
		public static void DebugNodeFontGlyph(ref ImFont font, ImFontGlyphPtr glyph)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGuiPNative.DebugNodeFontGlyph((ImFont*)pfont, glyph);
			}
		}
		public static void DebugNodeFontGlyph(ImFontPtr font, ref ImFontGlyph glyph)
		{
			fixed (ImFontGlyph* pglyph = &glyph)
			{
				ImGuiPNative.DebugNodeFontGlyph(font, (ImFontGlyph*)pglyph);
			}
		}
		public static void DebugNodeFontGlyph(ref ImFont font, ref ImFontGlyph glyph)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (ImFontGlyph* pglyph = &glyph)
				{
					ImGuiPNative.DebugNodeFontGlyph((ImFont*)pfont, (ImFontGlyph*)pglyph);
				}
			}
		}
		public static void DebugNodeStorage(ImGuiStoragePtr storage, byte* label)
		{
			ImGuiPNative.DebugNodeStorage(storage, label);
		}
		public static void DebugNodeStorage(ref ImGuiStorage storage, byte* label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				ImGuiPNative.DebugNodeStorage((ImGuiStorage*)pstorage, label);
			}
		}
		public static void DebugNodeStorage(ImGuiStoragePtr storage, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.DebugNodeStorage(storage, (byte*)plabel);
			}
		}
		public static void DebugNodeStorage(ImGuiStoragePtr storage, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.DebugNodeStorage(storage, (byte*)plabel);
			}
		}
		public static void DebugNodeStorage(ImGuiStoragePtr storage, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DebugNodeStorage(storage, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DebugNodeStorage(ref ImGuiStorage storage, ref byte label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeStorage((ImGuiStorage*)pstorage, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeStorage(ref ImGuiStorage storage, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeStorage((ImGuiStorage*)pstorage, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeStorage(ref ImGuiStorage storage, string label)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeStorage((ImGuiStorage*)pstorage, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeTabBar(ImGuiTabBarPtr tabBar, byte* label)
		{
			ImGuiPNative.DebugNodeTabBar(tabBar, label);
		}
		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, byte* label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				ImGuiPNative.DebugNodeTabBar((ImGuiTabBar*)ptabBar, label);
			}
		}
		public static void DebugNodeTabBar(ImGuiTabBarPtr tabBar, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.DebugNodeTabBar(tabBar, (byte*)plabel);
			}
		}
		public static void DebugNodeTabBar(ImGuiTabBarPtr tabBar, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.DebugNodeTabBar(tabBar, (byte*)plabel);
			}
		}
		public static void DebugNodeTabBar(ImGuiTabBarPtr tabBar, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DebugNodeTabBar(tabBar, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, ref byte label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeTabBar((ImGuiTabBar*)ptabBar, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeTabBar((ImGuiTabBar*)ptabBar, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeTabBar(ref ImGuiTabBar tabBar, string label)
		{
			fixed (ImGuiTabBar* ptabBar = &tabBar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeTabBar((ImGuiTabBar*)ptabBar, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeTable(ImGuiTablePtr table)
		{
			ImGuiPNative.DebugNodeTable(table);
		}
		public static void DebugNodeTable(ref ImGuiTable table)
		{
			fixed (ImGuiTable* ptable = &table)
			{
				ImGuiPNative.DebugNodeTable((ImGuiTable*)ptable);
			}
		}
		public static void DebugNodeTableSettings(ImGuiTableSettingsPtr settings)
		{
			ImGuiPNative.DebugNodeTableSettings(settings);
		}
		public static void DebugNodeTableSettings(ref ImGuiTableSettings settings)
		{
			fixed (ImGuiTableSettings* psettings = &settings)
			{
				ImGuiPNative.DebugNodeTableSettings((ImGuiTableSettings*)psettings);
			}
		}
		public static void DebugNodeInputTextState(ImGuiInputTextStatePtr state)
		{
			ImGuiPNative.DebugNodeInputTextState(state);
		}
		public static void DebugNodeInputTextState(ref ImGuiInputTextState state)
		{
			fixed (ImGuiInputTextState* pstate = &state)
			{
				ImGuiPNative.DebugNodeInputTextState((ImGuiInputTextState*)pstate);
			}
		}
		public static void DebugNodeWindow(ImGuiWindowPtr window, byte* label)
		{
			ImGuiPNative.DebugNodeWindow(window, label);
		}
		public static void DebugNodeWindow(ref ImGuiWindow window, byte* label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				ImGuiPNative.DebugNodeWindow((ImGuiWindow*)pwindow, label);
			}
		}
		public static void DebugNodeWindow(ImGuiWindowPtr window, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.DebugNodeWindow(window, (byte*)plabel);
			}
		}
		public static void DebugNodeWindow(ImGuiWindowPtr window, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.DebugNodeWindow(window, (byte*)plabel);
			}
		}
		public static void DebugNodeWindow(ImGuiWindowPtr window, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DebugNodeWindow(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DebugNodeWindow(ref ImGuiWindow window, ref byte label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeWindow((ImGuiWindow*)pwindow, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeWindow(ref ImGuiWindow window, ReadOnlySpan<byte> label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeWindow((ImGuiWindow*)pwindow, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeWindow(ref ImGuiWindow window, string label)
		{
			fixed (ImGuiWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeWindow((ImGuiWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeWindowSettings(ImGuiWindowSettingsPtr settings)
		{
			ImGuiPNative.DebugNodeWindowSettings(settings);
		}
		public static void DebugNodeWindowSettings(ref ImGuiWindowSettings settings)
		{
			fixed (ImGuiWindowSettings* psettings = &settings)
			{
				ImGuiPNative.DebugNodeWindowSettings((ImGuiWindowSettings*)psettings);
			}
		}
		public static void DebugNodeWindowsList(ImVector<ImGuiWindowPtr>* windows, byte* label)
		{
			ImGuiPNative.DebugNodeWindowsList(windows, label);
		}
		public static void DebugNodeWindowsList(ref ImVector<ImGuiWindowPtr> windows, byte* label)
		{
			fixed (ImVector<ImGuiWindowPtr>* pwindows = &windows)
			{
				ImGuiPNative.DebugNodeWindowsList((ImVector<ImGuiWindowPtr>*)pwindows, label);
			}
		}
		public static void DebugNodeWindowsList(ImVector<ImGuiWindowPtr>* windows, ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				ImGuiPNative.DebugNodeWindowsList(windows, (byte*)plabel);
			}
		}
		public static void DebugNodeWindowsList(ImVector<ImGuiWindowPtr>* windows, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				ImGuiPNative.DebugNodeWindowsList(windows, (byte*)plabel);
			}
		}
		public static void DebugNodeWindowsList(ImVector<ImGuiWindowPtr>* windows, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.DebugNodeWindowsList(windows, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void DebugNodeWindowsList(ref ImVector<ImGuiWindowPtr> windows, ref byte label)
		{
			fixed (ImVector<ImGuiWindowPtr>* pwindows = &windows)
			{
				fixed (byte* plabel = &label)
				{
					ImGuiPNative.DebugNodeWindowsList((ImVector<ImGuiWindowPtr>*)pwindows, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeWindowsList(ref ImVector<ImGuiWindowPtr> windows, ReadOnlySpan<byte> label)
		{
			fixed (ImVector<ImGuiWindowPtr>* pwindows = &windows)
			{
				fixed (byte* plabel = label)
				{
					ImGuiPNative.DebugNodeWindowsList((ImVector<ImGuiWindowPtr>*)pwindows, (byte*)plabel);
				}
			}
		}
		public static void DebugNodeWindowsList(ref ImVector<ImGuiWindowPtr> windows, string label)
		{
			fixed (ImVector<ImGuiWindowPtr>* pwindows = &windows)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.DebugNodeWindowsList((ImVector<ImGuiWindowPtr>*)pwindows, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void DebugNodeWindowsListByBeginStackParent(ImGuiWindowPtrPtr windows, int windowsSize, ImGuiWindowPtr parentInBeginStack)
		{
			ImGuiPNative.DebugNodeWindowsListByBeginStackParent(windows, windowsSize, parentInBeginStack);
		}
		public static void DebugNodeWindowsListByBeginStackParent(ref ImGuiWindow* windows, int windowsSize, ImGuiWindowPtr parentInBeginStack)
		{
			fixed (ImGuiWindow** pwindows = &windows)
			{
				ImGuiPNative.DebugNodeWindowsListByBeginStackParent((ImGuiWindow**)pwindows, windowsSize, parentInBeginStack);
			}
		}
		public static void DebugNodeWindowsListByBeginStackParent(ImGuiWindowPtrPtr windows, int windowsSize, ref ImGuiWindow parentInBeginStack)
		{
			fixed (ImGuiWindow* pparentInBeginStack = &parentInBeginStack)
			{
				ImGuiPNative.DebugNodeWindowsListByBeginStackParent(windows, windowsSize, (ImGuiWindow*)pparentInBeginStack);
			}
		}
		public static void DebugNodeWindowsListByBeginStackParent(ref ImGuiWindow* windows, int windowsSize, ref ImGuiWindow parentInBeginStack)
		{
			fixed (ImGuiWindow** pwindows = &windows)
			{
				fixed (ImGuiWindow* pparentInBeginStack = &parentInBeginStack)
				{
					ImGuiPNative.DebugNodeWindowsListByBeginStackParent((ImGuiWindow**)pwindows, windowsSize, (ImGuiWindow*)pparentInBeginStack);
				}
			}
		}
		public static void DebugNodeViewport(ImGuiViewportPPtr viewport)
		{
			ImGuiPNative.DebugNodeViewport(viewport);
		}
		public static void DebugNodeViewport(ref ImGuiViewportP viewport)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.DebugNodeViewport((ImGuiViewportP*)pviewport);
			}
		}
		public static void DebugRenderViewportThumbnail(ImDrawListPtr drawList, ImGuiViewportPPtr viewport, ImRect bb)
		{
			ImGuiPNative.DebugRenderViewportThumbnail(drawList, viewport, bb);
		}
		public static void DebugRenderViewportThumbnail(ref ImDrawList drawList, ImGuiViewportPPtr viewport, ImRect bb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				ImGuiPNative.DebugRenderViewportThumbnail((ImDrawList*)pdrawList, viewport, bb);
			}
		}
		public static void DebugRenderViewportThumbnail(ImDrawListPtr drawList, ref ImGuiViewportP viewport, ImRect bb)
		{
			fixed (ImGuiViewportP* pviewport = &viewport)
			{
				ImGuiPNative.DebugRenderViewportThumbnail(drawList, (ImGuiViewportP*)pviewport, bb);
			}
		}
		public static void DebugRenderViewportThumbnail(ref ImDrawList drawList, ref ImGuiViewportP viewport, ImRect bb)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (ImGuiViewportP* pviewport = &viewport)
				{
					ImGuiPNative.DebugRenderViewportThumbnail((ImDrawList*)pdrawList, (ImGuiViewportP*)pviewport, bb);
				}
			}
		}
		public static ImFontBuilderIOPtr ImFontAtlasGetBuilderForStbTruetype()
		{
			ImFontBuilderIOPtr ret = ImGuiPNative.ImFontAtlasGetBuilderForStbTruetype();
			return ret;
		}
		public static void ImFontAtlasBuildInit(ImFontAtlasPtr atlas)
		{
			ImGuiPNative.ImFontAtlasBuildInit(atlas);
		}
		public static void ImFontAtlasBuildInit(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImGuiPNative.ImFontAtlasBuildInit((ImFontAtlas*)patlas);
			}
		}
		public static void ImFontAtlasBuildSetupFont(ImFontAtlasPtr atlas, ImFontPtr font, ImFontConfigPtr fontConfig, float ascent, float descent)
		{
			ImGuiPNative.ImFontAtlasBuildSetupFont(atlas, font, fontConfig, ascent, descent);
		}
		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ImFontPtr font, ImFontConfigPtr fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImGuiPNative.ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, font, fontConfig, ascent, descent);
			}
		}
		public static void ImFontAtlasBuildSetupFont(ImFontAtlasPtr atlas, ref ImFont font, ImFontConfigPtr fontConfig, float ascent, float descent)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGuiPNative.ImFontAtlasBuildSetupFont(atlas, (ImFont*)pfont, fontConfig, ascent, descent);
			}
		}
		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ref ImFont font, ImFontConfigPtr fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGuiPNative.ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, (ImFont*)pfont, fontConfig, ascent, descent);
				}
			}
		}
		public static void ImFontAtlasBuildSetupFont(ImFontAtlasPtr atlas, ImFontPtr font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontConfig* pfontConfig = &fontConfig)
			{
				ImGuiPNative.ImFontAtlasBuildSetupFont(atlas, font, (ImFontConfig*)pfontConfig, ascent, descent);
			}
		}
		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ImFontPtr font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFontConfig* pfontConfig = &fontConfig)
				{
					ImGuiPNative.ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, font, (ImFontConfig*)pfontConfig, ascent, descent);
				}
			}
		}
		public static void ImFontAtlasBuildSetupFont(ImFontAtlasPtr atlas, ref ImFont font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (ImFontConfig* pfontConfig = &fontConfig)
				{
					ImGuiPNative.ImFontAtlasBuildSetupFont(atlas, (ImFont*)pfont, (ImFontConfig*)pfontConfig, ascent, descent);
				}
			}
		}
		public static void ImFontAtlasBuildSetupFont(ref ImFontAtlas atlas, ref ImFont font, ref ImFontConfig fontConfig, float ascent, float descent)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (ImFontConfig* pfontConfig = &fontConfig)
					{
						ImGuiPNative.ImFontAtlasBuildSetupFont((ImFontAtlas*)patlas, (ImFont*)pfont, (ImFontConfig*)pfontConfig, ascent, descent);
					}
				}
			}
		}
		public static void ImFontAtlasBuildFinish(ImFontAtlasPtr atlas)
		{
			ImGuiPNative.ImFontAtlasBuildFinish(atlas);
		}
		public static void ImFontAtlasBuildFinish(ref ImFontAtlas atlas)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImGuiPNative.ImFontAtlasBuildFinish((ImFontAtlas*)patlas);
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString(atlas, textureIndex, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (byte* pinStr = &inStr)
			{
				ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString(atlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, ReadOnlySpan<byte> inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (byte* pinStr = inStr)
			{
				ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString(atlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, string inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString(atlas, textureIndex, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = &inStr)
				{
					ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, ReadOnlySpan<byte> inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = inStr)
				{
					ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}
		public static void ImFontAtlasBuildRender8bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, string inStr, byte inMarkerChar, byte inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inStr != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inStr);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.ImFontAtlasBuildRender8bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString(atlas, textureIndex, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, byte* inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, inStr, inMarkerChar, inMarkerPixelValue);
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (byte* pinStr = &inStr)
			{
				ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString(atlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, ReadOnlySpan<byte> inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (byte* pinStr = inStr)
			{
				ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString(atlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlasPtr atlas, int textureIndex, int x, int y, int w, int h, string inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString(atlas, textureIndex, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, ref byte inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = &inStr)
				{
					ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, ReadOnlySpan<byte> inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				fixed (byte* pinStr = inStr)
				{
					ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, (byte*)pinStr, inMarkerChar, inMarkerPixelValue);
				}
			}
		}
		public static void ImFontAtlasBuildRender32bppRectFromString(ref ImFontAtlas atlas, int textureIndex, int x, int y, int w, int h, string inStr, byte inMarkerChar, uint inMarkerPixelValue)
		{
			fixed (ImFontAtlas* patlas = &atlas)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inStr != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inStr);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inStr, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiPNative.ImFontAtlasBuildRender32bppRectFromString((ImFontAtlas*)patlas, textureIndex, x, y, w, h, pStr0, inMarkerChar, inMarkerPixelValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
		public static void ImFontAtlasBuildMultiplyCalcLookupTable(byte* outTable, float inMultiplyFactor, float gammaFactor)
		{
			ImGuiPNative.ImFontAtlasBuildMultiplyCalcLookupTable(outTable, inMultiplyFactor, gammaFactor);
		}
		public static void ImFontAtlasBuildMultiplyCalcLookupTable(ref byte outTable, float inMultiplyFactor, float gammaFactor)
		{
			fixed (byte* poutTable = &outTable)
			{
				ImGuiPNative.ImFontAtlasBuildMultiplyCalcLookupTable((byte*)poutTable, inMultiplyFactor, gammaFactor);
			}
		}
		public static void ImFontAtlasBuildMultiplyCalcLookupTable(ReadOnlySpan<byte> outTable, float inMultiplyFactor, float gammaFactor)
		{
			fixed (byte* poutTable = outTable)
			{
				ImGuiPNative.ImFontAtlasBuildMultiplyCalcLookupTable((byte*)poutTable, inMultiplyFactor, gammaFactor);
			}
		}
		public static void ImFontAtlasBuildMultiplyRectAlpha8(byte* table, byte* pixels, int x, int y, int w, int h, int stride)
		{
			ImGuiPNative.ImFontAtlasBuildMultiplyRectAlpha8(table, pixels, x, y, w, h, stride);
		}
		public static void ImFontAtlasBuildMultiplyRectAlpha8(ref byte table, byte* pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = &table)
			{
				ImGuiPNative.ImFontAtlasBuildMultiplyRectAlpha8((byte*)ptable, pixels, x, y, w, h, stride);
			}
		}
		public static void ImFontAtlasBuildMultiplyRectAlpha8(ReadOnlySpan<byte> table, byte* pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = table)
			{
				ImGuiPNative.ImFontAtlasBuildMultiplyRectAlpha8((byte*)ptable, pixels, x, y, w, h, stride);
			}
		}
		public static void ImFontAtlasBuildMultiplyRectAlpha8(byte* table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ppixels = &pixels)
			{
				ImGuiPNative.ImFontAtlasBuildMultiplyRectAlpha8(table, (byte*)ppixels, x, y, w, h, stride);
			}
		}
		public static void ImFontAtlasBuildMultiplyRectAlpha8(ref byte table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = &table)
			{
				fixed (byte* ppixels = &pixels)
				{
					ImGuiPNative.ImFontAtlasBuildMultiplyRectAlpha8((byte*)ptable, (byte*)ppixels, x, y, w, h, stride);
				}
			}
		}
		public static void ImFontAtlasBuildMultiplyRectAlpha8(ReadOnlySpan<byte> table, ref byte pixels, int x, int y, int w, int h, int stride)
		{
			fixed (byte* ptable = table)
			{
				fixed (byte* ppixels = &pixels)
				{
					ImGuiPNative.ImFontAtlasBuildMultiplyRectAlpha8((byte*)ptable, (byte*)ppixels, x, y, w, h, stride);
				}
			}
		}
}
// DISCARDED: ColorEditOptionsPopup
// DISCARDED: ColorPickerOptionsPopup
// DISCARDED: DebugLog
// DISCARDED: DebugLogV
// DISCARDED: DragBehavior
// DISCARDED: FindRenderedTextEnd
// DISCARDED: FindRenderedTextEndS
// DISCARDED: GetID
// DISCARDED: GetIDWithSeed
// DISCARDED: ImFormatStringToTempBuffer
// DISCARDED: ImFormatStringToTempBufferV
// DISCARDED: ImHashData
// DISCARDED: ImHashStr
// DISCARDED: ImParseFormatSanitizeForPrinting
// DISCARDED: ImParseFormatSanitizeForScanning
// DISCARDED: ImParseFormatSanitizeForScanningS
// DISCARDED: ImStrchrRange
// DISCARDED: ImStrchrRangeS
// DISCARDED: ImStreolRange
// DISCARDED: ImStreolRangeS
// DISCARDED: LogRenderedText
// DISCARDED: RenderText
// DISCARDED: RenderTextClipped
// DISCARDED: RenderTextClippedEx
// DISCARDED: RenderTextEllipsis
// DISCARDED: RenderTextWrapped
// DISCARDED: SliderBehavior
// DISCARDED: TextEx

