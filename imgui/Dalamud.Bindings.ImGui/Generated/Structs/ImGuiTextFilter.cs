// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Dalamud.Bindings.ImGui
{
	/// <summary>
	/// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"<br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextFilter
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte InputBuf_0;
		public byte InputBuf_1;
		public byte InputBuf_2;
		public byte InputBuf_3;
		public byte InputBuf_4;
		public byte InputBuf_5;
		public byte InputBuf_6;
		public byte InputBuf_7;
		public byte InputBuf_8;
		public byte InputBuf_9;
		public byte InputBuf_10;
		public byte InputBuf_11;
		public byte InputBuf_12;
		public byte InputBuf_13;
		public byte InputBuf_14;
		public byte InputBuf_15;
		public byte InputBuf_16;
		public byte InputBuf_17;
		public byte InputBuf_18;
		public byte InputBuf_19;
		public byte InputBuf_20;
		public byte InputBuf_21;
		public byte InputBuf_22;
		public byte InputBuf_23;
		public byte InputBuf_24;
		public byte InputBuf_25;
		public byte InputBuf_26;
		public byte InputBuf_27;
		public byte InputBuf_28;
		public byte InputBuf_29;
		public byte InputBuf_30;
		public byte InputBuf_31;
		public byte InputBuf_32;
		public byte InputBuf_33;
		public byte InputBuf_34;
		public byte InputBuf_35;
		public byte InputBuf_36;
		public byte InputBuf_37;
		public byte InputBuf_38;
		public byte InputBuf_39;
		public byte InputBuf_40;
		public byte InputBuf_41;
		public byte InputBuf_42;
		public byte InputBuf_43;
		public byte InputBuf_44;
		public byte InputBuf_45;
		public byte InputBuf_46;
		public byte InputBuf_47;
		public byte InputBuf_48;
		public byte InputBuf_49;
		public byte InputBuf_50;
		public byte InputBuf_51;
		public byte InputBuf_52;
		public byte InputBuf_53;
		public byte InputBuf_54;
		public byte InputBuf_55;
		public byte InputBuf_56;
		public byte InputBuf_57;
		public byte InputBuf_58;
		public byte InputBuf_59;
		public byte InputBuf_60;
		public byte InputBuf_61;
		public byte InputBuf_62;
		public byte InputBuf_63;
		public byte InputBuf_64;
		public byte InputBuf_65;
		public byte InputBuf_66;
		public byte InputBuf_67;
		public byte InputBuf_68;
		public byte InputBuf_69;
		public byte InputBuf_70;
		public byte InputBuf_71;
		public byte InputBuf_72;
		public byte InputBuf_73;
		public byte InputBuf_74;
		public byte InputBuf_75;
		public byte InputBuf_76;
		public byte InputBuf_77;
		public byte InputBuf_78;
		public byte InputBuf_79;
		public byte InputBuf_80;
		public byte InputBuf_81;
		public byte InputBuf_82;
		public byte InputBuf_83;
		public byte InputBuf_84;
		public byte InputBuf_85;
		public byte InputBuf_86;
		public byte InputBuf_87;
		public byte InputBuf_88;
		public byte InputBuf_89;
		public byte InputBuf_90;
		public byte InputBuf_91;
		public byte InputBuf_92;
		public byte InputBuf_93;
		public byte InputBuf_94;
		public byte InputBuf_95;
		public byte InputBuf_96;
		public byte InputBuf_97;
		public byte InputBuf_98;
		public byte InputBuf_99;
		public byte InputBuf_100;
		public byte InputBuf_101;
		public byte InputBuf_102;
		public byte InputBuf_103;
		public byte InputBuf_104;
		public byte InputBuf_105;
		public byte InputBuf_106;
		public byte InputBuf_107;
		public byte InputBuf_108;
		public byte InputBuf_109;
		public byte InputBuf_110;
		public byte InputBuf_111;
		public byte InputBuf_112;
		public byte InputBuf_113;
		public byte InputBuf_114;
		public byte InputBuf_115;
		public byte InputBuf_116;
		public byte InputBuf_117;
		public byte InputBuf_118;
		public byte InputBuf_119;
		public byte InputBuf_120;
		public byte InputBuf_121;
		public byte InputBuf_122;
		public byte InputBuf_123;
		public byte InputBuf_124;
		public byte InputBuf_125;
		public byte InputBuf_126;
		public byte InputBuf_127;
		public byte InputBuf_128;
		public byte InputBuf_129;
		public byte InputBuf_130;
		public byte InputBuf_131;
		public byte InputBuf_132;
		public byte InputBuf_133;
		public byte InputBuf_134;
		public byte InputBuf_135;
		public byte InputBuf_136;
		public byte InputBuf_137;
		public byte InputBuf_138;
		public byte InputBuf_139;
		public byte InputBuf_140;
		public byte InputBuf_141;
		public byte InputBuf_142;
		public byte InputBuf_143;
		public byte InputBuf_144;
		public byte InputBuf_145;
		public byte InputBuf_146;
		public byte InputBuf_147;
		public byte InputBuf_148;
		public byte InputBuf_149;
		public byte InputBuf_150;
		public byte InputBuf_151;
		public byte InputBuf_152;
		public byte InputBuf_153;
		public byte InputBuf_154;
		public byte InputBuf_155;
		public byte InputBuf_156;
		public byte InputBuf_157;
		public byte InputBuf_158;
		public byte InputBuf_159;
		public byte InputBuf_160;
		public byte InputBuf_161;
		public byte InputBuf_162;
		public byte InputBuf_163;
		public byte InputBuf_164;
		public byte InputBuf_165;
		public byte InputBuf_166;
		public byte InputBuf_167;
		public byte InputBuf_168;
		public byte InputBuf_169;
		public byte InputBuf_170;
		public byte InputBuf_171;
		public byte InputBuf_172;
		public byte InputBuf_173;
		public byte InputBuf_174;
		public byte InputBuf_175;
		public byte InputBuf_176;
		public byte InputBuf_177;
		public byte InputBuf_178;
		public byte InputBuf_179;
		public byte InputBuf_180;
		public byte InputBuf_181;
		public byte InputBuf_182;
		public byte InputBuf_183;
		public byte InputBuf_184;
		public byte InputBuf_185;
		public byte InputBuf_186;
		public byte InputBuf_187;
		public byte InputBuf_188;
		public byte InputBuf_189;
		public byte InputBuf_190;
		public byte InputBuf_191;
		public byte InputBuf_192;
		public byte InputBuf_193;
		public byte InputBuf_194;
		public byte InputBuf_195;
		public byte InputBuf_196;
		public byte InputBuf_197;
		public byte InputBuf_198;
		public byte InputBuf_199;
		public byte InputBuf_200;
		public byte InputBuf_201;
		public byte InputBuf_202;
		public byte InputBuf_203;
		public byte InputBuf_204;
		public byte InputBuf_205;
		public byte InputBuf_206;
		public byte InputBuf_207;
		public byte InputBuf_208;
		public byte InputBuf_209;
		public byte InputBuf_210;
		public byte InputBuf_211;
		public byte InputBuf_212;
		public byte InputBuf_213;
		public byte InputBuf_214;
		public byte InputBuf_215;
		public byte InputBuf_216;
		public byte InputBuf_217;
		public byte InputBuf_218;
		public byte InputBuf_219;
		public byte InputBuf_220;
		public byte InputBuf_221;
		public byte InputBuf_222;
		public byte InputBuf_223;
		public byte InputBuf_224;
		public byte InputBuf_225;
		public byte InputBuf_226;
		public byte InputBuf_227;
		public byte InputBuf_228;
		public byte InputBuf_229;
		public byte InputBuf_230;
		public byte InputBuf_231;
		public byte InputBuf_232;
		public byte InputBuf_233;
		public byte InputBuf_234;
		public byte InputBuf_235;
		public byte InputBuf_236;
		public byte InputBuf_237;
		public byte InputBuf_238;
		public byte InputBuf_239;
		public byte InputBuf_240;
		public byte InputBuf_241;
		public byte InputBuf_242;
		public byte InputBuf_243;
		public byte InputBuf_244;
		public byte InputBuf_245;
		public byte InputBuf_246;
		public byte InputBuf_247;
		public byte InputBuf_248;
		public byte InputBuf_249;
		public byte InputBuf_250;
		public byte InputBuf_251;
		public byte InputBuf_252;
		public byte InputBuf_253;
		public byte InputBuf_254;
		public byte InputBuf_255;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<ImGuiTextRange> Filters;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CountGrep;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTextFilter(byte* inputBuf = default, ImVector<ImGuiTextRange> filters = default, int countGrep = default)
		{
			if (inputBuf != default(byte*))
			{
				InputBuf_0 = inputBuf[0];
				InputBuf_1 = inputBuf[1];
				InputBuf_2 = inputBuf[2];
				InputBuf_3 = inputBuf[3];
				InputBuf_4 = inputBuf[4];
				InputBuf_5 = inputBuf[5];
				InputBuf_6 = inputBuf[6];
				InputBuf_7 = inputBuf[7];
				InputBuf_8 = inputBuf[8];
				InputBuf_9 = inputBuf[9];
				InputBuf_10 = inputBuf[10];
				InputBuf_11 = inputBuf[11];
				InputBuf_12 = inputBuf[12];
				InputBuf_13 = inputBuf[13];
				InputBuf_14 = inputBuf[14];
				InputBuf_15 = inputBuf[15];
				InputBuf_16 = inputBuf[16];
				InputBuf_17 = inputBuf[17];
				InputBuf_18 = inputBuf[18];
				InputBuf_19 = inputBuf[19];
				InputBuf_20 = inputBuf[20];
				InputBuf_21 = inputBuf[21];
				InputBuf_22 = inputBuf[22];
				InputBuf_23 = inputBuf[23];
				InputBuf_24 = inputBuf[24];
				InputBuf_25 = inputBuf[25];
				InputBuf_26 = inputBuf[26];
				InputBuf_27 = inputBuf[27];
				InputBuf_28 = inputBuf[28];
				InputBuf_29 = inputBuf[29];
				InputBuf_30 = inputBuf[30];
				InputBuf_31 = inputBuf[31];
				InputBuf_32 = inputBuf[32];
				InputBuf_33 = inputBuf[33];
				InputBuf_34 = inputBuf[34];
				InputBuf_35 = inputBuf[35];
				InputBuf_36 = inputBuf[36];
				InputBuf_37 = inputBuf[37];
				InputBuf_38 = inputBuf[38];
				InputBuf_39 = inputBuf[39];
				InputBuf_40 = inputBuf[40];
				InputBuf_41 = inputBuf[41];
				InputBuf_42 = inputBuf[42];
				InputBuf_43 = inputBuf[43];
				InputBuf_44 = inputBuf[44];
				InputBuf_45 = inputBuf[45];
				InputBuf_46 = inputBuf[46];
				InputBuf_47 = inputBuf[47];
				InputBuf_48 = inputBuf[48];
				InputBuf_49 = inputBuf[49];
				InputBuf_50 = inputBuf[50];
				InputBuf_51 = inputBuf[51];
				InputBuf_52 = inputBuf[52];
				InputBuf_53 = inputBuf[53];
				InputBuf_54 = inputBuf[54];
				InputBuf_55 = inputBuf[55];
				InputBuf_56 = inputBuf[56];
				InputBuf_57 = inputBuf[57];
				InputBuf_58 = inputBuf[58];
				InputBuf_59 = inputBuf[59];
				InputBuf_60 = inputBuf[60];
				InputBuf_61 = inputBuf[61];
				InputBuf_62 = inputBuf[62];
				InputBuf_63 = inputBuf[63];
				InputBuf_64 = inputBuf[64];
				InputBuf_65 = inputBuf[65];
				InputBuf_66 = inputBuf[66];
				InputBuf_67 = inputBuf[67];
				InputBuf_68 = inputBuf[68];
				InputBuf_69 = inputBuf[69];
				InputBuf_70 = inputBuf[70];
				InputBuf_71 = inputBuf[71];
				InputBuf_72 = inputBuf[72];
				InputBuf_73 = inputBuf[73];
				InputBuf_74 = inputBuf[74];
				InputBuf_75 = inputBuf[75];
				InputBuf_76 = inputBuf[76];
				InputBuf_77 = inputBuf[77];
				InputBuf_78 = inputBuf[78];
				InputBuf_79 = inputBuf[79];
				InputBuf_80 = inputBuf[80];
				InputBuf_81 = inputBuf[81];
				InputBuf_82 = inputBuf[82];
				InputBuf_83 = inputBuf[83];
				InputBuf_84 = inputBuf[84];
				InputBuf_85 = inputBuf[85];
				InputBuf_86 = inputBuf[86];
				InputBuf_87 = inputBuf[87];
				InputBuf_88 = inputBuf[88];
				InputBuf_89 = inputBuf[89];
				InputBuf_90 = inputBuf[90];
				InputBuf_91 = inputBuf[91];
				InputBuf_92 = inputBuf[92];
				InputBuf_93 = inputBuf[93];
				InputBuf_94 = inputBuf[94];
				InputBuf_95 = inputBuf[95];
				InputBuf_96 = inputBuf[96];
				InputBuf_97 = inputBuf[97];
				InputBuf_98 = inputBuf[98];
				InputBuf_99 = inputBuf[99];
				InputBuf_100 = inputBuf[100];
				InputBuf_101 = inputBuf[101];
				InputBuf_102 = inputBuf[102];
				InputBuf_103 = inputBuf[103];
				InputBuf_104 = inputBuf[104];
				InputBuf_105 = inputBuf[105];
				InputBuf_106 = inputBuf[106];
				InputBuf_107 = inputBuf[107];
				InputBuf_108 = inputBuf[108];
				InputBuf_109 = inputBuf[109];
				InputBuf_110 = inputBuf[110];
				InputBuf_111 = inputBuf[111];
				InputBuf_112 = inputBuf[112];
				InputBuf_113 = inputBuf[113];
				InputBuf_114 = inputBuf[114];
				InputBuf_115 = inputBuf[115];
				InputBuf_116 = inputBuf[116];
				InputBuf_117 = inputBuf[117];
				InputBuf_118 = inputBuf[118];
				InputBuf_119 = inputBuf[119];
				InputBuf_120 = inputBuf[120];
				InputBuf_121 = inputBuf[121];
				InputBuf_122 = inputBuf[122];
				InputBuf_123 = inputBuf[123];
				InputBuf_124 = inputBuf[124];
				InputBuf_125 = inputBuf[125];
				InputBuf_126 = inputBuf[126];
				InputBuf_127 = inputBuf[127];
				InputBuf_128 = inputBuf[128];
				InputBuf_129 = inputBuf[129];
				InputBuf_130 = inputBuf[130];
				InputBuf_131 = inputBuf[131];
				InputBuf_132 = inputBuf[132];
				InputBuf_133 = inputBuf[133];
				InputBuf_134 = inputBuf[134];
				InputBuf_135 = inputBuf[135];
				InputBuf_136 = inputBuf[136];
				InputBuf_137 = inputBuf[137];
				InputBuf_138 = inputBuf[138];
				InputBuf_139 = inputBuf[139];
				InputBuf_140 = inputBuf[140];
				InputBuf_141 = inputBuf[141];
				InputBuf_142 = inputBuf[142];
				InputBuf_143 = inputBuf[143];
				InputBuf_144 = inputBuf[144];
				InputBuf_145 = inputBuf[145];
				InputBuf_146 = inputBuf[146];
				InputBuf_147 = inputBuf[147];
				InputBuf_148 = inputBuf[148];
				InputBuf_149 = inputBuf[149];
				InputBuf_150 = inputBuf[150];
				InputBuf_151 = inputBuf[151];
				InputBuf_152 = inputBuf[152];
				InputBuf_153 = inputBuf[153];
				InputBuf_154 = inputBuf[154];
				InputBuf_155 = inputBuf[155];
				InputBuf_156 = inputBuf[156];
				InputBuf_157 = inputBuf[157];
				InputBuf_158 = inputBuf[158];
				InputBuf_159 = inputBuf[159];
				InputBuf_160 = inputBuf[160];
				InputBuf_161 = inputBuf[161];
				InputBuf_162 = inputBuf[162];
				InputBuf_163 = inputBuf[163];
				InputBuf_164 = inputBuf[164];
				InputBuf_165 = inputBuf[165];
				InputBuf_166 = inputBuf[166];
				InputBuf_167 = inputBuf[167];
				InputBuf_168 = inputBuf[168];
				InputBuf_169 = inputBuf[169];
				InputBuf_170 = inputBuf[170];
				InputBuf_171 = inputBuf[171];
				InputBuf_172 = inputBuf[172];
				InputBuf_173 = inputBuf[173];
				InputBuf_174 = inputBuf[174];
				InputBuf_175 = inputBuf[175];
				InputBuf_176 = inputBuf[176];
				InputBuf_177 = inputBuf[177];
				InputBuf_178 = inputBuf[178];
				InputBuf_179 = inputBuf[179];
				InputBuf_180 = inputBuf[180];
				InputBuf_181 = inputBuf[181];
				InputBuf_182 = inputBuf[182];
				InputBuf_183 = inputBuf[183];
				InputBuf_184 = inputBuf[184];
				InputBuf_185 = inputBuf[185];
				InputBuf_186 = inputBuf[186];
				InputBuf_187 = inputBuf[187];
				InputBuf_188 = inputBuf[188];
				InputBuf_189 = inputBuf[189];
				InputBuf_190 = inputBuf[190];
				InputBuf_191 = inputBuf[191];
				InputBuf_192 = inputBuf[192];
				InputBuf_193 = inputBuf[193];
				InputBuf_194 = inputBuf[194];
				InputBuf_195 = inputBuf[195];
				InputBuf_196 = inputBuf[196];
				InputBuf_197 = inputBuf[197];
				InputBuf_198 = inputBuf[198];
				InputBuf_199 = inputBuf[199];
				InputBuf_200 = inputBuf[200];
				InputBuf_201 = inputBuf[201];
				InputBuf_202 = inputBuf[202];
				InputBuf_203 = inputBuf[203];
				InputBuf_204 = inputBuf[204];
				InputBuf_205 = inputBuf[205];
				InputBuf_206 = inputBuf[206];
				InputBuf_207 = inputBuf[207];
				InputBuf_208 = inputBuf[208];
				InputBuf_209 = inputBuf[209];
				InputBuf_210 = inputBuf[210];
				InputBuf_211 = inputBuf[211];
				InputBuf_212 = inputBuf[212];
				InputBuf_213 = inputBuf[213];
				InputBuf_214 = inputBuf[214];
				InputBuf_215 = inputBuf[215];
				InputBuf_216 = inputBuf[216];
				InputBuf_217 = inputBuf[217];
				InputBuf_218 = inputBuf[218];
				InputBuf_219 = inputBuf[219];
				InputBuf_220 = inputBuf[220];
				InputBuf_221 = inputBuf[221];
				InputBuf_222 = inputBuf[222];
				InputBuf_223 = inputBuf[223];
				InputBuf_224 = inputBuf[224];
				InputBuf_225 = inputBuf[225];
				InputBuf_226 = inputBuf[226];
				InputBuf_227 = inputBuf[227];
				InputBuf_228 = inputBuf[228];
				InputBuf_229 = inputBuf[229];
				InputBuf_230 = inputBuf[230];
				InputBuf_231 = inputBuf[231];
				InputBuf_232 = inputBuf[232];
				InputBuf_233 = inputBuf[233];
				InputBuf_234 = inputBuf[234];
				InputBuf_235 = inputBuf[235];
				InputBuf_236 = inputBuf[236];
				InputBuf_237 = inputBuf[237];
				InputBuf_238 = inputBuf[238];
				InputBuf_239 = inputBuf[239];
				InputBuf_240 = inputBuf[240];
				InputBuf_241 = inputBuf[241];
				InputBuf_242 = inputBuf[242];
				InputBuf_243 = inputBuf[243];
				InputBuf_244 = inputBuf[244];
				InputBuf_245 = inputBuf[245];
				InputBuf_246 = inputBuf[246];
				InputBuf_247 = inputBuf[247];
				InputBuf_248 = inputBuf[248];
				InputBuf_249 = inputBuf[249];
				InputBuf_250 = inputBuf[250];
				InputBuf_251 = inputBuf[251];
				InputBuf_252 = inputBuf[252];
				InputBuf_253 = inputBuf[253];
				InputBuf_254 = inputBuf[254];
				InputBuf_255 = inputBuf[255];
			}
			Filters = filters;
			CountGrep = countGrep;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTextFilter(Span<byte> inputBuf = default, ImVector<ImGuiTextRange> filters = default, int countGrep = default)
		{
			if (inputBuf != default(Span<byte>))
			{
				InputBuf_0 = inputBuf[0];
				InputBuf_1 = inputBuf[1];
				InputBuf_2 = inputBuf[2];
				InputBuf_3 = inputBuf[3];
				InputBuf_4 = inputBuf[4];
				InputBuf_5 = inputBuf[5];
				InputBuf_6 = inputBuf[6];
				InputBuf_7 = inputBuf[7];
				InputBuf_8 = inputBuf[8];
				InputBuf_9 = inputBuf[9];
				InputBuf_10 = inputBuf[10];
				InputBuf_11 = inputBuf[11];
				InputBuf_12 = inputBuf[12];
				InputBuf_13 = inputBuf[13];
				InputBuf_14 = inputBuf[14];
				InputBuf_15 = inputBuf[15];
				InputBuf_16 = inputBuf[16];
				InputBuf_17 = inputBuf[17];
				InputBuf_18 = inputBuf[18];
				InputBuf_19 = inputBuf[19];
				InputBuf_20 = inputBuf[20];
				InputBuf_21 = inputBuf[21];
				InputBuf_22 = inputBuf[22];
				InputBuf_23 = inputBuf[23];
				InputBuf_24 = inputBuf[24];
				InputBuf_25 = inputBuf[25];
				InputBuf_26 = inputBuf[26];
				InputBuf_27 = inputBuf[27];
				InputBuf_28 = inputBuf[28];
				InputBuf_29 = inputBuf[29];
				InputBuf_30 = inputBuf[30];
				InputBuf_31 = inputBuf[31];
				InputBuf_32 = inputBuf[32];
				InputBuf_33 = inputBuf[33];
				InputBuf_34 = inputBuf[34];
				InputBuf_35 = inputBuf[35];
				InputBuf_36 = inputBuf[36];
				InputBuf_37 = inputBuf[37];
				InputBuf_38 = inputBuf[38];
				InputBuf_39 = inputBuf[39];
				InputBuf_40 = inputBuf[40];
				InputBuf_41 = inputBuf[41];
				InputBuf_42 = inputBuf[42];
				InputBuf_43 = inputBuf[43];
				InputBuf_44 = inputBuf[44];
				InputBuf_45 = inputBuf[45];
				InputBuf_46 = inputBuf[46];
				InputBuf_47 = inputBuf[47];
				InputBuf_48 = inputBuf[48];
				InputBuf_49 = inputBuf[49];
				InputBuf_50 = inputBuf[50];
				InputBuf_51 = inputBuf[51];
				InputBuf_52 = inputBuf[52];
				InputBuf_53 = inputBuf[53];
				InputBuf_54 = inputBuf[54];
				InputBuf_55 = inputBuf[55];
				InputBuf_56 = inputBuf[56];
				InputBuf_57 = inputBuf[57];
				InputBuf_58 = inputBuf[58];
				InputBuf_59 = inputBuf[59];
				InputBuf_60 = inputBuf[60];
				InputBuf_61 = inputBuf[61];
				InputBuf_62 = inputBuf[62];
				InputBuf_63 = inputBuf[63];
				InputBuf_64 = inputBuf[64];
				InputBuf_65 = inputBuf[65];
				InputBuf_66 = inputBuf[66];
				InputBuf_67 = inputBuf[67];
				InputBuf_68 = inputBuf[68];
				InputBuf_69 = inputBuf[69];
				InputBuf_70 = inputBuf[70];
				InputBuf_71 = inputBuf[71];
				InputBuf_72 = inputBuf[72];
				InputBuf_73 = inputBuf[73];
				InputBuf_74 = inputBuf[74];
				InputBuf_75 = inputBuf[75];
				InputBuf_76 = inputBuf[76];
				InputBuf_77 = inputBuf[77];
				InputBuf_78 = inputBuf[78];
				InputBuf_79 = inputBuf[79];
				InputBuf_80 = inputBuf[80];
				InputBuf_81 = inputBuf[81];
				InputBuf_82 = inputBuf[82];
				InputBuf_83 = inputBuf[83];
				InputBuf_84 = inputBuf[84];
				InputBuf_85 = inputBuf[85];
				InputBuf_86 = inputBuf[86];
				InputBuf_87 = inputBuf[87];
				InputBuf_88 = inputBuf[88];
				InputBuf_89 = inputBuf[89];
				InputBuf_90 = inputBuf[90];
				InputBuf_91 = inputBuf[91];
				InputBuf_92 = inputBuf[92];
				InputBuf_93 = inputBuf[93];
				InputBuf_94 = inputBuf[94];
				InputBuf_95 = inputBuf[95];
				InputBuf_96 = inputBuf[96];
				InputBuf_97 = inputBuf[97];
				InputBuf_98 = inputBuf[98];
				InputBuf_99 = inputBuf[99];
				InputBuf_100 = inputBuf[100];
				InputBuf_101 = inputBuf[101];
				InputBuf_102 = inputBuf[102];
				InputBuf_103 = inputBuf[103];
				InputBuf_104 = inputBuf[104];
				InputBuf_105 = inputBuf[105];
				InputBuf_106 = inputBuf[106];
				InputBuf_107 = inputBuf[107];
				InputBuf_108 = inputBuf[108];
				InputBuf_109 = inputBuf[109];
				InputBuf_110 = inputBuf[110];
				InputBuf_111 = inputBuf[111];
				InputBuf_112 = inputBuf[112];
				InputBuf_113 = inputBuf[113];
				InputBuf_114 = inputBuf[114];
				InputBuf_115 = inputBuf[115];
				InputBuf_116 = inputBuf[116];
				InputBuf_117 = inputBuf[117];
				InputBuf_118 = inputBuf[118];
				InputBuf_119 = inputBuf[119];
				InputBuf_120 = inputBuf[120];
				InputBuf_121 = inputBuf[121];
				InputBuf_122 = inputBuf[122];
				InputBuf_123 = inputBuf[123];
				InputBuf_124 = inputBuf[124];
				InputBuf_125 = inputBuf[125];
				InputBuf_126 = inputBuf[126];
				InputBuf_127 = inputBuf[127];
				InputBuf_128 = inputBuf[128];
				InputBuf_129 = inputBuf[129];
				InputBuf_130 = inputBuf[130];
				InputBuf_131 = inputBuf[131];
				InputBuf_132 = inputBuf[132];
				InputBuf_133 = inputBuf[133];
				InputBuf_134 = inputBuf[134];
				InputBuf_135 = inputBuf[135];
				InputBuf_136 = inputBuf[136];
				InputBuf_137 = inputBuf[137];
				InputBuf_138 = inputBuf[138];
				InputBuf_139 = inputBuf[139];
				InputBuf_140 = inputBuf[140];
				InputBuf_141 = inputBuf[141];
				InputBuf_142 = inputBuf[142];
				InputBuf_143 = inputBuf[143];
				InputBuf_144 = inputBuf[144];
				InputBuf_145 = inputBuf[145];
				InputBuf_146 = inputBuf[146];
				InputBuf_147 = inputBuf[147];
				InputBuf_148 = inputBuf[148];
				InputBuf_149 = inputBuf[149];
				InputBuf_150 = inputBuf[150];
				InputBuf_151 = inputBuf[151];
				InputBuf_152 = inputBuf[152];
				InputBuf_153 = inputBuf[153];
				InputBuf_154 = inputBuf[154];
				InputBuf_155 = inputBuf[155];
				InputBuf_156 = inputBuf[156];
				InputBuf_157 = inputBuf[157];
				InputBuf_158 = inputBuf[158];
				InputBuf_159 = inputBuf[159];
				InputBuf_160 = inputBuf[160];
				InputBuf_161 = inputBuf[161];
				InputBuf_162 = inputBuf[162];
				InputBuf_163 = inputBuf[163];
				InputBuf_164 = inputBuf[164];
				InputBuf_165 = inputBuf[165];
				InputBuf_166 = inputBuf[166];
				InputBuf_167 = inputBuf[167];
				InputBuf_168 = inputBuf[168];
				InputBuf_169 = inputBuf[169];
				InputBuf_170 = inputBuf[170];
				InputBuf_171 = inputBuf[171];
				InputBuf_172 = inputBuf[172];
				InputBuf_173 = inputBuf[173];
				InputBuf_174 = inputBuf[174];
				InputBuf_175 = inputBuf[175];
				InputBuf_176 = inputBuf[176];
				InputBuf_177 = inputBuf[177];
				InputBuf_178 = inputBuf[178];
				InputBuf_179 = inputBuf[179];
				InputBuf_180 = inputBuf[180];
				InputBuf_181 = inputBuf[181];
				InputBuf_182 = inputBuf[182];
				InputBuf_183 = inputBuf[183];
				InputBuf_184 = inputBuf[184];
				InputBuf_185 = inputBuf[185];
				InputBuf_186 = inputBuf[186];
				InputBuf_187 = inputBuf[187];
				InputBuf_188 = inputBuf[188];
				InputBuf_189 = inputBuf[189];
				InputBuf_190 = inputBuf[190];
				InputBuf_191 = inputBuf[191];
				InputBuf_192 = inputBuf[192];
				InputBuf_193 = inputBuf[193];
				InputBuf_194 = inputBuf[194];
				InputBuf_195 = inputBuf[195];
				InputBuf_196 = inputBuf[196];
				InputBuf_197 = inputBuf[197];
				InputBuf_198 = inputBuf[198];
				InputBuf_199 = inputBuf[199];
				InputBuf_200 = inputBuf[200];
				InputBuf_201 = inputBuf[201];
				InputBuf_202 = inputBuf[202];
				InputBuf_203 = inputBuf[203];
				InputBuf_204 = inputBuf[204];
				InputBuf_205 = inputBuf[205];
				InputBuf_206 = inputBuf[206];
				InputBuf_207 = inputBuf[207];
				InputBuf_208 = inputBuf[208];
				InputBuf_209 = inputBuf[209];
				InputBuf_210 = inputBuf[210];
				InputBuf_211 = inputBuf[211];
				InputBuf_212 = inputBuf[212];
				InputBuf_213 = inputBuf[213];
				InputBuf_214 = inputBuf[214];
				InputBuf_215 = inputBuf[215];
				InputBuf_216 = inputBuf[216];
				InputBuf_217 = inputBuf[217];
				InputBuf_218 = inputBuf[218];
				InputBuf_219 = inputBuf[219];
				InputBuf_220 = inputBuf[220];
				InputBuf_221 = inputBuf[221];
				InputBuf_222 = inputBuf[222];
				InputBuf_223 = inputBuf[223];
				InputBuf_224 = inputBuf[224];
				InputBuf_225 = inputBuf[225];
				InputBuf_226 = inputBuf[226];
				InputBuf_227 = inputBuf[227];
				InputBuf_228 = inputBuf[228];
				InputBuf_229 = inputBuf[229];
				InputBuf_230 = inputBuf[230];
				InputBuf_231 = inputBuf[231];
				InputBuf_232 = inputBuf[232];
				InputBuf_233 = inputBuf[233];
				InputBuf_234 = inputBuf[234];
				InputBuf_235 = inputBuf[235];
				InputBuf_236 = inputBuf[236];
				InputBuf_237 = inputBuf[237];
				InputBuf_238 = inputBuf[238];
				InputBuf_239 = inputBuf[239];
				InputBuf_240 = inputBuf[240];
				InputBuf_241 = inputBuf[241];
				InputBuf_242 = inputBuf[242];
				InputBuf_243 = inputBuf[243];
				InputBuf_244 = inputBuf[244];
				InputBuf_245 = inputBuf[245];
				InputBuf_246 = inputBuf[246];
				InputBuf_247 = inputBuf[247];
				InputBuf_248 = inputBuf[248];
				InputBuf_249 = inputBuf[249];
				InputBuf_250 = inputBuf[250];
				InputBuf_251 = inputBuf[251];
				InputBuf_252 = inputBuf[252];
				InputBuf_253 = inputBuf[253];
				InputBuf_254 = inputBuf[254];
				InputBuf_255 = inputBuf[255];
			}
			Filters = filters;
			CountGrep = countGrep;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Build()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.BuildNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Clear()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(byte* label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, width);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(byte* label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", (float)(0.0f));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", width);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ref byte label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ReadOnlySpan<byte> label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ReadOnlySpan<byte> label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(string label, float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(string label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, (float)(0.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool IsActive()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.IsActiveNative(@this);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, textEnd);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, (byte*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, textEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, textEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, text, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, text, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = text)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImGuiTextFilterPtr : IEquatable<ImGuiTextFilterPtr>
	{
		public ImGuiTextFilterPtr(ImGuiTextFilter* handle) { Handle = handle; }

		public ImGuiTextFilter* Handle;

		public bool IsNull => Handle == null;

		public static ImGuiTextFilterPtr Null => new ImGuiTextFilterPtr(null);

		public ImGuiTextFilter this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImGuiTextFilterPtr(ImGuiTextFilter* handle) => new ImGuiTextFilterPtr(handle);

		public static implicit operator ImGuiTextFilter*(ImGuiTextFilterPtr handle) => handle.Handle;

		public static bool operator ==(ImGuiTextFilterPtr left, ImGuiTextFilterPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImGuiTextFilterPtr left, ImGuiTextFilterPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImGuiTextFilterPtr left, ImGuiTextFilter* right) => left.Handle == right;

		public static bool operator !=(ImGuiTextFilterPtr left, ImGuiTextFilter* right) => left.Handle != right;

		public bool Equals(ImGuiTextFilterPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImGuiTextFilterPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImGuiTextFilterPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<byte> InputBuf
		
		{
			get
			{
				return new Span<byte>(&Handle->InputBuf_0, 256);
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<ImGuiTextRange> Filters => ref Unsafe.AsRef<ImVector<ImGuiTextRange>>(&Handle->Filters);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref int CountGrep => ref Unsafe.AsRef<int>(&Handle->CountGrep);
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Build()
		{
			ImGui.BuildNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Clear()
		{
			ImGui.ClearNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(byte* label, float width)
		{
			byte ret = ImGui.DrawNative(Handle, label, width);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(byte* label)
		{
			byte ret = ImGui.DrawNative(Handle, label, (float)(0.0f));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw()
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(float width)
		{
			bool ret = ImGui.Draw(Handle, (string)"Filter(inc,-exc)", width);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ref byte label, float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, width);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ReadOnlySpan<byte> label, float width)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, width);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ImGui.DrawNative(Handle, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(string label, float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.DrawNative(Handle, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool Draw(string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.DrawNative(Handle, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool IsActive()
		{
			byte ret = ImGui.IsActiveNative(Handle);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, byte* textEnd)
		{
			byte ret = ImGui.PassFilterNative(Handle, text, textEnd);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text)
		{
			byte ret = ImGui.PassFilterNative(Handle, text, (byte*)(default));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, textEnd);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (byte* ptext = text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, textEnd);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte ret = ImGui.PassFilterNative(Handle, text, (byte*)ptextEnd);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				byte ret = ImGui.PassFilterNative(Handle, text, (byte*)ptextEnd);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = ImGui.PassFilterNative(Handle, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ref byte text, string textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, ref byte textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(ReadOnlySpan<byte> text, string textEnd)
		{
			fixed (byte* ptext = text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(Handle, (byte*)ptext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				byte ret = ImGui.PassFilterNative(Handle, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe bool PassFilter(string text, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				byte ret = ImGui.PassFilterNative(Handle, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

	}

}
