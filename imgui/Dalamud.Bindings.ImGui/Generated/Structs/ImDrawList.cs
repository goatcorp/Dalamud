// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Dalamud.Bindings.ImGui
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawList
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<ImDrawCmd> CmdBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<ushort> IdxBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<ImDrawVert> VtxBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListFlags Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VtxCurrentIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawListSharedData* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* OwnerName;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawVert* VtxWritePtr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ushort* IdxWritePtr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<Vector4> ClipRectStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<ImTextureID> TextureIdStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVector<Vector2> Path;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawCmdHeader CmdHeader;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSplitter Splitter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FringeScale;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawList(ImVector<ImDrawCmd> cmdBuffer = default, ImVector<ushort> idxBuffer = default, ImVector<ImDrawVert> vtxBuffer = default, ImDrawListFlags flags = default, uint vtxCurrentIdx = default, ImDrawListSharedData* data = default, byte* ownerName = default, ImDrawVert* vtxWritePtr = default, ushort* idxWritePtr = default, ImVector<Vector4> clipRectStack = default, ImVector<ImTextureID> textureIdStack = default, ImVector<Vector2> path = default, ImDrawCmdHeader cmdHeader = default, ImDrawListSplitter splitter = default, float fringeScale = default)
		{
			CmdBuffer = cmdBuffer;
			IdxBuffer = idxBuffer;
			VtxBuffer = vtxBuffer;
			Flags = flags;
			VtxCurrentIdx = vtxCurrentIdx;
			Data = data;
			OwnerName = ownerName;
			VtxWritePtr = vtxWritePtr;
			IdxWritePtr = idxWritePtr;
			ClipRectStack = clipRectStack;
			TextureIdStack = textureIdStack;
			Path = path;
			CmdHeader = cmdHeader;
			Splitter = splitter;
			FringeScale = fringeScale;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			fixed (ImDrawList* @this = &this)
			{
				int ret = ImGui._CalcCircleAutoSegmentCountNative(@this, radius);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _ClearFreeMemory()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ClearFreeMemoryNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _OnChangedClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedClipRectNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _OnChangedTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedTextureIDNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _OnChangedVtxOffset()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedVtxOffsetNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToFastExNative(@this, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToNNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _PopUnusedDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PopUnusedDrawCmdNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _ResetForNewFrame()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ResetForNewFrameNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _TryMergeDrawCmds()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._TryMergeDrawCmdsNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCallback(ImDrawCallback callback, void* callbackData)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCallbackNative(@this, callback, callbackData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddConvexPolyFilledNative(@this, points, numPoints, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddConvexPolyFilledNative(@this, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddDrawCmdNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonFilledNative(@this, center, radius, col, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddPolylineNative(@this, points, numPoints, col, flags, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddPolylineNative(@this, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadFilledNative(@this, p1, p2, p3, p4, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, (ImDrawFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledMultiColorNative(@this, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = textBegin)
					{
						byte* pStr0 = null;
						int pStrSize0 = 0;
						if (textEnd != null)
						{
							pStrSize0 = Utils.GetByteCountUTF8(textEnd);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
							}
							else
							{
								byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
								pStr0 = pStrStack0;
							}
							int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
							pStr0[pStrOffset0] = 0;
						}
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleFilledNative(@this, p1, p2, p3, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void ChannelsMerge()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsMergeNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void ChannelsSetCurrent(int n)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSetCurrentNative(@this, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void ChannelsSplit(int count)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSplitNative(@this, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawList* CloneOutput()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImDrawList* ret = ImGui.CloneOutputNative(@this);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToFastNative(@this, center, radius, aMinOf12, aMaxOf12);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, numSegments);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathClear()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathClearNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathFillConvex(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathFillConvexNative(@this, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathLineTo(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToNative(@this, pos);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToMergeDuplicateNative(@this, pos);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, (ImDrawFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col, ImDrawFlags flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (ImDrawFlags)(0), (float)(1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col, float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (ImDrawFlags)(0), thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PopClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopClipRectNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PopTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopTextureIDNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimQuadUVNative(@this, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectNative(@this, a, b, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectUVNative(@this, a, b, uvA, uvB, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimReserveNative(@this, idxCount, vtxCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimUnreserveNative(@this, idxCount, vtxCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimVtxNative(@this, pos, uv, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimWriteIdx(ushort idx)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteIdxNative(@this, idx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteVtxNative(@this, pos, uv, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, (byte)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushClipRectFullScreen()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectFullScreenNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushTextureID(ImTextureID textureId)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushTextureIDNative(@this, textureId);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImDrawListPtr : IEquatable<ImDrawListPtr>
	{
		public ImDrawListPtr(ImDrawList* handle) { Handle = handle; }

		public ImDrawList* Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListPtr Null => new ImDrawListPtr(null);

		public ImDrawList this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImDrawListPtr(ImDrawList* handle) => new ImDrawListPtr(handle);

		public static implicit operator ImDrawList*(ImDrawListPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListPtr left, ImDrawListPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListPtr left, ImDrawListPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListPtr left, ImDrawList* right) => left.Handle == right;

		public static bool operator !=(ImDrawListPtr left, ImDrawList* right) => left.Handle != right;

		public bool Equals(ImDrawListPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImDrawListPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<ImDrawCmd> CmdBuffer => ref Unsafe.AsRef<ImVector<ImDrawCmd>>(&Handle->CmdBuffer);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<ushort> IdxBuffer => ref Unsafe.AsRef<ImVector<ushort>>(&Handle->IdxBuffer);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<ImDrawVert> VtxBuffer => ref Unsafe.AsRef<ImVector<ImDrawVert>>(&Handle->VtxBuffer);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImDrawListFlags Flags => ref Unsafe.AsRef<ImDrawListFlags>(&Handle->Flags);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref uint VtxCurrentIdx => ref Unsafe.AsRef<uint>(&Handle->VtxCurrentIdx);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImDrawListSharedDataPtr Data => ref Unsafe.AsRef<ImDrawListSharedDataPtr>(&Handle->Data);
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte* OwnerName { get => Handle->OwnerName; set => Handle->OwnerName = value; }
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImDrawVertPtr VtxWritePtr => ref Unsafe.AsRef<ImDrawVertPtr>(&Handle->VtxWritePtr);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort* IdxWritePtr { get => Handle->IdxWritePtr; set => Handle->IdxWritePtr = value; }
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<Vector4> ClipRectStack => ref Unsafe.AsRef<ImVector<Vector4>>(&Handle->ClipRectStack);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<ImTextureID> TextureIdStack => ref Unsafe.AsRef<ImVector<ImTextureID>>(&Handle->TextureIdStack);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImVector<Vector2> Path => ref Unsafe.AsRef<ImVector<Vector2>>(&Handle->Path);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImDrawCmdHeader CmdHeader => ref Unsafe.AsRef<ImDrawCmdHeader>(&Handle->CmdHeader);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref ImDrawListSplitter Splitter => ref Unsafe.AsRef<ImDrawListSplitter>(&Handle->Splitter);
		/// <summary>
		/// To be documented.
		/// </summary>
		public ref float FringeScale => ref Unsafe.AsRef<float>(&Handle->FringeScale);
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int _CalcCircleAutoSegmentCount(float radius)
		{
			int ret = ImGui._CalcCircleAutoSegmentCountNative(Handle, radius);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _ClearFreeMemory()
		{
			ImGui._ClearFreeMemoryNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _OnChangedClipRect()
		{
			ImGui._OnChangedClipRectNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _OnChangedTextureID()
		{
			ImGui._OnChangedTextureIDNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _OnChangedVtxOffset()
		{
			ImGui._OnChangedVtxOffsetNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _PathArcToFastEx(Vector2 center, float radius, int aMinSample, int aMaxSample, int aStep)
		{
			ImGui._PathArcToFastExNative(Handle, center, radius, aMinSample, aMaxSample, aStep);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _PathArcToN(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGui._PathArcToNNative(Handle, center, radius, aMin, aMax, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _PopUnusedDrawCmd()
		{
			ImGui._PopUnusedDrawCmdNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _ResetForNewFrame()
		{
			ImGui._ResetForNewFrameNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void _TryMergeDrawCmds()
		{
			ImGui._TryMergeDrawCmdsNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness, int numSegments)
		{
			ImGui.AddBezierCubicNative(Handle, p1, p2, p3, p4, col, thickness, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierCubic(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGui.AddBezierCubicNative(Handle, p1, p2, p3, p4, col, thickness, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness, int numSegments)
		{
			ImGui.AddBezierQuadraticNative(Handle, p1, p2, p3, col, thickness, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddBezierQuadratic(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGui.AddBezierQuadraticNative(Handle, p1, p2, p3, col, thickness, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCallback(ImDrawCallback callback, void* callbackData)
		{
			ImGui.AddCallbackNative(Handle, callback, callbackData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, numSegments, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, numSegments, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, (int)(0), (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircle(Vector2 center, float radius, uint col, float thickness)
		{
			ImGui.AddCircleNative(Handle, center, radius, col, (int)(0), thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddCircleFilledNative(Handle, center, radius, col, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddCircleFilled(Vector2 center, float radius, uint col)
		{
			ImGui.AddCircleFilledNative(Handle, center, radius, col, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddConvexPolyFilled(Vector2* points, int numPoints, uint col)
		{
			ImGui.AddConvexPolyFilledNative(Handle, points, numPoints, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddConvexPolyFilled(ref Vector2 points, int numPoints, uint col)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGui.AddConvexPolyFilledNative(Handle, (Vector2*)ppoints, numPoints, col);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddDrawCmd()
		{
			ImGui.AddDrawCmdNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImage(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddImageNative(Handle, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector2 uv4)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, Vector2 uv3, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, Vector2 uv2, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 uv1, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageQuad(ImTextureID userTextureId, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddImageQuadNative(Handle, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddImageRoundedNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddImageRounded(ImTextureID userTextureId, Vector2 pMin, Vector2 pMax, Vector2 uvMin, Vector2 uvMax, uint col, float rounding)
		{
			ImGui.AddImageRoundedNative(Handle, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (ImDrawFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col, float thickness)
		{
			ImGui.AddLineNative(Handle, p1, p2, col, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddLine(Vector2 p1, Vector2 p2, uint col)
		{
			ImGui.AddLineNative(Handle, p1, p2, col, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments, float thickness)
		{
			ImGui.AddNgonNative(Handle, center, radius, col, numSegments, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddNgon(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddNgonNative(Handle, center, radius, col, numSegments, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddNgonFilled(Vector2 center, float radius, uint col, int numSegments)
		{
			ImGui.AddNgonFilledNative(Handle, center, radius, col, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddPolyline(Vector2* points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.AddPolylineNative(Handle, points, numPoints, col, flags, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddPolyline(ref Vector2 points, int numPoints, uint col, ImDrawFlags flags, float thickness)
		{
			fixed (Vector2* ppoints = &points)
			{
				ImGui.AddPolylineNative(Handle, (Vector2*)ppoints, numPoints, col, flags, thickness);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col, float thickness)
		{
			ImGui.AddQuadNative(Handle, p1, p2, p3, p4, col, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddQuad(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddQuadNative(Handle, p1, p2, p3, p4, col, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddQuadFilled(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, uint col)
		{
			ImGui.AddQuadFilledNative(Handle, p1, p2, p3, p4, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, flags, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, flags, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0), (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0), (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, float rounding, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0), thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRect(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.AddRectNative(Handle, pMin, pMax, col, (float)(0.0f), flags, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding, ImDrawFlags flags)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, rounding, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, float rounding)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, rounding, (ImDrawFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, (float)(0.0f), (ImDrawFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilled(Vector2 pMin, Vector2 pMax, uint col, ImDrawFlags flags)
		{
			ImGui.AddRectFilledNative(Handle, pMin, pMax, col, (float)(0.0f), flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddRectFilledMultiColor(Vector2 pMin, Vector2 pMax, uint colUprLeft, uint colUprRight, uint colBotRight, uint colBotLeft)
		{
			ImGui.AddRectFilledMultiColorNative(Handle, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, pos, col, textBegin, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin)
		{
			ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, pos, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, pos, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, pos, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, pos, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, pos, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, Vector4* cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, byte* textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, byte* textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
			{
				ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ImFont* font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, font, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ref byte textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ref byte textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, float wrapWidth, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddText(ref ImFont font, float fontSize, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd, ref Vector4 cpuFineClipRect)
		{
			fixed (ImFont* pfont = &font)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(Handle, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col, float thickness)
		{
			ImGui.AddTriangleNative(Handle, p1, p2, p3, col, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddTriangle(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGui.AddTriangleNative(Handle, p1, p2, p3, col, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddTriangleFilled(Vector2 p1, Vector2 p2, Vector2 p3, uint col)
		{
			ImGui.AddTriangleFilledNative(Handle, p1, p2, p3, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void ChannelsMerge()
		{
			ImGui.ChannelsMergeNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void ChannelsSetCurrent(int n)
		{
			ImGui.ChannelsSetCurrentNative(Handle, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void ChannelsSplit(int count)
		{
			ImGui.ChannelsSplitNative(Handle, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawListPtr CloneOutput()
		{
			ImDrawListPtr ret = ImGui.CloneOutputNative(Handle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			ImGui.DestroyNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax, int numSegments)
		{
			ImGui.PathArcToNative(Handle, center, radius, aMin, aMax, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathArcTo(Vector2 center, float radius, float aMin, float aMax)
		{
			ImGui.PathArcToNative(Handle, center, radius, aMin, aMax, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathArcToFast(Vector2 center, float radius, int aMinOf12, int aMaxOf12)
		{
			ImGui.PathArcToFastNative(Handle, center, radius, aMinOf12, aMaxOf12);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4, int numSegments)
		{
			ImGui.PathBezierCubicCurveToNative(Handle, p2, p3, p4, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierCubicCurveTo(Vector2 p2, Vector2 p3, Vector2 p4)
		{
			ImGui.PathBezierCubicCurveToNative(Handle, p2, p3, p4, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3, int numSegments)
		{
			ImGui.PathBezierQuadraticCurveToNative(Handle, p2, p3, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathBezierQuadraticCurveTo(Vector2 p2, Vector2 p3)
		{
			ImGui.PathBezierQuadraticCurveToNative(Handle, p2, p3, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathClear()
		{
			ImGui.PathClearNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathFillConvex(uint col)
		{
			ImGui.PathFillConvexNative(Handle, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathLineTo(Vector2 pos)
		{
			ImGui.PathLineToNative(Handle, pos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathLineToMergeDuplicate(Vector2 pos)
		{
			ImGui.PathLineToMergeDuplicateNative(Handle, pos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding, ImDrawFlags flags)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, rounding, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, float rounding)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, rounding, (ImDrawFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, (float)(0.0f), (ImDrawFlags)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathRect(Vector2 rectMin, Vector2 rectMax, ImDrawFlags flags)
		{
			ImGui.PathRectNative(Handle, rectMin, rectMax, (float)(0.0f), flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col, ImDrawFlags flags, float thickness)
		{
			ImGui.PathStrokeNative(Handle, col, flags, thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col, ImDrawFlags flags)
		{
			ImGui.PathStrokeNative(Handle, col, flags, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col)
		{
			ImGui.PathStrokeNative(Handle, col, (ImDrawFlags)(0), (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PathStroke(uint col, float thickness)
		{
			ImGui.PathStrokeNative(Handle, col, (ImDrawFlags)(0), thickness);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PopClipRect()
		{
			ImGui.PopClipRectNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PopTextureID()
		{
			ImGui.PopTextureIDNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimQuadUV(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Vector2 uvA, Vector2 uvB, Vector2 uvC, Vector2 uvD, uint col)
		{
			ImGui.PrimQuadUVNative(Handle, a, b, c, d, uvA, uvB, uvC, uvD, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimRect(Vector2 a, Vector2 b, uint col)
		{
			ImGui.PrimRectNative(Handle, a, b, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimRectUV(Vector2 a, Vector2 b, Vector2 uvA, Vector2 uvB, uint col)
		{
			ImGui.PrimRectUVNative(Handle, a, b, uvA, uvB, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimReserve(int idxCount, int vtxCount)
		{
			ImGui.PrimReserveNative(Handle, idxCount, vtxCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimUnreserve(int idxCount, int vtxCount)
		{
			ImGui.PrimUnreserveNative(Handle, idxCount, vtxCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimVtx(Vector2 pos, Vector2 uv, uint col)
		{
			ImGui.PrimVtxNative(Handle, pos, uv, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimWriteIdx(ushort idx)
		{
			ImGui.PrimWriteIdxNative(Handle, idx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PrimWriteVtx(Vector2 pos, Vector2 uv, uint col)
		{
			ImGui.PrimWriteVtxNative(Handle, pos, uv, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax, bool intersectWithCurrentClipRect)
		{
			ImGui.PushClipRectNative(Handle, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushClipRect(Vector2 clipRectMin, Vector2 clipRectMax)
		{
			ImGui.PushClipRectNative(Handle, clipRectMin, clipRectMax, (byte)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushClipRectFullScreen()
		{
			ImGui.PushClipRectFullScreenNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void PushTextureID(ImTextureID textureId)
		{
			ImGui.PushTextureIDNative(Handle, textureId);
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImDrawListPtrPtr : IEquatable<ImDrawListPtrPtr>
	{
		public ImDrawListPtrPtr(ImDrawList** handle) { Handle = handle; }

		public ImDrawList** Handle;

		public bool IsNull => Handle == null;

		public static ImDrawListPtrPtr Null => new ImDrawListPtrPtr(null);

		public ImDrawList* this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImDrawListPtrPtr(ImDrawList** handle) => new ImDrawListPtrPtr(handle);

		public static implicit operator ImDrawList**(ImDrawListPtrPtr handle) => handle.Handle;

		public static bool operator ==(ImDrawListPtrPtr left, ImDrawListPtrPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImDrawListPtrPtr left, ImDrawListPtrPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImDrawListPtrPtr left, ImDrawList** right) => left.Handle == right;

		public static bool operator !=(ImDrawListPtrPtr left, ImDrawList** right) => left.Handle != right;

		public bool Equals(ImDrawListPtrPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImDrawListPtrPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImDrawListPtrPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
	}

}
