// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Dalamud.Bindings.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipWithNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)funcTable[796])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[796])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWith(ImRectPtr self, ImRect r)
		{
			ClipWithNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWith(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ClipWithNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipWithFullNative(ImRect* self, ImRect r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImRect, void>)funcTable[797])(self, r);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImRect, void>)funcTable[797])((nint)self, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWithFull(ImRectPtr self, ImRect r)
		{
			ClipWithFullNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClipWithFull(ref ImRect self, ImRect r)
		{
			fixed (ImRect* pself = &self)
			{
				ClipWithFullNative((ImRect*)pself, r);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FloorNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, void>)funcTable[798])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[798])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Floor(ImRectPtr self)
		{
			FloorNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Floor(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				FloorNative((ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsInvertedNative(ImRect* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImRect*, byte>)funcTable[799])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[799])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ImRectPtr self)
		{
			byte ret = IsInvertedNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsInverted(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				byte ret = IsInvertedNative((ImRect*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ToVec4Native(Vector4* pOut, ImRect* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, ImRect*, void>)funcTable[800])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[800])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ToVec4(ImRectPtr self)
		{
			Vector4 ret;
			ToVec4Native(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(Vector4* pOut, ImRectPtr self)
		{
			ToVec4Native(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(ref Vector4 pOut, ImRectPtr self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ToVec4Native((Vector4*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ToVec4(ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				Vector4 ret;
				ToVec4Native(&ret, (ImRect*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(Vector4* pOut, ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ToVec4Native(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ToVec4(ref Vector4 pOut, ref ImRect self)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				fixed (ImRect* pself = &self)
				{
					ToVec4Native((Vector4*)ppOut, (ImRect*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImBitArrayTestBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, int, byte>)funcTable[801])(arr, n);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[801])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImBitArrayTestBit(uint* arr, int n)
		{
			byte ret = ImBitArrayTestBitNative(arr, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArrayClearBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)funcTable[802])(arr, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[802])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArrayClearBit(uint* arr, int n)
		{
			ImBitArrayClearBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArraySetBitNative(uint* arr, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, void>)funcTable[803])(arr, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[803])((nint)arr, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBit(uint* arr, int n)
		{
			ImBitArraySetBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImBitArraySetBitRangeNative(uint* arr, int n, int n2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, int, void>)funcTable[804])(arr, n, n2);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[804])((nint)arr, n, n2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImBitArraySetBitRange(uint* arr, int n, int n2)
		{
			ImBitArraySetBitRangeNative(arr, n, n2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateNative(ImBitVector* self, int sz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)funcTable[805])(self, sz);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[805])((nint)self, sz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Create(ImBitVectorPtr self, int sz)
		{
			CreateNative(self, sz);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Create(ref ImBitVector self, int sz)
		{
			fixed (ImBitVector* pself = &self)
			{
				CreateNative((ImBitVector*)pself, sz);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImBitVector* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, void>)funcTable[806])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[806])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImBitVectorPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImBitVector self)
		{
			fixed (ImBitVector* pself = &self)
			{
				ClearNative((ImBitVector*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImBitVector*, int, byte>)funcTable[807])(self, n);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, int, byte>)funcTable[807])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestBit(ImBitVectorPtr self, int n)
		{
			byte ret = TestBitNative(self, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TestBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				byte ret = TestBitNative((ImBitVector*)pself, n);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)funcTable[808])(self, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[808])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBit(ImBitVectorPtr self, int n)
		{
			SetBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				SetBitNative((ImBitVector*)pself, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBitNative(ImBitVector* self, int n)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImBitVector*, int, void>)funcTable[809])(self, n);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[809])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearBit(ImBitVectorPtr self, int n)
		{
			ClearBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearBit(ref ImBitVector self, int n)
		{
			fixed (ImBitVector* pself = &self)
			{
				ClearBitNative((ImBitVector*)pself, n);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImDrawListSharedData* ImDrawListSharedDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawListSharedData*>)funcTable[810])();
			#else
			return (ImDrawListSharedData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[810])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImDrawListSharedDataPtr ImDrawListSharedData()
		{
			ImDrawListSharedDataPtr ret = ImDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetCircleTessellationMaxErrorNative(ImDrawListSharedData* self, float maxError)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawListSharedData*, float, void>)funcTable[811])(self, maxError);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[811])((nint)self, maxError);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCircleTessellationMaxError(ImDrawListSharedDataPtr self, float maxError)
		{
			SetCircleTessellationMaxErrorNative(self, maxError);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetCircleTessellationMaxError(ref ImDrawListSharedData self, float maxError)
		{
			fixed (ImDrawListSharedData* pself = &self)
			{
				SetCircleTessellationMaxErrorNative((ImDrawListSharedData*)pself, maxError);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImDrawDataBuilder* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*, void>)funcTable[812])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[812])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImDrawDataBuilderPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ClearNative((ImDrawDataBuilder*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFreeMemoryNative(ImDrawDataBuilder* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*, void>)funcTable[813])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[813])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ImDrawDataBuilderPtr self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				ClearFreeMemoryNative((ImDrawDataBuilder*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDrawListCountNative(ImDrawDataBuilder* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*, int>)funcTable[814])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[814])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDrawListCount(ImDrawDataBuilderPtr self)
		{
			int ret = GetDrawListCountNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDrawListCount(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				int ret = GetDrawListCountNative((ImDrawDataBuilder*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlattenIntoSingleLayerNative(ImDrawDataBuilder* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawDataBuilder*, void>)funcTable[815])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[815])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FlattenIntoSingleLayer(ImDrawDataBuilderPtr self)
		{
			FlattenIntoSingleLayerNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FlattenIntoSingleLayer(ref ImDrawDataBuilder self)
		{
			fixed (ImDrawDataBuilder* pself = &self)
			{
				FlattenIntoSingleLayerNative((ImDrawDataBuilder*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, int v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, ImGuiStyleMod*>)funcTable[816])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, int, nint>)funcTable[816])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, int v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, float v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, ImGuiStyleMod*>)funcTable[817])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, float, nint>)funcTable[817])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, float v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyleMod* ImGuiStyleModNative(ImGuiStyleVar idx, Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, ImGuiStyleMod*>)funcTable[818])(idx, v);
			#else
			return (ImGuiStyleMod*)((delegate* unmanaged[Cdecl]<ImGuiStyleVar, Vector2, nint>)funcTable[818])(idx, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStyleModPtr ImGuiStyleMod(ImGuiStyleVar idx, Vector2 v)
		{
			ImGuiStyleModPtr ret = ImGuiStyleModNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiComboPreviewData* ImGuiComboPreviewDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiComboPreviewData*>)funcTable[819])();
			#else
			return (ImGuiComboPreviewData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[819])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiComboPreviewDataPtr ImGuiComboPreviewData()
		{
			ImGuiComboPreviewDataPtr ret = ImGuiComboPreviewDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMenuColumns* ImGuiMenuColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*>)funcTable[820])();
			#else
			return (ImGuiMenuColumns*)((delegate* unmanaged[Cdecl]<nint>)funcTable[820])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMenuColumnsPtr ImGuiMenuColumns()
		{
			ImGuiMenuColumnsPtr ret = ImGuiMenuColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateNative(ImGuiMenuColumns* self, float spacing, byte windowReappearing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, byte, void>)funcTable[821])(self, spacing, windowReappearing);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, byte, void>)funcTable[821])((nint)self, spacing, windowReappearing);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ImGuiMenuColumnsPtr self, float spacing, bool windowReappearing)
		{
			UpdateNative(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Update(ref ImGuiMenuColumns self, float spacing, bool windowReappearing)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				UpdateNative((ImGuiMenuColumns*)pself, spacing, windowReappearing ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DeclColumnsNative(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, float, float, float, float, float>)funcTable[822])(self, wIcon, wLabel, wShortcut, wMark);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float, float, float, float, float>)funcTable[822])((nint)self, wIcon, wLabel, wShortcut, wMark);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float DeclColumns(ImGuiMenuColumnsPtr self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			float ret = DeclColumnsNative(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float DeclColumns(ref ImGuiMenuColumns self, float wIcon, float wLabel, float wShortcut, float wMark)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				float ret = DeclColumnsNative((ImGuiMenuColumns*)pself, wIcon, wLabel, wShortcut, wMark);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcNextTotalWidthNative(ImGuiMenuColumns* self, byte updateOffsets)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMenuColumns*, byte, void>)funcTable[823])(self, updateOffsets);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[823])((nint)self, updateOffsets);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcNextTotalWidth(ImGuiMenuColumnsPtr self, bool updateOffsets)
		{
			CalcNextTotalWidthNative(self, updateOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcNextTotalWidth(ref ImGuiMenuColumns self, bool updateOffsets)
		{
			fixed (ImGuiMenuColumns* pself = &self)
			{
				CalcNextTotalWidthNative((ImGuiMenuColumns*)pself, updateOffsets ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiInputTextState* ImGuiInputTextStateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*>)funcTable[824])();
			#else
			return (ImGuiInputTextState*)((delegate* unmanaged[Cdecl]<nint>)funcTable[824])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextStatePtr ImGuiInputTextState()
		{
			ImGuiInputTextStatePtr ret = ImGuiInputTextStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTextNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[825])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[825])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearText(ImGuiInputTextStatePtr self)
		{
			ClearTextNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearText(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearTextNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFreeMemoryNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[826])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[826])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ImGuiInputTextStatePtr self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFreeMemory(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearFreeMemoryNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUndoAvailCountNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[827])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[827])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetUndoAvailCount(ImGuiInputTextStatePtr self)
		{
			int ret = GetUndoAvailCountNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetUndoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetUndoAvailCountNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetRedoAvailCountNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[828])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[828])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetRedoAvailCount(ImGuiInputTextStatePtr self)
		{
			int ret = GetRedoAvailCountNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetRedoAvailCount(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetRedoAvailCountNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OnKeyPressedNative(ImGuiInputTextState* self, int key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int, void>)funcTable[829])(self, key);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[829])((nint)self, key);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnKeyPressed(ImGuiInputTextStatePtr self, int key)
		{
			OnKeyPressedNative(self, key);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void OnKeyPressed(ref ImGuiInputTextState self, int key)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				OnKeyPressedNative((ImGuiInputTextState*)pself, key);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CursorAnimResetNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[830])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[830])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorAnimReset(ImGuiInputTextStatePtr self)
		{
			CursorAnimResetNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorAnimReset(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				CursorAnimResetNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CursorClampNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[831])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[831])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorClamp(ImGuiInputTextStatePtr self)
		{
			CursorClampNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CursorClamp(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				CursorClampNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte HasSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, byte>)funcTable[832])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[832])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasSelection(ImGuiInputTextStatePtr self)
		{
			byte ret = HasSelectionNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				byte ret = HasSelectionNative((ImGuiInputTextState*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearSelectionNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[833])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[833])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearSelection(ImGuiInputTextStatePtr self)
		{
			ClearSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearSelection(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				ClearSelectionNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCursorPosNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[834])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[834])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetCursorPos(ImGuiInputTextStatePtr self)
		{
			int ret = GetCursorPosNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetCursorPos(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetCursorPosNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSelectionStartNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[835])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[835])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionStart(ImGuiInputTextStatePtr self)
		{
			int ret = GetSelectionStartNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionStart(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetSelectionStartNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSelectionEndNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, int>)funcTable[836])(self);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[836])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionEnd(ImGuiInputTextStatePtr self)
		{
			int ret = GetSelectionEndNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetSelectionEnd(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				int ret = GetSelectionEndNative((ImGuiInputTextState*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SelectAllNative(ImGuiInputTextState* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextState*, void>)funcTable[837])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[837])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SelectAll(ImGuiInputTextStatePtr self)
		{
			SelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SelectAll(ref ImGuiInputTextState self)
		{
			fixed (ImGuiInputTextState* pself = &self)
			{
				SelectAllNative((ImGuiInputTextState*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPopupData* ImGuiPopupDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPopupData*>)funcTable[838])();
			#else
			return (ImGuiPopupData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[838])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPopupDataPtr ImGuiPopupData()
		{
			ImGuiPopupDataPtr ret = ImGuiPopupDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiNextWindowData* ImGuiNextWindowDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*>)funcTable[839])();
			#else
			return (ImGuiNextWindowData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[839])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextWindowDataPtr ImGuiNextWindowData()
		{
			ImGuiNextWindowDataPtr ret = ImGuiNextWindowDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFlagsNative(ImGuiNextWindowData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextWindowData*, void>)funcTable[840])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[840])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ImGuiNextWindowDataPtr self)
		{
			ClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ref ImGuiNextWindowData self)
		{
			fixed (ImGuiNextWindowData* pself = &self)
			{
				ClearFlagsNative((ImGuiNextWindowData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiNextItemData* ImGuiNextItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNextItemData*>)funcTable[841])();
			#else
			return (ImGuiNextItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[841])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNextItemDataPtr ImGuiNextItemData()
		{
			ImGuiNextItemDataPtr ret = ImGuiNextItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearFlagsNative(ImGuiNextItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNextItemData*, void>)funcTable[842])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[842])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ImGuiNextItemDataPtr self)
		{
			ClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearFlags(ref ImGuiNextItemData self)
		{
			fixed (ImGuiNextItemData* pself = &self)
			{
				ClearFlagsNative((ImGuiNextItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiLastItemData* ImGuiLastItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiLastItemData*>)funcTable[843])();
			#else
			return (ImGuiLastItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[843])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiLastItemDataPtr ImGuiLastItemData()
		{
			ImGuiLastItemDataPtr ret = ImGuiLastItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStackSizes* ImGuiStackSizesNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackSizes*>)funcTable[844])();
			#else
			return (ImGuiStackSizes*)((delegate* unmanaged[Cdecl]<nint>)funcTable[844])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackSizesPtr ImGuiStackSizes()
		{
			ImGuiStackSizesPtr ret = ImGuiStackSizesNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetToCurrentStateNative(ImGuiStackSizes* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, void>)funcTable[845])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[845])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetToCurrentState(ImGuiStackSizesPtr self)
		{
			SetToCurrentStateNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetToCurrentState(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				SetToCurrentStateNative((ImGuiStackSizes*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompareWithCurrentStateNative(ImGuiStackSizes* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStackSizes*, void>)funcTable[846])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[846])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompareWithCurrentState(ImGuiStackSizesPtr self)
		{
			CompareWithCurrentStateNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompareWithCurrentState(ref ImGuiStackSizes self)
		{
			fixed (ImGuiStackSizes* pself = &self)
			{
				CompareWithCurrentStateNative((ImGuiStackSizes*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPtrOrIndex* ImGuiPtrOrIndexNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiPtrOrIndex*>)funcTable[847])(ptr);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[847])((nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(void* ptr)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexNative(ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiPtrOrIndex* ImGuiPtrOrIndexNative(int index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiPtrOrIndex*>)funcTable[848])(index);
			#else
			return (ImGuiPtrOrIndex*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[848])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiPtrOrIndexPtr ImGuiPtrOrIndex(int index)
		{
			ImGuiPtrOrIndexPtr ret = ImGuiPtrOrIndexNative(index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiInputEvent* ImGuiInputEventNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputEvent*>)funcTable[849])();
			#else
			return (ImGuiInputEvent*)((delegate* unmanaged[Cdecl]<nint>)funcTable[849])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputEventPtr ImGuiInputEvent()
		{
			ImGuiInputEventPtr ret = ImGuiInputEventNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiListClipperRange FromIndicesNative(int min, int max)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)funcTable[850])(min, max);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<int, int, ImGuiListClipperRange>)funcTable[850])(min, max);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperRange FromIndices(int min, int max)
		{
			ImGuiListClipperRange ret = FromIndicesNative(min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiListClipperRange FromPositionsNative(float y1, float y2, int offMin, int offMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, int, int, ImGuiListClipperRange>)funcTable[851])(y1, y2, offMin, offMax);
			#else
			return (ImGuiListClipperRange)((delegate* unmanaged[Cdecl]<float, float, int, int, ImGuiListClipperRange>)funcTable[851])(y1, y2, offMin, offMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperRange FromPositions(float y1, float y2, int offMin, int offMax)
		{
			ImGuiListClipperRange ret = FromPositionsNative(y1, y2, offMin, offMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiListClipperData* ImGuiListClipperDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiListClipperData*>)funcTable[852])();
			#else
			return (ImGuiListClipperData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[852])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiListClipperDataPtr ImGuiListClipperData()
		{
			ImGuiListClipperDataPtr ret = ImGuiListClipperDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetNative(ImGuiListClipperData* self, ImGuiListClipper* clipper)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiListClipperData*, ImGuiListClipper*, void>)funcTable[853])(self, clipper);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[853])((nint)self, (nint)clipper);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImGuiListClipperDataPtr self, ImGuiListClipperPtr clipper)
		{
			ResetNative(self, clipper);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImGuiListClipperData self, ImGuiListClipperPtr clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				ResetNative((ImGuiListClipperData*)pself, clipper);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ImGuiListClipperDataPtr self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipper* pclipper = &clipper)
			{
				ResetNative(self, (ImGuiListClipper*)pclipper);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Reset(ref ImGuiListClipperData self, ref ImGuiListClipper clipper)
		{
			fixed (ImGuiListClipperData* pself = &self)
			{
				fixed (ImGuiListClipper* pclipper = &clipper)
				{
					ResetNative((ImGuiListClipperData*)pself, (ImGuiListClipper*)pclipper);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiNavItemData* ImGuiNavItemDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiNavItemData*>)funcTable[854])();
			#else
			return (ImGuiNavItemData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[854])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiNavItemDataPtr ImGuiNavItemData()
		{
			ImGuiNavItemDataPtr ret = ImGuiNavItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(ImGuiNavItemData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiNavItemData*, void>)funcTable[855])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[855])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ImGuiNavItemDataPtr self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Clear(ref ImGuiNavItemData self)
		{
			fixed (ImGuiNavItemData* pself = &self)
			{
				ClearNative((ImGuiNavItemData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiOldColumnData* ImGuiOldColumnDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumnData*>)funcTable[856])();
			#else
			return (ImGuiOldColumnData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[856])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnDataPtr ImGuiOldColumnData()
		{
			ImGuiOldColumnDataPtr ret = ImGuiOldColumnDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiOldColumns* ImGuiOldColumnsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiOldColumns*>)funcTable[857])();
			#else
			return (ImGuiOldColumns*)((delegate* unmanaged[Cdecl]<nint>)funcTable[857])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiOldColumnsPtr ImGuiOldColumns()
		{
			ImGuiOldColumnsPtr ret = ImGuiOldColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockNode* ImGuiDockNodeNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiDockNode*>)funcTable[858])(id);
			#else
			return (ImGuiDockNode*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[858])(id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockNodePtr ImGuiDockNode(uint id)
		{
			ImGuiDockNodePtr ret = ImGuiDockNodeNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)funcTable[859])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[859])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiDockNodePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				DestroyNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRootNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[860])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[860])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRootNode(ImGuiDockNodePtr self)
		{
			byte ret = IsRootNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsRootNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsRootNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsDockSpaceNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[861])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[861])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDockSpace(ImGuiDockNodePtr self)
		{
			byte ret = IsDockSpaceNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsDockSpace(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsDockSpaceNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFloatingNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[862])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[862])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsFloatingNode(ImGuiDockNodePtr self)
		{
			byte ret = IsFloatingNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsFloatingNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsFloatingNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCentralNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[863])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[863])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsCentralNode(ImGuiDockNodePtr self)
		{
			byte ret = IsCentralNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsCentralNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsCentralNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsHiddenTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[864])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[864])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsHiddenTabBar(ImGuiDockNodePtr self)
		{
			byte ret = IsHiddenTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsHiddenTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsHiddenTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsNoTabBarNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[865])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[865])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsNoTabBar(ImGuiDockNodePtr self)
		{
			byte ret = IsNoTabBarNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsNoTabBar(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsNoTabBarNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSplitNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[866])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[866])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsSplitNode(ImGuiDockNodePtr self)
		{
			byte ret = IsSplitNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsSplitNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsSplitNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLeafNodeNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[867])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[867])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeafNode(ImGuiDockNodePtr self)
		{
			byte ret = IsLeafNodeNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeafNode(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsLeafNodeNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEmptyNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockNode*, byte>)funcTable[868])(self);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[868])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsEmpty(ImGuiDockNodePtr self)
		{
			byte ret = IsEmptyNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsEmpty(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				byte ret = IsEmptyNative((ImGuiDockNode*)pself);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectNative(ImRect* pOut, ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiDockNode*, void>)funcTable[869])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[869])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ImGuiDockNodePtr self)
		{
			ImRect ret;
			RectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ImGuiDockNodePtr self)
		{
			RectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ImGuiDockNodePtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				RectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				ImRect ret;
				RectNative(&ret, (ImGuiDockNode*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				RectNative(pOut, (ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ref ImGuiDockNode self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiDockNode* pself = &self)
				{
					RectNative((ImRect*)ppOut, (ImGuiDockNode*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLocalFlagsNative(ImGuiDockNode* self, ImGuiDockNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, ImGuiDockNodeFlags, void>)funcTable[870])(self, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiDockNodeFlags, void>)funcTable[870])((nint)self, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLocalFlags(ImGuiDockNodePtr self, ImGuiDockNodeFlags flags)
		{
			SetLocalFlagsNative(self, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetLocalFlags(ref ImGuiDockNode self, ImGuiDockNodeFlags flags)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				SetLocalFlagsNative((ImGuiDockNode*)pself, flags);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateMergedFlagsNative(ImGuiDockNode* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiDockNode*, void>)funcTable[871])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[871])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMergedFlags(ImGuiDockNodePtr self)
		{
			UpdateMergedFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateMergedFlags(ref ImGuiDockNode self)
		{
			fixed (ImGuiDockNode* pself = &self)
			{
				UpdateMergedFlagsNative((ImGuiDockNode*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiDockContext* ImGuiDockContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiDockContext*>)funcTable[872])();
			#else
			return (ImGuiDockContext*)((delegate* unmanaged[Cdecl]<nint>)funcTable[872])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiDockContextPtr ImGuiDockContext()
		{
			ImGuiDockContextPtr ret = ImGuiDockContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiViewportP* ImGuiViewportPNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewportP*>)funcTable[873])();
			#else
			return (ImGuiViewportP*)((delegate* unmanaged[Cdecl]<nint>)funcTable[873])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiViewportPPtr ImGuiViewportP()
		{
			ImGuiViewportPPtr ret = ImGuiViewportPNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[874])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[874])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiViewportPPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				DestroyNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearRequestFlagsNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[875])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[875])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearRequestFlags(ImGuiViewportPPtr self)
		{
			ClearRequestFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClearRequestFlags(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ClearRequestFlagsNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcWorkRectPosNative(Vector2* pOut, ImGuiViewportP* self, Vector2 offMin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, void>)funcTable[876])(pOut, self, offMin);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, void>)funcTable[876])((nint)pOut, (nint)self, offMin);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectPos(ImGuiViewportPPtr self, Vector2 offMin)
		{
			Vector2 ret;
			CalcWorkRectPosNative(&ret, self, offMin);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(Vector2* pOut, ImGuiViewportPPtr self, Vector2 offMin)
		{
			CalcWorkRectPosNative(pOut, self, offMin);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 offMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWorkRectPosNative((Vector2*)ppOut, self, offMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectPos(ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				CalcWorkRectPosNative(&ret, (ImGuiViewportP*)pself, offMin);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(Vector2* pOut, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				CalcWorkRectPosNative(pOut, (ImGuiViewportP*)pself, offMin);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectPos(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 offMin)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					CalcWorkRectPosNative((Vector2*)ppOut, (ImGuiViewportP*)pself, offMin);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcWorkRectSizeNative(Vector2* pOut, ImGuiViewportP* self, Vector2 offMin, Vector2 offMax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiViewportP*, Vector2, Vector2, void>)funcTable[877])(pOut, self, offMin, offMax);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, Vector2, Vector2, void>)funcTable[877])((nint)pOut, (nint)self, offMin, offMax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectSize(ImGuiViewportPPtr self, Vector2 offMin, Vector2 offMax)
		{
			Vector2 ret;
			CalcWorkRectSizeNative(&ret, self, offMin, offMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(Vector2* pOut, ImGuiViewportPPtr self, Vector2 offMin, Vector2 offMax)
		{
			CalcWorkRectSizeNative(pOut, self, offMin, offMax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(ref Vector2 pOut, ImGuiViewportPPtr self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcWorkRectSizeNative((Vector2*)ppOut, self, offMin, offMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcWorkRectSize(ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				Vector2 ret;
				CalcWorkRectSizeNative(&ret, (ImGuiViewportP*)pself, offMin, offMax);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(Vector2* pOut, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				CalcWorkRectSizeNative(pOut, (ImGuiViewportP*)pself, offMin, offMax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcWorkRectSize(ref Vector2 pOut, ref ImGuiViewportP self, Vector2 offMin, Vector2 offMax)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					CalcWorkRectSizeNative((Vector2*)ppOut, (ImGuiViewportP*)pself, offMin, offMax);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdateWorkRectNative(ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiViewportP*, void>)funcTable[878])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[878])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWorkRect(ImGuiViewportPPtr self)
		{
			UpdateWorkRectNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				UpdateWorkRectNative((ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMainRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)funcTable[879])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[879])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetMainRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetMainRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetMainRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetMainRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetMainRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetMainRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetMainRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetMainRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetMainRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)funcTable[880])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[880])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBuildWorkRectNative(ImRect* pOut, ImGuiViewportP* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiViewportP*, void>)funcTable[881])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[881])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetBuildWorkRect(ImGuiViewportPPtr self)
		{
			ImRect ret;
			GetBuildWorkRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ImRectPtr pOut, ImGuiViewportPPtr self)
		{
			GetBuildWorkRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ref ImRect pOut, ImGuiViewportPPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				GetBuildWorkRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect GetBuildWorkRect(ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				ImRect ret;
				GetBuildWorkRectNative(&ret, (ImGuiViewportP*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ImRectPtr pOut, ref ImGuiViewportP self)
		{
			fixed (ImGuiViewportP* pself = &self)
			{
				GetBuildWorkRectNative(pOut, (ImGuiViewportP*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetBuildWorkRect(ref ImRect pOut, ref ImGuiViewportP self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiViewportP* pself = &self)
				{
					GetBuildWorkRectNative((ImRect*)ppOut, (ImGuiViewportP*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindowSettings* ImGuiWindowSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*>)funcTable[882])();
			#else
			return (ImGuiWindowSettings*)((delegate* unmanaged[Cdecl]<nint>)funcTable[882])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowSettingsPtr ImGuiWindowSettings()
		{
			ImGuiWindowSettingsPtr ret = ImGuiWindowSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetNameNative(ImGuiWindowSettings* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindowSettings*, byte*>)funcTable[883])(self);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[883])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ImGuiWindowSettingsPtr self)
		{
			byte* ret = GetNameNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ImGuiWindowSettingsPtr self)
		{
			string ret = Utils.DecodeStringUTF8(GetNameNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				byte* ret = GetNameNative((ImGuiWindowSettings*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(ref ImGuiWindowSettings self)
		{
			fixed (ImGuiWindowSettings* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetNameNative((ImGuiWindowSettings*)pself));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiSettingsHandler* ImGuiSettingsHandlerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiSettingsHandler*>)funcTable[884])();
			#else
			return (ImGuiSettingsHandler*)((delegate* unmanaged[Cdecl]<nint>)funcTable[884])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiSettingsHandlerPtr ImGuiSettingsHandler()
		{
			ImGuiSettingsHandlerPtr ret = ImGuiSettingsHandlerNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMetricsConfig* ImGuiMetricsConfigNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMetricsConfig*>)funcTable[885])();
			#else
			return (ImGuiMetricsConfig*)((delegate* unmanaged[Cdecl]<nint>)funcTable[885])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiMetricsConfigPtr ImGuiMetricsConfig()
		{
			ImGuiMetricsConfigPtr ret = ImGuiMetricsConfigNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStackLevelInfo* ImGuiStackLevelInfoNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackLevelInfo*>)funcTable[886])();
			#else
			return (ImGuiStackLevelInfo*)((delegate* unmanaged[Cdecl]<nint>)funcTable[886])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackLevelInfoPtr ImGuiStackLevelInfo()
		{
			ImGuiStackLevelInfoPtr ret = ImGuiStackLevelInfoNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStackTool* ImGuiStackToolNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStackTool*>)funcTable[887])();
			#else
			return (ImGuiStackTool*)((delegate* unmanaged[Cdecl]<nint>)funcTable[887])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStackToolPtr ImGuiStackTool()
		{
			ImGuiStackToolPtr ret = ImGuiStackToolNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContextHook* ImGuiContextHookNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContextHook*>)funcTable[888])();
			#else
			return (ImGuiContextHook*)((delegate* unmanaged[Cdecl]<nint>)funcTable[888])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextHookPtr ImGuiContextHook()
		{
			ImGuiContextHookPtr ret = ImGuiContextHookNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiContext* ImGuiContextNative(ImFontAtlas* sharedFontAtlas)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFontAtlas*, ImGuiContext*>)funcTable[889])(sharedFontAtlas);
			#else
			return (ImGuiContext*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[889])((nint)sharedFontAtlas);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr ImGuiContext(ImFontAtlasPtr sharedFontAtlas)
		{
			ImGuiContextPtr ret = ImGuiContextNative(sharedFontAtlas);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiContextPtr ImGuiContext(ref ImFontAtlas sharedFontAtlas)
		{
			fixed (ImFontAtlas* psharedFontAtlas = &sharedFontAtlas)
			{
				ImGuiContextPtr ret = ImGuiContextNative((ImFontAtlas*)psharedFontAtlas);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiWindow* ImGuiWindowNative(ImGuiContext* context, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiContext*, byte*, ImGuiWindow*>)funcTable[890])(context, name);
			#else
			return (ImGuiWindow*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[890])((nint)context, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, byte* name)
		{
			ImGuiWindowPtr ret = ImGuiWindowNative(context, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, byte* name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, name);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, ref byte name)
		{
			fixed (byte* pname = &name)
			{
				ImGuiWindowPtr ret = ImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname = name)
			{
				ImGuiWindowPtr ret = ImGuiWindowNative(context, (byte*)pname);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ImGuiContextPtr context, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiWindowPtr ret = ImGuiWindowNative(context, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, ref byte name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = &name)
				{
					ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, ReadOnlySpan<byte> name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				fixed (byte* pname = name)
				{
					ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiWindowPtr ImGuiWindow(ref ImGuiContext context, string name)
		{
			fixed (ImGuiContext* pcontext = &context)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGuiWindowPtr ret = ImGuiWindowNative((ImGuiContext*)pcontext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiWindow*, void>)funcTable[891])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[891])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiWindowPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				DestroyNative((ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(ImGuiWindow* self, byte* str, byte* strEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, byte*, byte*, uint>)funcTable[892])(self, str, strEnd);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint>)funcTable[892])((nint)self, (nint)str, (nint)strEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, byte* strEnd)
		{
			uint ret = GetIDNative(self, str, strEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str)
		{
			uint ret = GetIDNative(self, str, (byte*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, str, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, str, (byte*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, (byte*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, byte* strEnd)
		{
			fixed (byte* pstr = str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, strEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				uint ret = GetIDNative(self, (byte*)pstr, (byte*)(default));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)(default));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, strEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)(default));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, byte* strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				uint ret = GetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstrEnd = strEnd)
			{
				uint ret = GetIDNative(self, str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, byte* str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, str, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, byte* str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			uint ret = GetIDNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, ReadOnlySpan<byte> strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ref byte str, string strEnd)
		{
			fixed (byte* pstr = &str)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative(self, (byte*)pstr, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, ref byte strEnd)
		{
			fixed (byte* pstr = str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative(self, (byte*)pstr, (byte*)pstrEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, ReadOnlySpan<byte> str, string strEnd)
		{
			fixed (byte* pstr = str)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				uint ret = GetIDNative(self, (byte*)pstr, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, ref byte strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrEnd = &strEnd)
			{
				uint ret = GetIDNative(self, pStr0, (byte*)pstrEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, string str, ReadOnlySpan<byte> strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pstrEnd = strEnd)
			{
				uint ret = GetIDNative(self, pStr0, (byte*)pstrEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					fixed (byte* pstrEnd = strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ref byte str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (strEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(strEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, (byte*)pstrEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, ReadOnlySpan<byte> str, string strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (strEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(strEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					uint ret = GetIDNative((ImGuiWindow*)pself, (byte*)pstr, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, ref byte strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pstrEnd = &strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, (byte*)pstrEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, string str, ReadOnlySpan<byte> strEnd)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pstrEnd = strEnd)
				{
					uint ret = GetIDNative((ImGuiWindow*)pself, pStr0, (byte*)pstrEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(ImGuiWindow* self, void* ptr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, void*, uint>)funcTable[893])(self, ptr);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, nint, uint>)funcTable[893])((nint)self, (nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, void* ptr)
		{
			uint ret = GetIDNative(self, ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, void* ptr)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, ptr);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDNative(ImGuiWindow* self, int n)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, int, uint>)funcTable[894])(self, n);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, int, uint>)funcTable[894])((nint)self, n);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ImGuiWindowPtr self, int n)
		{
			uint ret = GetIDNative(self, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetID(ref ImGuiWindow self, int n)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDNative((ImGuiWindow*)pself, n);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetIDFromRectangleNative(ImGuiWindow* self, ImRect rAbs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, ImRect, uint>)funcTable[895])(self, rAbs);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, ImRect, uint>)funcTable[895])((nint)self, rAbs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDFromRectangle(ImGuiWindowPtr self, ImRect rAbs)
		{
			uint ret = GetIDFromRectangleNative(self, rAbs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetIDFromRectangle(ref ImGuiWindow self, ImRect rAbs)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				uint ret = GetIDFromRectangleNative((ImGuiWindow*)pself, rAbs);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectNative(ImRect* pOut, ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[896])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[896])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ImGuiWindowPtr self)
		{
			ImRect ret;
			RectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			RectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				RectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect Rect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				RectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				RectNative(pOut, (ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Rect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					RectNative((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float CalcFontSizeNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, float>)funcTable[897])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[897])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcFontSize(ImGuiWindowPtr self)
		{
			float ret = CalcFontSizeNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float CalcFontSize(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = CalcFontSizeNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float TitleBarHeightNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, float>)funcTable[898])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[898])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TitleBarHeight(ImGuiWindowPtr self)
		{
			float ret = TitleBarHeightNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float TitleBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = TitleBarHeightNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TitleBarRectNative(ImRect* pOut, ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[899])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[899])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect TitleBarRect(ImGuiWindowPtr self)
		{
			ImRect ret;
			TitleBarRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			TitleBarRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				TitleBarRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect TitleBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				TitleBarRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				TitleBarRectNative(pOut, (ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void TitleBarRect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					TitleBarRectNative((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MenuBarHeightNative(ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiWindow*, float>)funcTable[900])(self);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)funcTable[900])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float MenuBarHeight(ImGuiWindowPtr self)
		{
			float ret = MenuBarHeightNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float MenuBarHeight(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				float ret = MenuBarHeightNative((ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MenuBarRectNative(ImRect* pOut, ImGuiWindow* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImRect*, ImGuiWindow*, void>)funcTable[901])(pOut, self);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[901])((nint)pOut, (nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect MenuBarRect(ImGuiWindowPtr self)
		{
			ImRect ret;
			MenuBarRectNative(&ret, self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ImRectPtr pOut, ImGuiWindowPtr self)
		{
			MenuBarRectNative(pOut, self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ref ImRect pOut, ImGuiWindowPtr self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				MenuBarRectNative((ImRect*)ppOut, self);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImRect MenuBarRect(ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				ImRect ret;
				MenuBarRectNative(&ret, (ImGuiWindow*)pself);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ImRectPtr pOut, ref ImGuiWindow self)
		{
			fixed (ImGuiWindow* pself = &self)
			{
				MenuBarRectNative(pOut, (ImGuiWindow*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MenuBarRect(ref ImRect pOut, ref ImGuiWindow self)
		{
			fixed (ImRect* ppOut = &pOut)
			{
				fixed (ImGuiWindow* pself = &self)
				{
					MenuBarRectNative((ImRect*)ppOut, (ImGuiWindow*)pself);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTabItem* ImGuiTabItemNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabItem*>)funcTable[902])();
			#else
			return (ImGuiTabItem*)((delegate* unmanaged[Cdecl]<nint>)funcTable[902])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabItemPtr ImGuiTabItem()
		{
			ImGuiTabItemPtr ret = ImGuiTabItemNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTabBar* ImGuiTabBarNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*>)funcTable[903])();
			#else
			return (ImGuiTabBar*)((delegate* unmanaged[Cdecl]<nint>)funcTable[903])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTabBarPtr ImGuiTabBar()
		{
			ImGuiTabBarPtr ret = ImGuiTabBarNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetTabOrderNative(ImGuiTabBar* self, ImGuiTabItem* tab)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, int>)funcTable[904])(self, tab);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[904])((nint)self, (nint)tab);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetTabOrder(ImGuiTabBarPtr self, ImGuiTabItemPtr tab)
		{
			int ret = GetTabOrderNative(self, tab);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetTabOrder(ref ImGuiTabBar self, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				int ret = GetTabOrderNative((ImGuiTabBar*)pself, tab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetTabOrder(ImGuiTabBarPtr self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				int ret = GetTabOrderNative(self, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetTabOrder(ref ImGuiTabBar self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					int ret = GetTabOrderNative((ImGuiTabBar*)pself, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetTabNameNative(ImGuiTabBar* self, ImGuiTabItem* tab)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTabBar*, ImGuiTabItem*, byte*>)funcTable[905])(self, tab);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[905])((nint)self, (nint)tab);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetTabName(ImGuiTabBarPtr self, ImGuiTabItemPtr tab)
		{
			byte* ret = GetTabNameNative(self, tab);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTabNameS(ImGuiTabBarPtr self, ImGuiTabItemPtr tab)
		{
			string ret = Utils.DecodeStringUTF8(GetTabNameNative(self, tab));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetTabName(ref ImGuiTabBar self, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				byte* ret = GetTabNameNative((ImGuiTabBar*)pself, tab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTabNameS(ref ImGuiTabBar self, ImGuiTabItemPtr tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				string ret = Utils.DecodeStringUTF8(GetTabNameNative((ImGuiTabBar*)pself, tab));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetTabName(ImGuiTabBarPtr self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				byte* ret = GetTabNameNative(self, (ImGuiTabItem*)ptab);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTabNameS(ImGuiTabBarPtr self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabItem* ptab = &tab)
			{
				string ret = Utils.DecodeStringUTF8(GetTabNameNative(self, (ImGuiTabItem*)ptab));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetTabName(ref ImGuiTabBar self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					byte* ret = GetTabNameNative((ImGuiTabBar*)pself, (ImGuiTabItem*)ptab);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetTabNameS(ref ImGuiTabBar self, ref ImGuiTabItem tab)
		{
			fixed (ImGuiTabBar* pself = &self)
			{
				fixed (ImGuiTabItem* ptab = &tab)
				{
					string ret = Utils.DecodeStringUTF8(GetTabNameNative((ImGuiTabBar*)pself, (ImGuiTabItem*)ptab));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableColumn* ImGuiTableColumnNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumn*>)funcTable[906])();
			#else
			return (ImGuiTableColumn*)((delegate* unmanaged[Cdecl]<nint>)funcTable[906])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnPtr ImGuiTableColumn()
		{
			ImGuiTableColumnPtr ret = ImGuiTableColumnNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableInstanceData* ImGuiTableInstanceDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableInstanceData*>)funcTable[907])();
			#else
			return (ImGuiTableInstanceData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[907])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableInstanceDataPtr ImGuiTableInstanceData()
		{
			ImGuiTableInstanceDataPtr ret = ImGuiTableInstanceDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTable* ImGuiTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTable*>)funcTable[908])();
			#else
			return (ImGuiTable*)((delegate* unmanaged[Cdecl]<nint>)funcTable[908])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTablePtr ImGuiTable()
		{
			ImGuiTablePtr ret = ImGuiTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTable* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTable*, void>)funcTable[909])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[909])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTablePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTable self)
		{
			fixed (ImGuiTable* pself = &self)
			{
				DestroyNative((ImGuiTable*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableTempData* ImGuiTableTempDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableTempData*>)funcTable[910])();
			#else
			return (ImGuiTableTempData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[910])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableTempDataPtr ImGuiTableTempData()
		{
			ImGuiTableTempDataPtr ret = ImGuiTableTempDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableColumnSettings* ImGuiTableColumnSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumnSettings*>)funcTable[911])();
			#else
			return (ImGuiTableColumnSettings*)((delegate* unmanaged[Cdecl]<nint>)funcTable[911])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnSettingsPtr ImGuiTableColumnSettings()
		{
			ImGuiTableColumnSettingsPtr ret = ImGuiTableColumnSettingsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableSettings* ImGuiTableSettingsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableSettings*>)funcTable[912])();
			#else
			return (ImGuiTableSettings*)((delegate* unmanaged[Cdecl]<nint>)funcTable[912])();
			#endif
		}
	}
}
