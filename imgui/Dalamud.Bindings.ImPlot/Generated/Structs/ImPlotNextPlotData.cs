// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Dalamud.Bindings.ImGui;

namespace Dalamud.Bindings.ImPlot
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPlotNextPlotData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImPlotCond RangeCond_0;
		public ImPlotCond RangeCond_1;
		public ImPlotCond RangeCond_2;
		public ImPlotCond RangeCond_3;
		public ImPlotCond RangeCond_4;
		public ImPlotCond RangeCond_5;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImPlotRange Range_0;
		public ImPlotRange Range_1;
		public ImPlotRange Range_2;
		public ImPlotRange Range_3;
		public ImPlotRange Range_4;
		public ImPlotRange Range_5;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool HasRange_0;
		public bool HasRange_1;
		public bool HasRange_2;
		public bool HasRange_3;
		public bool HasRange_4;
		public bool HasRange_5;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool Fit_0;
		public bool Fit_1;
		public bool Fit_2;
		public bool Fit_3;
		public bool Fit_4;
		public bool Fit_5;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe double* LinkedMin_0;
		public unsafe double* LinkedMin_1;
		public unsafe double* LinkedMin_2;
		public unsafe double* LinkedMin_3;
		public unsafe double* LinkedMin_4;
		public unsafe double* LinkedMin_5;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe double* LinkedMax_0;
		public unsafe double* LinkedMax_1;
		public unsafe double* LinkedMax_2;
		public unsafe double* LinkedMax_3;
		public unsafe double* LinkedMax_4;
		public unsafe double* LinkedMax_5;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImPlotNextPlotData(ImPlotCond* rangeCond = default, ImPlotRangePtr range = default, bool* hasRange = default, bool* fit = default, double** linkedMin = default, double** linkedMax = default)
		{
			if (rangeCond != default(ImPlotCond*))
			{
				RangeCond_0 = rangeCond[0];
				RangeCond_1 = rangeCond[1];
				RangeCond_2 = rangeCond[2];
				RangeCond_3 = rangeCond[3];
				RangeCond_4 = rangeCond[4];
				RangeCond_5 = rangeCond[5];
			}
			if (range != default(ImPlotRangePtr))
			{
				Range_0 = range[0];
				Range_1 = range[1];
				Range_2 = range[2];
				Range_3 = range[3];
				Range_4 = range[4];
				Range_5 = range[5];
			}
			if (hasRange != default(bool*))
			{
				HasRange_0 = hasRange[0];
				HasRange_1 = hasRange[1];
				HasRange_2 = hasRange[2];
				HasRange_3 = hasRange[3];
				HasRange_4 = hasRange[4];
				HasRange_5 = hasRange[5];
			}
			if (fit != default(bool*))
			{
				Fit_0 = fit[0];
				Fit_1 = fit[1];
				Fit_2 = fit[2];
				Fit_3 = fit[3];
				Fit_4 = fit[4];
				Fit_5 = fit[5];
			}
			if (linkedMin != default(double**))
			{
				LinkedMin_0 = linkedMin[0];
				LinkedMin_1 = linkedMin[1];
				LinkedMin_2 = linkedMin[2];
				LinkedMin_3 = linkedMin[3];
				LinkedMin_4 = linkedMin[4];
				LinkedMin_5 = linkedMin[5];
			}
			if (linkedMax != default(double**))
			{
				LinkedMax_0 = linkedMax[0];
				LinkedMax_1 = linkedMax[1];
				LinkedMax_2 = linkedMax[2];
				LinkedMax_3 = linkedMax[3];
				LinkedMax_4 = linkedMax[4];
				LinkedMax_5 = linkedMax[5];
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImPlotNextPlotData(Span<ImPlotCond> rangeCond = default, Span<ImPlotRange> range = default, Span<bool> hasRange = default, Span<bool> fit = default, Span<Pointer<double>> linkedMin = default, Span<Pointer<double>> linkedMax = default)
		{
			if (rangeCond != default(Span<ImPlotCond>))
			{
				RangeCond_0 = rangeCond[0];
				RangeCond_1 = rangeCond[1];
				RangeCond_2 = rangeCond[2];
				RangeCond_3 = rangeCond[3];
				RangeCond_4 = rangeCond[4];
				RangeCond_5 = rangeCond[5];
			}
			if (range != default(Span<ImPlotRange>))
			{
				Range_0 = range[0];
				Range_1 = range[1];
				Range_2 = range[2];
				Range_3 = range[3];
				Range_4 = range[4];
				Range_5 = range[5];
			}
			if (hasRange != default(Span<bool>))
			{
				HasRange_0 = hasRange[0];
				HasRange_1 = hasRange[1];
				HasRange_2 = hasRange[2];
				HasRange_3 = hasRange[3];
				HasRange_4 = hasRange[4];
				HasRange_5 = hasRange[5];
			}
			if (fit != default(Span<bool>))
			{
				Fit_0 = fit[0];
				Fit_1 = fit[1];
				Fit_2 = fit[2];
				Fit_3 = fit[3];
				Fit_4 = fit[4];
				Fit_5 = fit[5];
			}
			if (linkedMin != default(Span<Pointer<double>>))
			{
				LinkedMin_0 = linkedMin[0];
				LinkedMin_1 = linkedMin[1];
				LinkedMin_2 = linkedMin[2];
				LinkedMin_3 = linkedMin[3];
				LinkedMin_4 = linkedMin[4];
				LinkedMin_5 = linkedMin[5];
			}
			if (linkedMax != default(Span<Pointer<double>>))
			{
				LinkedMax_0 = linkedMax[0];
				LinkedMax_1 = linkedMax[1];
				LinkedMax_2 = linkedMax[2];
				LinkedMax_3 = linkedMax[3];
				LinkedMax_4 = linkedMax[4];
				LinkedMax_5 = linkedMax[5];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<ImPlotRange> Range
		
		{
			get
			{
				fixed (ImPlotRange* p = &this.Range_0)
				{
					return new Span<ImPlotRange>(p, 6);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Pointer<double>> LinkedMin
		
		{
			get
			{
				fixed (double** p = &this.LinkedMin_0)
				{
					return new Span<Pointer<double>>(p, 6);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Pointer<double>> LinkedMax
		
		{
			get
			{
				fixed (double** p = &this.LinkedMax_0)
				{
					return new Span<Pointer<double>>(p, 6);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			fixed (ImPlotNextPlotData* @this = &this)
			{
				ImPlot.DestroyNative(@this);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Reset()
		{
			fixed (ImPlotNextPlotData* @this = &this)
			{
				ImPlot.ResetNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	#if NET5_0_OR_GREATER
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	#endif
	public unsafe struct ImPlotNextPlotDataPtr : IEquatable<ImPlotNextPlotDataPtr>
	{
		public ImPlotNextPlotDataPtr(ImPlotNextPlotData* handle) { Handle = handle; }

		public ImPlotNextPlotData* Handle;

		public bool IsNull => Handle == null;

		public static ImPlotNextPlotDataPtr Null => new ImPlotNextPlotDataPtr(null);

		public ImPlotNextPlotData this[int index] { get => Handle[index]; set => Handle[index] = value; }

		public static implicit operator ImPlotNextPlotDataPtr(ImPlotNextPlotData* handle) => new ImPlotNextPlotDataPtr(handle);

		public static implicit operator ImPlotNextPlotData*(ImPlotNextPlotDataPtr handle) => handle.Handle;

		public static bool operator ==(ImPlotNextPlotDataPtr left, ImPlotNextPlotDataPtr right) => left.Handle == right.Handle;

		public static bool operator !=(ImPlotNextPlotDataPtr left, ImPlotNextPlotDataPtr right) => left.Handle != right.Handle;

		public static bool operator ==(ImPlotNextPlotDataPtr left, ImPlotNextPlotData* right) => left.Handle == right;

		public static bool operator !=(ImPlotNextPlotDataPtr left, ImPlotNextPlotData* right) => left.Handle != right;

		public bool Equals(ImPlotNextPlotDataPtr other) => Handle == other.Handle;

		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is ImPlotNextPlotDataPtr handle && Equals(handle);

		/// <inheritdoc/>
		public override int GetHashCode() => ((nuint)Handle).GetHashCode();

		#if NET5_0_OR_GREATER
		private string DebuggerDisplay => string.Format("ImPlotNextPlotDataPtr [0x{0}]", ((nuint)Handle).ToString("X"));
		#endif
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<int> RangeCond
		
		{
			get
			{
				return new Span<int>(&Handle->RangeCond_0, 6);
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<ImPlotRange> Range
		
		{
			get
			{
				return new Span<ImPlotRange>(&Handle->Range_0, 6);
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<bool> HasRange
		
		{
			get
			{
				return new Span<bool>(&Handle->HasRange_0, 6);
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<bool> Fit
		
		{
			get
			{
				return new Span<bool>(&Handle->Fit_0, 6);
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			ImPlot.DestroyNative(Handle);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Reset()
		{
			ImPlot.ResetNative(Handle);
		}

	}

}
