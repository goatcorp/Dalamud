// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Dalamud.Bindings.ImGui;

namespace Dalamud.Bindings.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(id, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(pStr0, (int*)plevel, t, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				fixed (ImPlotTime* pt1 = &t1)
				{
					fixed (ImPlotTime* pt2 = &t2)
					{
						byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							fixed (ImPlotTime* pt2 = &t2)
							{
								byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						fixed (ImPlotTime* pt1 = &t1)
						{
							fixed (ImPlotTime* pt2 = &t2)
							{
								byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, ref ImPlotTime t1, ref ImPlotTime t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					fixed (ImPlotTime* pt1 = &t1)
					{
						fixed (ImPlotTime* pt2 = &t2)
						{
							byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)pt1, (ImPlotTime*)pt2);
							if (pStrSize0 >= Utils.MaxStackallocSize)
							{
								Utils.Free(pStr0);
							}
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowTimePickerNative(byte* id, ImPlotTime* t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImPlotTime*, byte>)funcTable[708])(id, t);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[708])((nint)id, (nint)t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(byte* id, ImPlotTimePtr t)
		{
			byte ret = ShowTimePickerNative(id, t);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(ref byte id, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowTimePickerNative((byte*)pid, t);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(ReadOnlySpan<byte> id, ImPlotTimePtr t)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowTimePickerNative((byte*)pid, t);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(string id, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowTimePickerNative(pStr0, t);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(byte* id, ref ImPlotTime t)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowTimePickerNative(id, (ImPlotTime*)pt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(ref byte id, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowTimePickerNative((byte*)pid, (ImPlotTime*)pt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(ReadOnlySpan<byte> id, ref ImPlotTime t)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowTimePickerNative((byte*)pid, (ImPlotTime*)pt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowTimePicker(string id, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowTimePickerNative(pStr0, (ImPlotTime*)pt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformForward_Log10Native(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[709])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[709])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_Log10(double v, void* noname1)
		{
			double ret = TransformForward_Log10Native(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformInverse_Log10Native(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[710])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[710])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_Log10(double v, void* noname1)
		{
			double ret = TransformInverse_Log10Native(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformForward_SymLogNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[711])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[711])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_SymLog(double v, void* noname1)
		{
			double ret = TransformForward_SymLogNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformInverse_SymLogNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[712])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[712])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_SymLog(double v, void* noname1)
		{
			double ret = TransformInverse_SymLogNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformForward_LogitNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[713])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[713])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformForward_Logit(double v, void* noname1)
		{
			double ret = TransformForward_LogitNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double TransformInverse_LogitNative(double v, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, void*, double>)funcTable[714])(v, noname1);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, nint, double>)funcTable[714])(v, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double TransformInverse_Logit(double v, void* noname1)
		{
			double ret = TransformInverse_LogitNative(v, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Formatter_DefaultNative(double value, byte* buff, int size, void* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte*, int, void*, int>)funcTable[715])(value, buff, size, data);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, nint, int, nint, int>)funcTable[715])(value, (nint)buff, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, byte* buff, int size, void* data)
		{
			int ret = Formatter_DefaultNative(value, buff, size, data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, ref byte buff, int size, void* data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_DefaultNative(value, (byte*)pbuff, size, data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Default(double value, ref string buff, int size, void* data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_DefaultNative(value, pStr0, size, data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Formatter_LogitNative(double value, byte* buff, int size, void* noname1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte*, int, void*, int>)funcTable[716])(value, buff, size, noname1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, nint, int, nint, int>)funcTable[716])(value, (nint)buff, size, (nint)noname1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, byte* buff, int size, void* noname1)
		{
			int ret = Formatter_LogitNative(value, buff, size, noname1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, ref byte buff, int size, void* noname1)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_LogitNative(value, (byte*)pbuff, size, noname1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Logit(double value, ref string buff, int size, void* noname1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_LogitNative(value, pStr0, size, noname1);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Formatter_TimeNative(double noname1, byte* buff, int size, void* data)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte*, int, void*, int>)funcTable[717])(noname1, buff, size, data);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, nint, int, nint, int>)funcTable[717])(noname1, (nint)buff, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, byte* buff, int size, void* data)
		{
			int ret = Formatter_TimeNative(noname1, buff, size, data);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, ref byte buff, int size, void* data)
		{
			fixed (byte* pbuff = &buff)
			{
				int ret = Formatter_TimeNative(noname1, (byte*)pbuff, size, data);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Formatter_Time(double noname1, ref string buff, int size, void* data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buff != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buff);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buff, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = Formatter_TimeNative(noname1, pStr0, size, data);
			buff = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_DefaultNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[718])(ticker, range, pixels, vertical, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[718])((nint)ticker, range, pixels, vertical, (nint)Utils.GetFunctionPointerForDelegate(formatter), (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_DefaultNative(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Default(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_DefaultNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_TimeNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[719])(ticker, range, pixels, vertical, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[719])((nint)ticker, range, pixels, vertical, (nint)Utils.GetFunctionPointerForDelegate(formatter), (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_TimeNative(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Time(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_TimeNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_Log10Native(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[720])(ticker, range, pixels, vertical, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[720])((nint)ticker, range, pixels, vertical, (nint)Utils.GetFunctionPointerForDelegate(formatter), (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_Log10Native(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_Log10(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_Log10Native((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Locator_SymLogNative(ImPlotTicker* ticker, ImPlotRange range, float pixels, byte vertical, ImPlotFormatter formatter, void* formatterData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTicker*, ImPlotRange, float, byte, delegate*<double, byte*, int, void*, int>, void*, void>)funcTable[721])(ticker, range, pixels, vertical, (delegate*<double, byte*, int, void*, int>)Utils.GetFunctionPointerForDelegate(formatter), formatterData);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotRange, float, byte, nint, nint, void>)funcTable[721])((nint)ticker, range, pixels, vertical, (nint)Utils.GetFunctionPointerForDelegate(formatter), (nint)formatterData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ImPlotTickerPtr ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			Locator_SymLogNative(ticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Locator_SymLog(ref ImPlotTicker ticker, ImPlotRange range, float pixels, bool vertical, ImPlotFormatter formatter, void* formatterData)
		{
			fixed (ImPlotTicker* pticker = &ticker)
			{
				Locator_SymLogNative((ImPlotTicker*)pticker, range, pixels, vertical ? (byte)1 : (byte)0, formatter, formatterData);
			}
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PlotLineGNative(byte* labelId, ImPlotPointGetter getter, void* data, int count, ImPlotLineFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, int, ImPlotPoint*, void*>, void*, int, ImPlotLineFlags, void>)funcTable[722])(labelId, (delegate*<void*, int, ImPlotPoint*, void*>)Utils.GetFunctionPointerForDelegate(getter), data, count, flags);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, ImPlotLineFlags, void>)funcTable[722])((nint)labelId, (nint)Utils.GetFunctionPointerForDelegate(getter), (nint)data, count, flags);
			#endif
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(byte* labelId, ImPlotPointGetter getter, void* data, int count, ImPlotLineFlags flags)
		{
			PlotLineGNative(labelId, getter, data, count, flags);
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(byte* labelId, ImPlotPointGetter getter, void* data, int count)
		{
			PlotLineGNative(labelId, getter, data, count, (ImPlotLineFlags)(0));
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(ref byte labelId, ImPlotPointGetter getter, void* data, int count, ImPlotLineFlags flags)
		{
			fixed (byte* plabelId = &labelId)
			{
				PlotLineGNative((byte*)plabelId, getter, data, count, flags);
			}
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(ref byte labelId, ImPlotPointGetter getter, void* data, int count)
		{
			fixed (byte* plabelId = &labelId)
			{
				PlotLineGNative((byte*)plabelId, getter, data, count, (ImPlotLineFlags)(0));
			}
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(ReadOnlySpan<byte> labelId, ImPlotPointGetter getter, void* data, int count, ImPlotLineFlags flags)
		{
			fixed (byte* plabelId = labelId)
			{
				PlotLineGNative((byte*)plabelId, getter, data, count, flags);
			}
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(ReadOnlySpan<byte> labelId, ImPlotPointGetter getter, void* data, int count)
		{
			fixed (byte* plabelId = labelId)
			{
				PlotLineGNative((byte*)plabelId, getter, data, count, (ImPlotLineFlags)(0));
			}
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(string labelId, ImPlotPointGetter getter, void* data, int count, ImPlotLineFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLineGNative(pStr0, getter, data, count, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// ImPlotPoint getters manually wrapped<br/>
		/// </summary>
		public static void PlotLineG(string labelId, ImPlotPointGetter getter, void* data, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLineGNative(pStr0, getter, data, count, (ImPlotLineFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PlotScatterGNative(byte* labelId, ImPlotPointGetter getter, void* data, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, int, ImPlotPoint*, void*>, void*, int, void>)funcTable[723])(labelId, (delegate*<void*, int, ImPlotPoint*, void*>)Utils.GetFunctionPointerForDelegate(getter), data, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[723])((nint)labelId, (nint)Utils.GetFunctionPointerForDelegate(getter), (nint)data, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotScatterG(byte* labelId, ImPlotPointGetter getter, void* data, int count)
		{
			PlotScatterGNative(labelId, getter, data, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotScatterG(ref byte labelId, ImPlotPointGetter getter, void* data, int count)
		{
			fixed (byte* plabelId = &labelId)
			{
				PlotScatterGNative((byte*)plabelId, getter, data, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotScatterG(ReadOnlySpan<byte> labelId, ImPlotPointGetter getter, void* data, int count)
		{
			fixed (byte* plabelId = labelId)
			{
				PlotScatterGNative((byte*)plabelId, getter, data, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotScatterG(string labelId, ImPlotPointGetter getter, void* data, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotScatterGNative(pStr0, getter, data, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PlotShadedGNative(byte* labelId, ImPlotPointGetter getter1, void* data1, ImPlotPointGetter getter2, void* data2, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, int, ImPlotPoint*, void*>, void*, delegate*<void*, int, ImPlotPoint*, void*>, void*, int, void>)funcTable[724])(labelId, (delegate*<void*, int, ImPlotPoint*, void*>)Utils.GetFunctionPointerForDelegate(getter1), data1, (delegate*<void*, int, ImPlotPoint*, void*>)Utils.GetFunctionPointerForDelegate(getter2), data2, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int, void>)funcTable[724])((nint)labelId, (nint)Utils.GetFunctionPointerForDelegate(getter1), (nint)data1, (nint)Utils.GetFunctionPointerForDelegate(getter2), (nint)data2, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotShadedG(byte* labelId, ImPlotPointGetter getter1, void* data1, ImPlotPointGetter getter2, void* data2, int count)
		{
			PlotShadedGNative(labelId, getter1, data1, getter2, data2, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotShadedG(ref byte labelId, ImPlotPointGetter getter1, void* data1, ImPlotPointGetter getter2, void* data2, int count)
		{
			fixed (byte* plabelId = &labelId)
			{
				PlotShadedGNative((byte*)plabelId, getter1, data1, getter2, data2, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotShadedG(ReadOnlySpan<byte> labelId, ImPlotPointGetter getter1, void* data1, ImPlotPointGetter getter2, void* data2, int count)
		{
			fixed (byte* plabelId = labelId)
			{
				PlotShadedGNative((byte*)plabelId, getter1, data1, getter2, data2, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotShadedG(string labelId, ImPlotPointGetter getter1, void* data1, ImPlotPointGetter getter2, void* data2, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotShadedGNative(pStr0, getter1, data1, getter2, data2, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PlotBarsGNative(byte* labelId, ImPlotPointGetter getter, void* data, int count, double width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, int, ImPlotPoint*, void*>, void*, int, double, void>)funcTable[725])(labelId, (delegate*<void*, int, ImPlotPoint*, void*>)Utils.GetFunctionPointerForDelegate(getter), data, count, width);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, double, void>)funcTable[725])((nint)labelId, (nint)Utils.GetFunctionPointerForDelegate(getter), (nint)data, count, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotBarsG(byte* labelId, ImPlotPointGetter getter, void* data, int count, double width)
		{
			PlotBarsGNative(labelId, getter, data, count, width);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotBarsG(ref byte labelId, ImPlotPointGetter getter, void* data, int count, double width)
		{
			fixed (byte* plabelId = &labelId)
			{
				PlotBarsGNative((byte*)plabelId, getter, data, count, width);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotBarsG(ReadOnlySpan<byte> labelId, ImPlotPointGetter getter, void* data, int count, double width)
		{
			fixed (byte* plabelId = labelId)
			{
				PlotBarsGNative((byte*)plabelId, getter, data, count, width);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void PlotBarsG(string labelId, ImPlotPointGetter getter, void* data, int count, double width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotBarsGNative(pStr0, getter, data, count, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// CIMGUI_API void ImPlot_PlotBarsHG(const char* label_id, ImPlotPoint_getter getter, void* data, int count, double height);<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PlotDigitalGNative(byte* labelId, ImPlotPointGetter getter, void* data, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, delegate*<void*, int, ImPlotPoint*, void*>, void*, int, void>)funcTable[726])(labelId, (delegate*<void*, int, ImPlotPoint*, void*>)Utils.GetFunctionPointerForDelegate(getter), data, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, int, void>)funcTable[726])((nint)labelId, (nint)Utils.GetFunctionPointerForDelegate(getter), (nint)data, count);
			#endif
		}

		/// <summary>
		/// CIMGUI_API void ImPlot_PlotBarsHG(const char* label_id, ImPlotPoint_getter getter, void* data, int count, double height);<br/>
		/// </summary>
		public static void PlotDigitalG(byte* labelId, ImPlotPointGetter getter, void* data, int count)
		{
			PlotDigitalGNative(labelId, getter, data, count);
		}

		/// <summary>
		/// CIMGUI_API void ImPlot_PlotBarsHG(const char* label_id, ImPlotPoint_getter getter, void* data, int count, double height);<br/>
		/// </summary>
		public static void PlotDigitalG(ref byte labelId, ImPlotPointGetter getter, void* data, int count)
		{
			fixed (byte* plabelId = &labelId)
			{
				PlotDigitalGNative((byte*)plabelId, getter, data, count);
			}
		}

		/// <summary>
		/// CIMGUI_API void ImPlot_PlotBarsHG(const char* label_id, ImPlotPoint_getter getter, void* data, int count, double height);<br/>
		/// </summary>
		public static void PlotDigitalG(ReadOnlySpan<byte> labelId, ImPlotPointGetter getter, void* data, int count)
		{
			fixed (byte* plabelId = labelId)
			{
				PlotDigitalGNative((byte*)plabelId, getter, data, count);
			}
		}

		/// <summary>
		/// CIMGUI_API void ImPlot_PlotBarsHG(const char* label_id, ImPlotPoint_getter getter, void* data, int count, double height);<br/>
		/// </summary>
		public static void PlotDigitalG(string labelId, ImPlotPointGetter getter, void* data, int count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (labelId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(labelId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(labelId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotDigitalGNative(pStr0, getter, data, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

	}
}
