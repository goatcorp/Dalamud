// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;
using Dalamud.Bindings.ImGui;

namespace Dalamud.Bindings.ImPlot
{
	public unsafe partial class ImPlot
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextVerticalNative(drawList, pos, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextVerticalNative(drawList, pos, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ImDrawListPtr drawList, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextVerticalNative(drawList, pos, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextVertical(ref ImDrawList drawList, Vector2 pos, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextVerticalNative((ImDrawList*)pdrawList, pos, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddTextCenteredNative(ImDrawList* drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImDrawList*, Vector2, uint, byte*, byte*, void>)funcTable[624])(drawList, topCenter, col, textBegin, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, uint, nint, nint, void>)funcTable[624])((nint)drawList, topCenter, col, (nint)textBegin, (nint)textEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			AddTextCenteredNative(drawList, topCenter, col, textBegin, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin)
		{
			AddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)(((void*)0)));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)(((void*)0)));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)(((void*)0)));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)(((void*)0)));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, pStr0, (byte*)(((void*)0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)(((void*)0)));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)(((void*)0)));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, (byte*)(((void*)0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, textBegin, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, byte* textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, textBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, byte* textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			AddTextCenteredNative(drawList, topCenter, col, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ref byte textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (byte* ptextBegin = textBegin)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddTextCenteredNative(drawList, topCenter, col, (byte*)ptextBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ImDrawListPtr drawList, Vector2 topCenter, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				AddTextCenteredNative(drawList, topCenter, col, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ref byte textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, ReadOnlySpan<byte> textBegin, string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = textBegin)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, (byte*)ptextBegin, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTextCentered(ref ImDrawList drawList, Vector2 topCenter, uint col, string textBegin, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					AddTextCenteredNative((ImDrawList*)pdrawList, topCenter, col, pStr0, (byte*)ptextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalcTextSizeVerticalNative(Vector2* pOut, byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, void>)funcTable[625])(pOut, text);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[625])((nint)pOut, (nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(byte* text)
		{
			Vector2 ret;
			CalcTextSizeVerticalNative(&ret, text);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(Vector2* pOut, byte* text)
		{
			CalcTextSizeVerticalNative(pOut, text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, byte* text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeVerticalNative((Vector2*)ppOut, text);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				Vector2 ret;
				CalcTextSizeVerticalNative(&ret, (byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				Vector2 ret;
				CalcTextSizeVerticalNative(&ret, (byte*)ptext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 CalcTextSizeVertical(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Vector2 ret;
			CalcTextSizeVerticalNative(&ret, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, ref byte text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeVerticalNative((Vector2*)ppOut, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, ReadOnlySpan<byte> text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeVerticalNative((Vector2*)ppOut, (byte*)ptext);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSizeVertical(ref Vector2 pOut, string text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeVerticalNative((Vector2*)ppOut, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalcTextColorNative(Vector4 bg)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[626])(bg);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[626])(bg);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CalcTextColor(Vector4 bg)
		{
			uint ret = CalcTextColorNative(bg);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalcTextColorNative(uint bg)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[627])(bg);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[627])(bg);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CalcTextColor(uint bg)
		{
			uint ret = CalcTextColorNative(bg);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CalcHoverColorNative(uint col)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[628])(col);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[628])(col);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CalcHoverColor(uint col)
		{
			uint ret = CalcHoverColorNative(col);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClampLabelPosNative(Vector2* pOut, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, void>)funcTable[629])(pOut, pos, size, min, max);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, void>)funcTable[629])((nint)pOut, pos, size, min, max);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 ClampLabelPos(Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			Vector2 ret;
			ClampLabelPosNative(&ret, pos, size, min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClampLabelPos(Vector2* pOut, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			ClampLabelPosNative(pOut, pos, size, min, max);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ClampLabelPos(ref Vector2 pOut, Vector2 pos, Vector2 size, Vector2 min, Vector2 max)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				ClampLabelPosNative((Vector2*)ppOut, pos, size, min, max);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetColormapColorU32Native(int idx, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImPlotColormap, uint>)funcTable[630])(idx, cmap);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, ImPlotColormap, uint>)funcTable[630])(idx, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColormapColorU32(int idx, ImPlotColormap cmap)
		{
			uint ret = GetColormapColorU32Native(idx, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint NextColormapColorU32Native()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[631])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[631])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint NextColormapColorU32()
		{
			uint ret = NextColormapColorU32Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint SampleColormapU32Native(float t, ImPlotColormap cmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, ImPlotColormap, uint>)funcTable[632])(t, cmap);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<float, ImPlotColormap, uint>)funcTable[632])(t, cmap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint SampleColormapU32(float t, ImPlotColormap cmap)
		{
			uint ret = SampleColormapU32Native(t, cmap);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderColorBarNative(uint* colors, int size, ImDrawList* drawList, ImRect bounds, byte vert, byte reversed, byte continuous)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, ImDrawList*, ImRect, byte, byte, byte, void>)funcTable[633])(colors, size, drawList, bounds, vert, reversed, continuous);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, ImRect, byte, byte, byte, void>)funcTable[633])((nint)colors, size, (nint)drawList, bounds, vert, reversed, continuous);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(uint* colors, int size, ImDrawListPtr drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			RenderColorBarNative(colors, size, drawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(ref uint colors, int size, ImDrawListPtr drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (uint* pcolors = &colors)
			{
				RenderColorBarNative((uint*)pcolors, size, drawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(uint* colors, int size, ref ImDrawList drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderColorBarNative(colors, size, (ImDrawList*)pdrawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RenderColorBar(ref uint colors, int size, ref ImDrawList drawList, ImRect bounds, bool vert, bool reversed, bool continuous)
		{
			fixed (uint* pcolors = &colors)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					RenderColorBarNative((uint*)pcolors, size, (ImDrawList*)pdrawList, bounds, vert ? (byte)1 : (byte)0, reversed ? (byte)1 : (byte)0, continuous ? (byte)1 : (byte)0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double NiceNumNative(double x, byte round)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, byte, double>)funcTable[634])(x, round);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, byte, double>)funcTable[634])(x, round);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double NiceNum(double x, bool round)
		{
			double ret = NiceNumNative(x, round ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OrderOfMagnitudeNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[635])(val);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[635])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int OrderOfMagnitude(double val)
		{
			int ret = OrderOfMagnitudeNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OrderToPrecisionNative(int order)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[636])(order);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[636])(order);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int OrderToPrecision(int order)
		{
			int ret = OrderToPrecisionNative(order);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PrecisionNative(double val)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int>)funcTable[637])(val);
			#else
			return (int)((delegate* unmanaged[Cdecl]<double, int>)funcTable[637])(val);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Precision(double val)
		{
			int ret = PrecisionNative(val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double RoundToNative(double val, int prec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[638])(val, prec);
			#else
			return (double)((delegate* unmanaged[Cdecl]<double, int, double>)funcTable[638])(val, prec);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double RoundTo(double val, int prec)
		{
			double ret = RoundToNative(val, prec);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IntersectionNative(Vector2* pOut, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, Vector2, Vector2, Vector2, Vector2, void>)funcTable[639])(pOut, a1, a2, b1, b2);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2, Vector2, Vector2, void>)funcTable[639])((nint)pOut, a1, a2, b1, b2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector2 Intersection(Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			Vector2 ret;
			IntersectionNative(&ret, a1, a2, b1, b2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Intersection(Vector2* pOut, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			IntersectionNative(pOut, a1, a2, b1, b2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Intersection(ref Vector2 pOut, Vector2 a1, Vector2 a2, Vector2 b1, Vector2 b2)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				IntersectionNative((Vector2*)ppOut, a1, a2, b1, b2);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<float>* buffer, int n, float vmin, float vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<float>*, int, float, float, void>)funcTable[640])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, float, float, void>)funcTable[640])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<float>* buffer, int n, float vmin, float vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<float> buffer, int n, float vmin, float vmax)
		{
			fixed (ImVector<float>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<float>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<double>* buffer, int n, double vmin, double vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<double>*, int, double, double, void>)funcTable[641])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, double, double, void>)funcTable[641])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<double>* buffer, int n, double vmin, double vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<double> buffer, int n, double vmin, double vmax)
		{
			fixed (ImVector<double>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<double>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<sbyte>* buffer, int n, byte vmin, byte vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<sbyte>*, int, byte, byte, void>)funcTable[642])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, byte, byte, void>)funcTable[642])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<sbyte>* buffer, int n, byte vmin, byte vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<sbyte> buffer, int n, byte vmin, byte vmax)
		{
			fixed (ImVector<sbyte>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<sbyte>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<byte>* buffer, int n, byte vmin, byte vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<byte>*, int, byte, byte, void>)funcTable[643])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, byte, byte, void>)funcTable[643])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<byte>* buffer, int n, byte vmin, byte vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<byte> buffer, int n, byte vmin, byte vmax)
		{
			fixed (ImVector<byte>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<byte>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<short>* buffer, int n, short vmin, short vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<short>*, int, short, short, void>)funcTable[644])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, short, short, void>)funcTable[644])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<short>* buffer, int n, short vmin, short vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<short> buffer, int n, short vmin, short vmax)
		{
			fixed (ImVector<short>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<short>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<ushort>* buffer, int n, ushort vmin, ushort vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<ushort>*, int, ushort, ushort, void>)funcTable[645])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ushort, ushort, void>)funcTable[645])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<ushort>* buffer, int n, ushort vmin, ushort vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<ushort> buffer, int n, ushort vmin, ushort vmax)
		{
			fixed (ImVector<ushort>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<ushort>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<int>* buffer, int n, int vmin, int vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<int>*, int, int, int, void>)funcTable[646])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, void>)funcTable[646])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<int>* buffer, int n, int vmin, int vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<int> buffer, int n, int vmin, int vmax)
		{
			fixed (ImVector<int>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<int>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<uint>* buffer, int n, uint vmin, uint vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<uint>*, int, uint, uint, void>)funcTable[647])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, uint, uint, void>)funcTable[647])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<uint>* buffer, int n, uint vmin, uint vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<uint> buffer, int n, uint vmin, uint vmax)
		{
			fixed (ImVector<uint>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<uint>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<long>* buffer, int n, long vmin, long vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<long>*, int, long, long, void>)funcTable[648])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, long, long, void>)funcTable[648])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<long>* buffer, int n, long vmin, long vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<long> buffer, int n, long vmin, long vmax)
		{
			fixed (ImVector<long>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<long>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FillRangeNative(ImVector<ulong>* buffer, int n, ulong vmin, ulong vmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImVector<ulong>*, int, ulong, ulong, void>)funcTable[649])(buffer, n, vmin, vmax);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ulong, ulong, void>)funcTable[649])((nint)buffer, n, vmin, vmax);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ImVector<ulong>* buffer, int n, ulong vmin, ulong vmax)
		{
			FillRangeNative(buffer, n, vmin, vmax);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FillRange(ref ImVector<ulong> buffer, int n, ulong vmin, ulong vmax)
		{
			fixed (ImVector<ulong>* pbuffer = &buffer)
			{
				FillRangeNative((ImVector<ulong>*)pbuffer, n, vmin, vmax);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[650])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[650])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (float* pvalues = &values)
			{
				CalculateBinsNative((float*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((float*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((float*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(float* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref float values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (float* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((float*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[651])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[651])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (double* pvalues = &values)
			{
				CalculateBinsNative((double*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((double*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((double*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(double* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref double values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (double* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((double*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(byte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[652])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[652])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(byte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref byte values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				CalculateBinsNative((byte*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(byte* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref byte values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((byte*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(byte* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref byte values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((byte*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(byte* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref byte values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (byte* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((byte*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(short* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[653])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[653])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(short* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref short values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (short* pvalues = &values)
			{
				CalculateBinsNative((short*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(short* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref short values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((short*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(short* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref short values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((short*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(short* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref short values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (short* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((short*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(ushort* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[654])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[654])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ushort* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				CalculateBinsNative((ushort*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ushort* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((ushort*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ushort* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((ushort*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ushort* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ushort values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (ushort* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((ushort*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(int* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[655])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[655])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(int* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref int values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (int* pvalues = &values)
			{
				CalculateBinsNative((int*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(int* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref int values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((int*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(int* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref int values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((int*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(int* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref int values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((int*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(uint* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[656])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[656])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(uint* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref uint values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				CalculateBinsNative((uint*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(uint* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref uint values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((uint*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(uint* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref uint values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((uint*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(uint* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref uint values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (uint* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((uint*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<long*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[657])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[657])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref long values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (long* pvalues = &values)
			{
				CalculateBinsNative((long*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref long values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((long*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref long values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((long*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(long* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref long values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (long* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((long*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CalculateBinsNative(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong*, int, ImPlotBin, ImPlotRange, int*, double*, void>)funcTable[658])(values, count, meth, range, binsOut, widthOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, ImPlotBin, ImPlotRange, nint, nint, void>)funcTable[658])((nint)values, count, meth, range, (nint)binsOut, (nint)widthOut);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			CalculateBinsNative(values, count, meth, range, binsOut, widthOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, double* widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				CalculateBinsNative((ulong*)pvalues, count, meth, range, binsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, widthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, double* widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					CalculateBinsNative((ulong*)pvalues, count, meth, range, (int*)pbinsOut, widthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (double* pwidthOut = &widthOut)
			{
				CalculateBinsNative(values, count, meth, range, binsOut, (double*)pwidthOut);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, int* binsOut, ref double widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative((ulong*)pvalues, count, meth, range, binsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ulong* values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (int* pbinsOut = &binsOut)
			{
				fixed (double* pwidthOut = &widthOut)
				{
					CalculateBinsNative(values, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalculateBins(ref ulong values, int count, ImPlotBin meth, ImPlotRange range, ref int binsOut, ref double widthOut)
		{
			fixed (ulong* pvalues = &values)
			{
				fixed (int* pbinsOut = &binsOut)
				{
					fixed (double* pwidthOut = &widthOut)
					{
						CalculateBinsNative((ulong*)pvalues, count, meth, range, (int*)pbinsOut, (double*)pwidthOut);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLeapYearNative(int year)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[659])(year);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[659])(year);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool IsLeapYear(int year)
		{
			byte ret = IsLeapYearNative(year);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetDaysInMonthNative(int year, int month)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[660])(year, month);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[660])(year, month);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetDaysInMonth(int year, int month)
		{
			int ret = GetDaysInMonthNative(year, month);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MkGmtTimeNative(ImPlotTime* pOut, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, Tm*, void>)funcTable[661])(pOut, ptm);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[661])((nint)pOut, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkGmtTime(Tm* ptm)
		{
			ImPlotTime ret;
			MkGmtTimeNative(&ret, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ImPlotTimePtr pOut, Tm* ptm)
		{
			MkGmtTimeNative(pOut, ptm);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ref ImPlotTime pOut, Tm* ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MkGmtTimeNative((ImPlotTime*)ppOut, ptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkGmtTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				MkGmtTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ImPlotTimePtr pOut, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				MkGmtTimeNative(pOut, (Tm*)pptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkGmtTime(ref ImPlotTime pOut, ref Tm ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				fixed (Tm* pptm = &ptm)
				{
					MkGmtTimeNative((ImPlotTime*)ppOut, (Tm*)pptm);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Tm* GetGmtTimeNative(ImPlotTime t, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, Tm*, Tm*>)funcTable[662])(t, ptm);
			#else
			return (Tm*)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, nint>)funcTable[662])(t, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetGmtTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = GetGmtTimeNative(t, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetGmtTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = GetGmtTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MkLocTimeNative(ImPlotTime* pOut, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, Tm*, void>)funcTable[663])(pOut, ptm);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[663])((nint)pOut, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkLocTime(Tm* ptm)
		{
			ImPlotTime ret;
			MkLocTimeNative(&ret, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ImPlotTimePtr pOut, Tm* ptm)
		{
			MkLocTimeNative(pOut, ptm);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ref ImPlotTime pOut, Tm* ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MkLocTimeNative((ImPlotTime*)ppOut, ptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MkLocTime(ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				ImPlotTime ret;
				MkLocTimeNative(&ret, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ImPlotTimePtr pOut, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				MkLocTimeNative(pOut, (Tm*)pptm);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MkLocTime(ref ImPlotTime pOut, ref Tm ptm)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				fixed (Tm* pptm = &ptm)
				{
					MkLocTimeNative((ImPlotTime*)ppOut, (Tm*)pptm);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Tm* GetLocTimeNative(ImPlotTime t, Tm* ptm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, Tm*, Tm*>)funcTable[664])(t, ptm);
			#else
			return (Tm*)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, nint>)funcTable[664])(t, (nint)ptm);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetLocTime(ImPlotTime t, Tm* ptm)
		{
			Tm* ret = GetLocTimeNative(t, ptm);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Tm* GetLocTime(ImPlotTime t, ref Tm ptm)
		{
			fixed (Tm* pptm = &ptm)
			{
				Tm* ret = GetLocTimeNative(t, (Tm*)pptm);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTimeNative(ImPlotTime* pOut, int year, int month, int day, int hour, int min, int sec, int us)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, int, int, int, int, int, int, int, void>)funcTable[665])(pOut, year, month, day, hour, min, sec, us);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, int, int, int, int, int, void>)funcTable[665])((nint)pOut, year, month, day, hour, min, sec, us);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, (int)(0), (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year)
		{
			MakeTimeNative(pOut, year, (int)(0), (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, (int)(0), (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month)
		{
			MakeTimeNative(pOut, year, month, (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, (int)(0), (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day)
		{
			MakeTimeNative(pOut, year, month, day, (int)(0), (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, min, (int)(0), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour)
		{
			MakeTimeNative(pOut, year, month, day, hour, (int)(0), (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, min, sec, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour, int min)
		{
			MakeTimeNative(pOut, year, month, day, hour, min, (int)(0), (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime MakeTime(int year, int month, int day, int hour, int min, int sec, int us)
		{
			ImPlotTime ret;
			MakeTimeNative(&ret, year, month, day, hour, min, sec, us);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour, int min, int sec, int us)
		{
			MakeTimeNative(pOut, year, month, day, hour, min, sec, us);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ImPlotTimePtr pOut, int year, int month, int day, int hour, int min, int sec)
		{
			MakeTimeNative(pOut, year, month, day, hour, min, sec, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour, int min, int sec, int us)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, min, sec, us);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour, int min, int sec)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, min, sec, (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour, int min)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, min, (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day, int hour)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, hour, (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month, int day)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, day, (int)(0), (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year, int month)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, month, (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MakeTime(ref ImPlotTime pOut, int year)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				MakeTimeNative((ImPlotTime*)ppOut, year, (int)(0), (int)(1), (int)(0), (int)(0), (int)(0), (int)(0));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetYearNative(ImPlotTime t)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, int>)funcTable[666])(t);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, int>)funcTable[666])(t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetYear(ImPlotTime t)
		{
			int ret = GetYearNative(t);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, int, void>)funcTable[667])(pOut, t, unit, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, int, void>)funcTable[667])((nint)pOut, t, unit, count);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime AddTime(ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			ImPlotTime ret;
			AddTimeNative(&ret, t, unit, count);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			AddTimeNative(pOut, t, unit, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void AddTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit, int count)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				AddTimeNative((ImPlotTime*)ppOut, t, unit, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FloorTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, void>)funcTable[668])(pOut, t, unit);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, void>)funcTable[668])((nint)pOut, t, unit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime FloorTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			FloorTimeNative(&ret, t, unit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FloorTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			FloorTimeNative(pOut, t, unit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void FloorTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				FloorTimeNative((ImPlotTime*)ppOut, t, unit);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CeilTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, void>)funcTable[669])(pOut, t, unit);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, void>)funcTable[669])((nint)pOut, t, unit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime CeilTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			CeilTimeNative(&ret, t, unit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CeilTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			CeilTimeNative(pOut, t, unit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CeilTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				CeilTimeNative((ImPlotTime*)ppOut, t, unit);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RoundTimeNative(ImPlotTime* pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTimeUnit, void>)funcTable[670])(pOut, t, unit);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTimeUnit, void>)funcTable[670])((nint)pOut, t, unit);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime RoundTime(ImPlotTime t, ImPlotTimeUnit unit)
		{
			ImPlotTime ret;
			RoundTimeNative(&ret, t, unit);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RoundTime(ImPlotTimePtr pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			RoundTimeNative(pOut, t, unit);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void RoundTime(ref ImPlotTime pOut, ImPlotTime t, ImPlotTimeUnit unit)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				RoundTimeNative((ImPlotTime*)ppOut, t, unit);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombineDateTimeNative(ImPlotTime* pOut, ImPlotTime datePart, ImPlotTime timePart)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImPlotTime*, ImPlotTime, ImPlotTime, void>)funcTable[671])(pOut, datePart, timePart);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImPlotTime, ImPlotTime, void>)funcTable[671])((nint)pOut, datePart, timePart);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImPlotTime CombineDateTime(ImPlotTime datePart, ImPlotTime timePart)
		{
			ImPlotTime ret;
			CombineDateTimeNative(&ret, datePart, timePart);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineDateTime(ImPlotTimePtr pOut, ImPlotTime datePart, ImPlotTime timePart)
		{
			CombineDateTimeNative(pOut, datePart, timePart);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CombineDateTime(ref ImPlotTime pOut, ImPlotTime datePart, ImPlotTime timePart)
		{
			fixed (ImPlotTime* ppOut = &pOut)
			{
				CombineDateTimeNative((ImPlotTime*)ppOut, datePart, timePart);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FormatTimeNative(ImPlotTime t, byte* buffer, int size, ImPlotTimeFmt fmt, byte use24HrClk)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, byte*, int, ImPlotTimeFmt, byte, int>)funcTable[672])(t, buffer, size, fmt, use24HrClk);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, int, ImPlotTimeFmt, byte, int>)funcTable[672])(t, (nint)buffer, size, fmt, use24HrClk);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatTime(ImPlotTime t, byte* buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			int ret = FormatTimeNative(t, buffer, size, fmt, use24HrClk ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatTime(ImPlotTime t, ref byte buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FormatTimeNative(t, (byte*)pbuffer, size, fmt, use24HrClk ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatTime(ImPlotTime t, ref string buffer, int size, ImPlotTimeFmt fmt, bool use24HrClk)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FormatTimeNative(t, pStr0, size, fmt, use24HrClk ? (byte)1 : (byte)0);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FormatDateNative(ImPlotTime t, byte* buffer, int size, ImPlotDateFmt fmt, byte useIso8601)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, byte*, int, ImPlotDateFmt, byte, int>)funcTable[673])(t, buffer, size, fmt, useIso8601);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, int, ImPlotDateFmt, byte, int>)funcTable[673])(t, (nint)buffer, size, fmt, useIso8601);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDate(ImPlotTime t, byte* buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			int ret = FormatDateNative(t, buffer, size, fmt, useIso8601 ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDate(ImPlotTime t, ref byte buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FormatDateNative(t, (byte*)pbuffer, size, fmt, useIso8601 ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDate(ImPlotTime t, ref string buffer, int size, ImPlotDateFmt fmt, bool useIso8601)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FormatDateNative(t, pStr0, size, fmt, useIso8601 ? (byte)1 : (byte)0);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FormatDateTimeNative(ImPlotTime t, byte* buffer, int size, ImPlotDateTimeSpec fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImPlotTime, byte*, int, ImPlotDateTimeSpec, int>)funcTable[674])(t, buffer, size, fmt);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImPlotTime, nint, int, ImPlotDateTimeSpec, int>)funcTable[674])(t, (nint)buffer, size, fmt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDateTime(ImPlotTime t, byte* buffer, int size, ImPlotDateTimeSpec fmt)
		{
			int ret = FormatDateTimeNative(t, buffer, size, fmt);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDateTime(ImPlotTime t, ref byte buffer, int size, ImPlotDateTimeSpec fmt)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FormatDateTimeNative(t, (byte*)pbuffer, size, fmt);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int FormatDateTime(ImPlotTime t, ref string buffer, int size, ImPlotDateTimeSpec fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buffer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buffer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buffer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FormatDateTimeNative(t, pStr0, size, fmt);
			buffer = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShowDatePickerNative(byte* id, int* level, ImPlotTime* t, ImPlotTime* t1, ImPlotTime* t2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int*, ImPlotTime*, ImPlotTime*, ImPlotTime*, byte>)funcTable[675])(id, level, t, t1, t2);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, byte>)funcTable[675])((nint)id, (nint)level, (nint)t, (nint)t1, (nint)t2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte ret = ShowDatePickerNative(id, level, t, t1, t2);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			byte ret = ShowDatePickerNative(id, level, t, t1, (ImPlotTime*)(((void*)0)));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t)
		{
			byte ret = ShowDatePickerNative(id, level, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, t, t1, t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, t, t1, (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, t, t1, t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, t, t1, (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ImPlotTimePtr t)
		{
			fixed (byte* pid = id)
			{
				byte ret = ShowDatePickerNative((byte*)pid, level, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowDatePickerNative(pStr0, level, t, t1, t2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowDatePickerNative(pStr0, level, t, t1, (ImPlotTime*)(((void*)0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ShowDatePickerNative(pStr0, level, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(id, (int*)plevel, t, t1, t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(id, (int*)plevel, t, t1, (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ImPlotTimePtr t)
		{
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(id, (int*)plevel, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, t1, t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, t1, (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ImPlotTimePtr t)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, t1, t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, t1, (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ImPlotTimePtr t)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(pStr0, (int*)plevel, t, t1, t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(pStr0, (int*)plevel, t, t1, (ImPlotTime*)(((void*)0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ImPlotTimePtr t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				byte ret = ShowDatePickerNative(pStr0, (int*)plevel, t, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, t1, t2);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ref ImPlotTime t)
		{
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(id, level, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, t1, t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, int* level, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, t1, t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, int* level, ref ImPlotTime t)
		{
			fixed (byte* pid = id)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative((byte*)pid, level, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, t1, t2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, int* level, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (ImPlotTime* pt = &t)
			{
				byte ret = ShowDatePickerNative(pStr0, level, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, t1, t2);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, ref int level, ref ImPlotTime t)
		{
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(id, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, t1, t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ref byte id, ref int level, ref ImPlotTime t)
		{
			fixed (byte* pid = &id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, t1, t2);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(ReadOnlySpan<byte> id, ref int level, ref ImPlotTime t)
		{
			fixed (byte* pid = id)
			{
				fixed (int* plevel = &level)
				{
					fixed (ImPlotTime* pt = &t)
					{
						byte ret = ShowDatePickerNative((byte*)pid, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1, ImPlotTimePtr t2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, t1, t2);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t, ImPlotTimePtr t1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, t1, (ImPlotTime*)(((void*)0)));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(string id, ref int level, ref ImPlotTime t)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (int* plevel = &level)
			{
				fixed (ImPlotTime* pt = &t)
				{
					byte ret = ShowDatePickerNative(pStr0, (int*)plevel, (ImPlotTime*)pt, (ImPlotTime*)(((void*)0)), (ImPlotTime*)(((void*)0)));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ShowDatePicker(byte* id, int* level, ImPlotTimePtr t, ref ImPlotTime t1, ImPlotTimePtr t2)
		{
			fixed (ImPlotTime* pt1 = &t1)
			{
				byte ret = ShowDatePickerNative(id, level, t, (ImPlotTime*)pt1, t2);
				return ret != 0;
			}
		}
	}
}
